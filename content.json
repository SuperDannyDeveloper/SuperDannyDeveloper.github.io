[{"title":"CocoaPods之iOS组件化开发:远程私有库","date":"2018-07-31T11:21:00.000Z","path":"2018/07/31/CocoaPods-private-podspec/","text":"随着公司的不断发展，业务领域越来越广泛，团队也在不断壮大，那么随着项目的增多，我们越来越感觉到重复工作的情况越来越频繁，于是封装了很多工具类和第三方库等等便于集成。但是集成的方式却非常低效，都是直接将需要用到的类添加到工程里面。这样子不便于管理。所以搭建私有库非常有必要。本篇文章需要有一定的知识基础。 创建私有库搭建私有库有两种方案：一种是搭建在公司服务器(内网/外网)上，另一种是托管在第三方平台上面。目前我使用的是第二套方案。由于是私有库，GitHub私有库是收费的，加上没资金(穷)所以没办法放在上面，只能选择其他平台，目前可支持免费私有库的平台有Coding，码云，Bitbucket等。我们先创建一个私有库，我选择的是Bitbucket平台。因为私有库数量没有限制，所以暂且选择这个平台。说干就干！然后我们将私有库Clone到本地，本次选用Sourcetree进行管理。 创建本地CocoaPods索引库关于CocoaPods的，我之前有文章写过相关知识的，需要脑补的童鞋先过一遍。CocoaPods安装过程CocoaPods之repo换源和gem换源如何从项目中移除CocoaPods(译) 接下来我们继续，一般我们安装CocoaPods之后会在本地有一个仓库，仓库里面会有所有使用CocoaPods的开源项目的索引库。现在，把我们自己的远程索引库下载到本地，和CocoaPods的官方索引库在同一级目录。在终端输入: pod repo add 仓库名 仓库源地址(SSH地址)例如我输入的是: pod repo add XXModule https://XXX@bitbucket.org/Apple_Developer/xxmodule.git 12# pod repo add 仓库名 仓库源地址(SSH地址)pod repo add XXModule https://XXX@bitbucket.org/Apple_Developer/xxmodule.git 创建完后，会在多出一个目录，这个目录就是专门用于当做本地索引库用。我们也可以不创建，直接使用远程的就行。 后续操作及补充说明后续的操作这边直接引用网友写的一篇文章iOS组件化开发:远程私有库，写的还算是比较细致的。这边做一个补充说明。里面的大概步骤如下：1、创建远程私有库2、将私有库Clone到本地3、创建本地索引库-指令pod repo add 仓库名 仓库源地址(SSH地址)4、创建一个模板库-指令pod lib create 远程仓库名5、将需要继承的类库添加到Classes文件夹下面，同时删除里面默认创建的ReplaceMe.m文件6、再cd到测试工程目录，执行pod install指令会安装我们刚才拖入的类库7、打开测试工程，已经有我们的类库了，现在配置xxx.podspec文件(文件具体说明详情见上面的文章)8、本地仓库开发完毕之后，借助Sourcetree将整个工程push到远端私有库上面同时打一个tag10、校验操作，分本地跟远端校验11、上传索引库并在工程内测试 subspec子模块化当我们封装了大量的组件之后，有时候只想使用其中的某一个组件，不希望一次性导入大量的组件时。子模块的优势就显现出来。比如我们在Classes目录下有XXScanA，XXScanB，XXScanC，XXScanD等多个组件，然后我的新项目只需要引入组件XXScanA，那么就需要在.podspec文件里面配置。具体配置如下： 12345678910s.subspec 'XXScanA' do |xxScanA| xxScanA.source_files = 'XXXModuleYModule/Classes/XXScanA/*.&#123;h,m&#125;' xxScanA.libraries = 'iconv','z' xxScanA.vendored_libraries = 'XXModule/Classes/ThirdParty/*.&#123;a&#125;' xxScanA.resource = 'XXModule/Classes/LBXScan/UI/CodeScan.bundle' xxScanA.dependency 'ZBarSDK', '~&gt; 1.3.1' xxScanA.dependency 'XXModule/XXScanB' xxScanA.ios.frameworks = 'AVFoundation', 'CoreGraphics', 'CoreMedia', 'CoreVideo', 'ImageIO', 'QuartzCore' xxScanA.prefix_header_contents = '#import \"xxx.h\"','#import \"xxx.h\"' end 说明 参数 说明 .source_files 这里的路径是相对于.podspec文件位置的路径 .libraries 添加依赖的系统library .vendored_libraries 添加第三方.a文件 .resource 如果有包含资源文件，则需要次参数 .dependency 添加第三方依赖 .ios.frameworks 添加依赖的系统framework .prefix_header_contents 类似于pch文件，多个用逗号隔开 校验在将我们的私有库提交的时候，会先进行校验操作。这里说下我这边出现的情况以及使用对应的校验指令。验证有两种，一种是本地校验.podspec文件，另一种是远程校验.podspec文件。需要注意的是，校验需要cd到.podspec文件所在目录进行。远程校验需要事先将工程push到远端私有库上面，同时打上tag。有时候我们可能在同一个tag上面进行多次修改，比如当前tag版本是0.1.0。这个时候，应该先将tag0.1.0移除，然后给最新的提交点重新打上tag0.1.0。 删除标签 使用旧标签版本号 1234# 本地校验pod lib lint# 远程校验pod spec lint 这里说明下，最好加上参数，便于定位问题。所以应该是如下写法： 1234# 本地校验--allow-warnings忽略编译警告，--verbose打印日志，--use-libraries(有引用framwork框架或C语言库时，需加入此参数)，XXModule.podspec(指定校验仓库，不指定时会遍历当前目录所有仓库)pod lib lint --allow-warnings XXModule.podspec --verbose --use-libraries# 远程校验pod spec lint --allow-warnings XXModule.podspec --verbose --use-libraries 上传索引库本地跟远程校验都成功之后，我们就可以更新索引文件到本地索引库跟远端私有库上面，执行以下指令 123# pod repo push 索引库名 索引文件名 # --allow-warnings忽略编译警告，--use-libraries(有引用framwork框架或C语言库时，需加入此参数)pod repo push XXModule XXModule.podspec --use-libraries --allow-warnings 说明：这个命令，其实先把索引文件推送到本地CocoaPods的索引库，在由本地的CocoaPods推送到我们的远程私有索引库。所以，这一步操作之后，CocoaPods索引库和我们远程私有索引库都有了这个索引文件，不用再去推送到本地CocoaPods索引库了。 我们在编译类库时，难免存在警告，最好先解决警告，再编译检查。但是，如果需要忽略编译警告，则要添加额外参数--allow-warnings设置。 另外一开始搭建CocoaPods时，使用了官方的模板指令pod lib create 远程仓库名创建的工程，都会帮我们创建两个文件夹。一个是Classes，另一个是Assets，当我们执行pod repo push 索引库名 索引文件名 --use-libraries --allow-warnings更新索引库的指令之后，这两个文件夹也会跟着被下载到本地索引库里面，等执行完上面的指令之后再删除即可。不然本地测试会报错。 如果执行上面的指令之后报如下错误： 1[!] The repo `索引库名` at `../.cocoapods/repos/索引库名` is not clean 解决办法：先执行下面的指令更新下我们的版本库，再继续执行上面的指令上传即可。 1pod repo update 索引库名 测试本地跟远端最后我们在以后项目的Podfile文件里面只需要如下写法即可： 12345678source 'https://xxx@bitbucket.org/xxx/xxmodule.git'source 'https://github.com/CocoaPods/Specs.git'platform :ios, '8.0'target 'XXModule_Example' do pod 'XXModule/XXScanA','~&gt; 0.1.0'end 终端运行pod install后，会默认从GitHub上搜索公开库，因此，我们需要在Podfile上指明我们的私有库的地址，在Podfile最顶部添加如下代码： 123456# 格式：source '私有/公有库地址'，可以放多个source# 这个是GitHub上公有库的地址，没有这个，pod就不会去公有库查询，就不能下载公有库的东西source 'https://github.com/CocoaPods/Specs.git'# 这个是私有库的地址，如果没有这个，就不能下载私有库的东西source 'https://xxx@bitbucket.org/xxx/xxmodule.git' 最后大功告成！🎉 参考资料教程相关：iOS组件化开发:远程私有库CocoaPods集成和使用创建CocoaPods私有podspecCOCOAPODS创建私有PODS创建私有CocoaPods仓库使用私有Cocoapods仓库 中高级用法创建属于自己的私有库CocoaPods 私有仓库的创建（超详细）iOS组件化解决方案(私有pod、热更新、个推、友盟等知识点） 问题相关：cocoapods迭代版本时，出现问题The NAME.podspec specification does not validateCocoapods项目添加Cocoapods支持遇到的坑CocoaPods 问题和解决 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"终端","slug":"终端","permalink":"superdanny.link/tags/终端/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"superdanny.link/tags/CocoaPods/"}]},{"title":"2018，我的年中工作总结","date":"2018-07-03T15:10:00.000Z","path":"2018/07/03/2018-Mid-year-work-summary/","text":"出于公司的战略发展原因，今年的总结将改为半年一次工作总结。年中年底各一次小结，同时年底一次全方面总结。18年，一个特殊之年，也是我第四个年头写总结了，每一年的总结都有所收获，有所成长。本次重点在总结上半年工作情况以及下半年的计划。 前言回首3年前刚入职那会，我还只是一个项目的开发者，到现在可以参与项目的探讨、评估与开发并且独自承担起一个项目的重任。这对于我来说是一个莫大的进步。虽然工作量大了，但是我却乐此不疲，因为这让我的开发水平与开发速度有了质的提升。以前我只会盲目的按照需求打代码，而现如今，我能根据功能的合理性判定是否应该按照需求来开发。这看起来不起眼，但是却体现了我从以往只会以开发的角度思考问题到现在能够站在用户使用习惯和体验的角度多方面思考问题。虽然自身角色没有转变，但是思考的层面却有所不同。我也不再仅仅只是为了开发而开发。 在这最近的半年来，有过收获与喜悦，也有过遗憾与无奈。在工作上虽然无法保证每件事都能百分之百做到最好，但是对待每一件事我都是全身心投入。俗话说金无足赤，人无完人。但是这不能成为我往后工作的借口，因为人总要学会成长。 参与其中，乐此不疲这半年来，我工作上的重心就是将云澳门项目重新整改与优化。在增加“招聘”版块和“活动”板块等新功能的同时，我也开始对其他现有模块进行了彻底重构。其中包括了“商家”模块、“会员汇”模块、“卡券”模块、“订单”模块、“我的”模块以及“登录注册”模块。在这过程中，一开始会觉得有趣和自信，但随着项目的开展，慢慢的也会出现疲倦。因为随着项目的开展，会遇到各种各样的问题，不管是沟通也好，业务意见不统一也罢，都会将一个原本信心十足的人逐渐击垮。为此，我特意给自己定了一些小目标来强制自己认真对待并重新调整态度做事。比如，当你开发的比较疲乏又突然提不起兴趣的时候。先暂停当前手头上的工作，选一个你感兴趣的技术领域并能够运用到现有项目中进行优化，这样不仅可以提升自己的能力水平，而且能够激起你工作的热情，两全其美，何乐而不为之。 角色转变，换位思考我感到高兴的是，公司领导对所有部门都广开言路，每一个部门都有了表达自己想法与观点的发言权。现在的云澳门项目，说广泛一些包括之后的很多项目，也越来越多同事愿意表达自己的观点。先不说对项目起到多大的作用，相比以往的确认需求和功能点后立马着手开发的行云流水式开发流程而言，这种先讨论再确定方向和可行性分析的方式是值得赞赏的。因为它可以有效降低新需求失败的风险，将公司的资源更有效的整合并应用到更值得开展的领域上。 因为每个同事有了更多发言权，探讨项目以及方向的会议也就变得越来越频繁。大家的观点和想法也就越来越多，每个人在激烈的讨论中擦出灵感的火花。而我也置身其中，站在对方的角度思考对方的观点。这让我对部门间考虑问题的层次不同有了新的认识。经过几番探讨与自身体验了一把项目之后，有以下几点是导致以往项目失败的直接原因： 广撒网战略导致功能杂而不实 就比如云澳门项目，虽然功能点很多，也是市场普遍需求的功能，但是里面却很少有一个功能能够做到既简单又实用，有时候甚至没办法用起来。所以以往的广撒网战略还是有些行不通。 资源少而乱，体验差 很多功能点有了以后，资源成为了一大问题。由于没有资源的支撑，是导致功能无用武之地的致命原因。而即便有了资源，当初的软件体验却无法吸引用户去深入了解并使用它。所以不但需要有资源，体验也是项目成败的一个重要因素。 项目开发前期缺乏对市场的分析 市场真正需要什么，我的观点并不能代表所有人的观点，需要市场部的同事真正去感受并调查一番。也就是公司CEO常说的抓住用户痛点。找到突破口，直达用户内心最渴望的需求。 不愿抛弃冗余功能 功能的冗余让项目变得越来越庞大，同时维护起来也变得困难许多。有些功能看起来就像是为了充数放进去。但是真正会用的人确实很少。应该将重心着重放在一两个功能点上，不断的提升其资源量。 在公司领导的大力支持下，在各部门同事的积极配合下，上面提及的几点问题，在后面项目开展中，领导层都纳入了项目评估标准中，这使得云澳门的发展方向更加的清晰。同时对以后其他项目起到至关重要的带头作用。 有效合理利用时间为了提高在公司的工作效率，我会抽空将一些琐碎的代码整理并封装。因为一天8小时的正常工作时间是很有限的(加班时间除外)，如何将时间更有效的利用，就需要把时间和精力用到刀刃上，而不能将时间浪费在一些繁琐而又枯燥的无需太多思考的重复工作上面。那么如何将这些繁琐的工作时间省下来？ 养成代码封装整理的好习惯 将通用的功能点抽离，做成通用的类库提供给外部调用。既方便了以后的项目开发，又为开发省下不少时间。 自动化操作 将一些繁琐的打包工作交给计算机执行。平时打包是一件重复而又枯燥且浪费时间的事情，于是我在网上查阅并学习了相关的知识之后，编写了一些打包脚本，实现自动化操作。同时也共享给了部门的同事，方便大家使用。 善于总结问题 当项目开发过程中经常遇到同样的问题时，就应该总结原因，避免下一次出现类似的事情。这也是节省开发时间的关键。因为同样的问题出现只会让自己浪费一些时间来处理问题。以前刚踏入iOS开发这一行时，我总会遇到一些低级的问题，而且不是一次两次的事情，但是经过追根溯源之后，找到问题所在，在以后的开发过程中规避这种问题。 存在的不足在工作中，我还有有一些不足的地方需要改进，并向同事学习。 资源共享委员工作做得不够努力 在今年年初的时候，在公司IT部周总监的鼓励和推动下，成立了资源共享委员会。作为委员会的带头人，我觉得我做的不够好。因为发现我的很多时间精力都难以投入到这一块工作上面，虽然偶尔会分享一些零散的技术干货，但是这远远不是我一个人能够完成的事情，需要大家一起共同完成。这也是我需要反思并努力改进的地方。 管理及专业知识的提升不够快速 工作中我感觉到自己专业知识、管理知识的匮乏，提升的速度并不是很快。一个人在公司要有所成长，唯一的途径就是学习他人的长处，弥补自身的不足。今后我将要在这两个方面加强学习，从同事中学习他们的优点，提升自身综合素质，全面发展。 集体荣誉感不够强 虽然我每次都很积极的参与公司组织的各项活动，同时也认真对待每一项工作任务。但是在做好工作方面，我仍然欠缺一种集体荣誉感，因为只有保持这种荣誉感，在对待工作和其他事情上面才会多一分心思去思考如何做到更好。 下半年计划在工作上 务实与拼搏：保持一股冲劲，认真对待每一项工作任务。认真总结每日工作情况，从中总结问题与经验； 提升与创新：提升自身专业知识，使之更有效的运用到项目中并提高程序的执行效率； 谦虚与上进：成为管培生之后，应保持一种谦虚的学习态度，认真努力学习更多管理的相关知识； 共享与互助：努力推进资源共享委员会的开展，做到“我为人人”的核心宗旨； 交流与配合：积极参与公司以及部门团队建设工作，提高自己在团队的默契与责任感。积极配合领导以及相关部门同事的工作安排。 在生活上 丰富阅历：今年读的课外读物还是比较少，应该多读一些相关的书籍，丰富自己的阅历，自我升华； 身体素质：继续坚持锻炼。保持良好的身体素质，才能更好的投入到工作中去；","tags":[{"name":"年中总结","slug":"年中总结","permalink":"superdanny.link/tags/年中总结/"}]},{"title":"iOS静态库实战之Framework","date":"2018-06-26T14:55:00.000Z","path":"2018/06/26/iOS-StaticLibrary-Framework/","text":"需求由于喜欢琢磨一些技术，这块领域其实已经好多年就有人发表相关的技术文章，但是自己没有亲手实战一次还真不能说是自己学到这门技术。前段时间研究了一下并动手做了一个静态库。效果挺好，也达到了我想要的预期结果并运用到了我实际项目中。今天重新翻看了一些资料，发现还有完善的地方，特意记录一下，方便后期查阅。 战前准备之.a与.framework库的区别 总结：同一个静态库在不同程序中使用时，每一个程序中都得导入一次，打包时也被打包进去，形成一个程序。而动态库在不同程序中，打包时并没有被打包进去，只在程序运行使用时，才链接载入（如系统的框架如UIKit、Foundation等），所以程序体积会小很多，但是苹果不让使用自己的动态库，否则审核就无法通过。 好了，已经了解了两种类型库的区别之后我们就开始动手制作自己的静态库吧。😄 制作静态库时的几点注意1、注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。 2、图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。 3、category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。 4、如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。 制作Framework静态库第一步 创建项目 第二步 创建需要封装的类或者将需要封装的第三方类加进项目里面 第三步 修改项目配置1、设置需要公开的头文件 2、修改生成的Mach-O格式 3、将项目的最低支持系统版本设置成iOS 8，可根据自己实际情况设置 这里需要注意的是公开的头文件里 import 了其他类也得添加到 public 中公开出来。如果不想将 import 的类公开出来，那么在头文件中用@class然后在对应的 .m 文件中再 import。 需要注意的是默认的Architectures是不包含armv7s，如果需要支持该架构，需要配置一下 第四步 创建通用静态库执行脚本1、创建Target 2、创建Run Script脚本 3、编写执行脚本 1234567891011121314151617181920212223242526272829303132# Sets the target folders and the final framework product.# 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME# ----这种方式仅仅适合非pods形式的打包---# 例如: FMK_NAME = \"MyFramework\"FMK_NAME=$&#123;PROJECT_NAME&#125;# FMK_NAME = \"TestFamework\"# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;FMK_NAME&#125;.framework# Working dir will be deleted after the framework creation.WRK_DIR=buildDEVICE_DIR=$&#123;WRK_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;WRK_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework# -configuration $&#123;CONFIGURATION&#125;# Clean and Building both architectures.xcodebuild -configuration \"Release\" -target \"$&#123;FMK_NAME&#125;\" -sdk iphoneos clean buildxcodebuild -configuration \"Release\" -target \"$&#123;FMK_NAME&#125;\" -sdk iphonesimulator clean build# Cleaning the oldest.if [ -d \"$&#123;INSTALL_DIR&#125;\" ]thenrm -rf \"$&#123;INSTALL_DIR&#125;\"fimkdir -p \"$&#123;INSTALL_DIR&#125;\"cp -R \"$&#123;DEVICE_DIR&#125;/\" \"$&#123;INSTALL_DIR&#125;/\"# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.lipo -create \"$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;\" \"$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;\" -output \"$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;\"rm -r \"$&#123;WRK_DIR&#125;\"open \"$&#123;INSTALL_DIR&#125;\" 第五步 选中新建的Target，Run，如果没有异常的话，会自动弹出生成的Framework文件 制作Framework静态库，同时引用第三方类库我们有时候封装一个静态库可能会引用到第三方的类库，这个时候，如果我们直接将类库封装进入静态库里面的话，刚好其他工程里面也存在这个类库，那么就容易引起冲突。解决的方案也是有的：方案1：直接修改其中一个类库重命名(这种方式不是很好)方案2：分离类库，不将第三方类库打入静态库类，只保留引用(此方式要求其他工程手动引入第三方类库) 下面我会以方案2进行实战讲解。 新建工程的步骤同上面是一样的，这里就不多讲，直接从引入第三方类库开始。 方式一：直接拖拽第三方类库到工程并生成静态库1、将需要的类库拖拽进工程里面 2、直接在需要使用的地方导入头文件#import &quot;MBProgressHUD.h&quot; 3、接下来就是跟之前一样用脚本打包的方式生成对应的通用静态库 方式二：通过CocoaPods方式引用第三方类库并生成静态库1、跟平时使用CocoaPods方式一样，我们在Podfile文件里面写上需要使用的第三方类库 12345platform :ios, \"9.0\" target 'TestFramework' do pod 'MBProgressHUD'end 2、之后我们配置下Scheme 3、分别选择模拟器跟真机编译两个不同版本静态库 4、将编译好的两个.framework静态库用指令合并成一个 1lipo -create xFramework-iphoneos.framework/xFramework xFramework-iphonesimulator.framework/xFramework -output /Users/superdanny/Downloads/framework/xFramework(xFramework为合成后的静态库名称) 这里需要注意一点，当我们的-output导出路径参数设置不同时，产生的结果也会不同。 结果1：比如有/Users/superdanny/Downloads/framework这个目录的时候，将导出路径参数设置为/Users/superdanny/Downloads/framework。那么就会产生一个跟framework文件夹同级且同名的framework.lipo的文件。同时终端也会报一个错误，这种情况，我们只需要将后缀.lipo去掉，并且将文件名改为静态库名称。然后执行下文图片中说到的替换操作。 结果2：同样有/Users/superdanny/Downloads/framework这个目录的时候，但是我们将导出路径参数设置为/Users/superdanny/Downloads/framework/xFramework。此时就会在framework文件夹下产生一个名为xFramework的文件。之后我们直接执行下文图片中说到的替换操作即可。 正确的做法应该是用第二种。 指令参数说明 参数 说明 xFramework-iphoneos.framework/xFramework 真机静态库 xFramework-iphonesimulator.framework/xFramework 模拟器静态库 /Users/superdanny/Downloads/framework/xFramework 合成后文件存放路径 大功告成！🎉 验证最后我们来验证下Framework支持哪些架构，相关指令格式如下： 1234# 验证Framework$ lipo -info /Users/.../xFramework.framework/xFramework# 验证.a$ lipo -info /Users/.../libXYPlatform.a 123456# 没有添加armv7s之前的支持架构$ lipo -info /Users/superdanny/Out/动态包/CoreAppStatus/Products/CoreAppStatus.framework/CoreAppStatus$ Architectures in the fat file: /Users/superdanny/Out/动态包/CoreAppStatus/Products/CoreAppStatus.framework/CoreAppStatus are: armv7 i386 x86_64 arm64# 添加armv7s之后的支持架构$ lipo -info /Users/superdanny/Out/动态包/CoreAppStatus/Products/CoreAppStatus.framework/CoreAppStatus$ Architectures in the fat file: /Users/superdanny/Out/动态包/CoreAppStatus/Products/CoreAppStatus.framework/CoreAppStatus are: armv7 armv7s i386 x86_64 arm64 应用我们新建一个工程Test-Framework，然后集成我们的静态库，编写测试用例。 来看看最后集成静态库Demo展示效果： 参考资料iOS中.a与.framework库的区别Xcode 6制作动态及静态Framework关于ios开发framework及.a文件支持架构判断以及合并iOS Xcode9 封装生成.frameworkIOS-静态库(.a、framewrok)、动态库(.tbd、framework)、Bundle制作(适用于静态库的)研究 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"Framework","slug":"Framework","permalink":"superdanny.link/tags/Framework/"}]},{"title":"使用AppleDoc快速生成iOS开发文档","date":"2018-06-19T02:30:00.000Z","path":"2018/06/19/iOS-AppleDoc/","text":"需求一个公司随着时间的推移会慢慢的成长起来，这也就意味着公司的队伍也会不断的壮大。在壮大的同时需要保证团队开发的规范性。这样有益于后期维护，同时也能够培养团队的协作能力。软件开发一直是公司的核心部门，那么作为 iOS开发部 的成员之一，就更应该积极做好各项工作。这次我就啰里啰嗦的整理一下网上的关于 AppleDoc 生成开发文档的相关知识点。此文章需要有一定的指令基础的童鞋学习，不然看了会比较吃力。有不懂的需要自行脑补一下，这里就不再累赘。 安装打开终端，执行指令进行下载安装 123$ git clone git://github.com/tomaz/appledoc.git$ cd ./appledoc$ sudo sh install-appledoc.sh 当出现 INSTALL SUCCEEDED 时说明成功了，你也可以用appledoc –version查看验证下。如果可以正常执行下面指令则证明安装成功，否则需要查看报错说明。 1234# 查看版本号$ appledoc --version# 查看更多文档信息$ appledoc --help 使用 使用终端进入代码目录 直接拖拽我们的工程文件夹到终端，然后按回车键或者使用 cd+”项目名字目录”，然后按回车键以上两种方法都可以进入到我们的工程根目录 指令用法及参数说明 1234567891011# 参考指令写法1(不生成docset文件)$ appledoc --no-create-docset --output ./doc --project-name \"QQ\" --company-id \"com.tencent.QQ\" --project-company \"Tencent Inc.\" /Users/superdanny/Desktop/QQ-Project/QQ/Views# 参考指令写法2(不生成docset文件，参数使用“=”等号写法)$ appledoc --no-create-docset --output=\"./doc\" --project-name=\"QQ\" --company-id=\"com.tencent.QQ\" --project-company=\"Tencent Inc.\" /Users/superdanny/Desktop/QQ-Project/QQ/Views# 参考指令写法3(生成docset文件并指定生成路径)$ appledoc --output ./doc --project-name \"QQ\" --company-id \"com.tencent.QQ\" --project-company \"Tencent Inc.\" /Users/superdanny/Desktop/QQ-Project/QQ/Views --docset-install-path ./doc# 以上都是扫描指定目录下的文件，如果想扫描当前目录所有文件，只需要将指定目录换成\".\"即可$ appledoc --no-create-docset --output=\"./doc\" --project-name=\"QQ\" --company-id=\"com.tencent.QQ\" --project-company=\"Tencent Inc.\" . 参数说明 参数 说明 –no-create-docset (选填参数)只生成html，不生成docset文件。如果需要生成，则去掉该参数即可 –output (必填参数)生成结果输出路径，如“./doc”，会在工程目录下创建一个doc文件夹存放生成的文档。当然你可以指定一个完整的目录路径存放生成的文档 –project-name (必填参数)工程名字，如“QQ” –project-company (必填参数)公司名字，如“Tencent Inc.” –company-id (选填参数)公司ID，如“com.tencent.QQ”，会生成文件名为companyID.projectName.docset的docset文件。如果不设置，则文件名为com.companyname.projectname.projectName.docset –docset-install-path (选填参数)生成docset文件的目录。如果此目录不设置，默认会在~/Library/Developer/Shared/Documentation/DocSets/目录生成 /Users/superdanny/Desktop/QQ-Project/QQ/Views 扫描对应路径下的类，如果想扫描当前目录所有文件，则将此路径换成.即可 如果是生成docset文件，则--output参数对应的目录会生成一个 docset-installed.txt 文件，里面记录docset存放的目录。如果是不生成docset文件，则--output参数对应的目录会生成html文件。直接打开 index.html 文件即可查看。 支持的注释下面是一些常用的语法示意: 单行注释/// 这是单行注释。 /** 这也是单行注释 */ /*! 同样是单行注释 */ /** 这也是单行注释， * 第二行会接上第一行。 */ 多行注释/** @brief 这里是方法的简介。仅对属性、方法有效，对类、协议 无效，会造成后续内容解析失败。所以该指令不能放到类注释里。 @param string 参数描述。 @return 返回值描述。 @exception NSException 可能抛出的异常。 @warning 这里是警告描述。 @bug 这里是缺陷描述。 @see 用它来指明其他相关的method或function。你可以使用多个这种标签。 @sa 同@see。 */ 注意事项 @brief、@see、@sa仅对属性、方法有效，对类、协议 无效，会造成后续内容解析失败。所以该指令不能放到类注释里。 @see &lt;name&gt; @sa &lt;name&gt; 其中&lt;name&gt;为： 1) 当前类（或协议）中的属性或方法。（注意Objective-C方法签名的写法，一般为“方法名:参数1:参数2:⋯⋯”的格式） 2) 类（或协议）名。（注意AppleDoc不支持当前类） 3) 将@see或@sa指令放在注释的最后面，避免内容丢失 类注释/** 第一行是类的简介 在简介的下面,就是类的详细介绍了。 没有间隔换行会被消除，就像HTML那样。 下面是常用的markdown语法 分割线： - - - 无序列表: (每行以 &apos;*&apos;、&apos;-&apos;、&apos;+&apos; 开头): * this is the first line * this is the second line * this is the third line 有序列表: (每行以 1.2.3、a.b.c 开头): a. this is the first line b. this is the secode line 多级列表: * this is the first line a. this is line a b. this is line b * this is the second line 1. this in line 1 2. this is line 2 标题: # This is an H1 ## This is an H2 ### This is an H3 #### This is an h4 ##### This is an h5 ###### This is an H6 链接: 普通URL直接写上，appledoc会自动翻译成链接: http://superdanny.link 这个 [链接](http://example.net/) 会隐藏实际URL. 表格: | header1(默认) | header2(居中) | header3(左对齐) | header4(右对齐) | |---------|:-------:|:--------|--------:| | normal | center | left | right | | cell | cell | cell | cell | 引用: 这里会引用到方法 `pinyinFromChiniseString:`，这里会引用到类 `AreaListViewController` 这里会引用到一个代码块。具体办法是在每行内容的前面按tab键进行缩进，不然会无法正常识别。 void CMYK2RGB(float c, float m, float y, float k, float *r, float *g, float *b) { *r = (1 - c) * (1 - k); *g = (1 - m) * (1 - k); *b = (1 - y) * (1 - k); } */ 最后我们来看看效果怎么样吧😁 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"工具","slug":"工具","permalink":"superdanny.link/tags/工具/"},{"name":"AppleDoc","slug":"AppleDoc","permalink":"superdanny.link/tags/AppleDoc/"}]},{"title":"2017，我的年终总结","date":"2018-01-02T11:49:00.000Z","path":"2018/01/02/2017-Year-end-summary/","text":"已经是第三个年头写总结了，感觉写总结是对自己人生计划的一个负责，毕竟每个人都有自己的理想计划，总结这一年来自己成长了多少，完成了多少年前计划，漏掉忽略了多少，是否有什么成就或者遗憾，来年的计划等等。写总结也不能像记流水账一样草草了事，不然就没有任何意义。 工作回顾2016年的总结，觉得今年自己在工作中有了一股冲劲，因为随着年纪的增长，很多事情担子都会落在自己的肩上，自己也要扛起家庭这个重担。所以你不得不更加的努力。 项目启发今年公司项目还算是松紧有致，中旬跟年尾都是比较忙的时候，项目也都能够如期上线并更新迭代。唯一不足的地方就是公司推出的产品对市场了解还不够全面，投入的资金没有用到刀刃上，导致上线之后无法真正运营起来。这一点对一个开发者而言无疑是一个痛点，因为自己亲手开发的程序，到最后却无用武之地，自豪感就大打折扣。 分析导致出现这种情况的原因有如下几点： 项目立项之前缺少对市场的调查，即市场需求定向分析。这导致了项目推出市场之后反响不是很大的必然结果； 项目立项之后产品原型缺乏前期的逻辑业务分析。这导致了项目开发过程中存在各种逻辑不通，业务不流畅的情况发生，导致浪费了太多时间在探讨和核对上面； 项目开发过程中缺乏主观意识认定，即开发人员对产品的不足之处无法真正否定，默许的结果就是开发出一款不尽人意的产品； 项目上线之后缺乏对市场的反馈总结，一味的进行盲目增减业务。导致项目的初衷慢慢偏移轨道； 雲社團 这个项目对于我来说算是一个转折点，让我重新对自己有一个新的认知以及自我反省。因为当初开发时，信誓旦旦的给出预估开发时间，等到后面真正开发时，我才发现事情并没有想象中那么简单，作为一个高端技术人才(IT民工)，一心想着往管理方向进军，能够从中学到技术外的东西，不断提升自己的能力。这个过程并没那么容易。虽然我知道，在业务不变的大前提下，开发时间(这里仅仅指程序开发到上线这个过程)一般包含程序设计-&gt;测试反馈问题-&gt;解决问题-&gt;进一步回归测试并确认无误-&gt;提交审核。但是我发现，在预估时间这个环节上，我犯了一个错误，那就是没有清晰完整的了解这个项目业务的前提下，盲目笼统的进行时间预估。这导致了我后期开发时间紧迫，以至于那个月要经常加班的情况。 同时，这个项目发生的一起事件，也让我对网络数据安全方面更加的重视。以往都知道项目安全问题至关重要，但是到了实际开发过程中却又忽略了这个重要因素。一方面是公司项目以往对核心项目的重要操作做了加密处理，比如支付。但是部分项目开发中是完全没有将加密作为开发的一部分考虑。另一方面，自己对自身的要求不够高，明知公司开发的项目存在一些不足，但是却没有主动提出。两方面导致了这起泄密风波的发生。从这次事件中，也让我清楚的认识到，应该要将网络安全攻防放在第一位，因为用户的信息是宝贵的。APP能不能让用户用的放心，保护隐私以及数据传输安全是至关重要的因素。 泄密风波之后，项目组立马提出解决方案： 改用HTTPS请求方式(阻挡住新手级别的抓包方式) 获取服务器时间戳作为参数之一，所有参数MD5，并用RSA进行签名之后传输给服务器(阻挡住大部分的攻击者，因为破解成本很高) 补充更新：2018年03月16日 上面方案第二点改为：将提交的参数连同时间戳这个参数组成的JSON进行排序(根据参数名)，之后将整个JSON字符串进行MD5加密，并用RSA进行签名之后传输给服务器。 在最终方案确认之前，参数并非使用MD5加密，而是直接URL编码，这样的坏处在于不同语言的兼容性问题。相同内容在 iOS 跟 Android 还有 C# 上面 URL编码 的结果会有所不同。这样就导致客户端需要针对部分特殊字符进行转换之后再传输，一来浪费太多时间在兼容上，每发现一处不同就得对应做兼容。二来考虑到该方案会用在目前所有项目以及往后项目开发中。所以最终决定使用MD5进行参数加密。 虽然服务器验签过程会消耗一点点性能，但是可以忽略不计，总的来说可以接受。至少数据传输上保证了安全性。 开源精神这一年里，我对自己说过最多的一句话就是，“工作上，要求自己一定要做好每一件事，不给自己找任何借口”。 个人方面，继续秉承开源的精神，不断的开源各种功能代码。目的是为了让后期的项目开发以及工作成本得到更恰到好处的利用，同时也给后人方便。 年底的时候，IT部门也举办了一次部门团建活动(召开了一场座谈会)，目的是想了解员工们的真实想法。本人也倡议公司成立一个技术知识共享委员会，目的是将开发过程中或者业余时间封装抽离的功能分享出来，给组内或者其他部门学习。同时也节省后期项目开发的时间成本。这既能锻炼同事对代码的敏感度以及养成共享精神，又能促进部门间的交流。同时初步建立一套企业知识WIKI库，方便同事查阅。目的都是为了让大家的能力有所提升，同时节省大家的宝贵时间。 我相信，通过这种方式，养成开源共享精神，个人的能力一定会有更好的提升空间。 生活今年，又回到单身生活😭，开支方面少了许多，但是却更加注重自身的投资。 业余生活也慢慢更加丰富起来，经常会跟朋友出去玩，喝点小酒，聊聊想法等等。所以一定不能宅在家，这样只会限制你的思维和想法。多在外面接触事物还是有好处的。 饮食方面也更加健康，上半年工作不是很忙的时候，会自己煮饭，带饭到公司。那时候体重减了10斤，算是健康饮食带来的好处。因为长期叫外卖，吃的都是油盐比较重的食物，对身体没什么好处。下半年工作忙起来，加上冬天到了，比较懒，所以下半年，体重回升了好几斤😂。等过完年后，要重新自己做饭，健康的饮食还是很重要的。 健身方面，夏季的时候，会经常去游泳，个人非常喜欢游泳，偶尔下班会去跑步。出了一身汗之后，晚上睡眠质量会好很多，第二天也很精神，做起事来比较有干劲。毕竟身体素质决定工作效率，这一点是毋庸置疑的。 家庭本人因为长期在外地工作，很少能够回到家中，一年就两次长假会回一趟家。陪伴家人的时间也就变得很宝贵，所以本人在去年的时候就开始计划，一年陪家人去旅行一趟，这样子也算是对父母的一种关心和孝顺。多陪陪父母是好事，毕竟养育了我这么多年，挺不容易，也是时候懂得感恩。所以今年春节的时候打算一家人出去外面旅游8天，计划好了旅游路线以及需要准备的旅行物品之后，就开始操办这件事。 我本人很少旅游，又是第一次准备这么长久的计划。加上没什么经验，所以那时候很晚才确定了到云南玩8天，因为是春节旅游旺季，所以机票什么的都比较贵。算是汲取经验，以后计划至少得提前一个半月开展。 理财投资今年一整年，除了工作上面的固定收入外。投资和其他方面收入加起来也有上万收入，虽然不多，但是对于我来说，2017年只是一个开始，2018年才是重头戏😏。 我这个人最不喜欢把钱放银行，拿那点破利息都不够晒牙缝(其实就是因为穷，钱不多😅)。我从大学那会就有了理财的观念，当初第一次理财是支付宝刚推出余额宝项目，那时候的收益是7%左右，相比放银行利润是非常高的。后面发现余额宝收益慢慢开始不行，我就转战其他领域——基金。那时候发现某些基金收益蛮高的。于是我每次交学费都没拿去交，而是投入到了基金上面，那时候一学期的学费大概是1w多一些，加上父母每次是转一学期的伙食费给我，所以这边全部拿去投资。选择那种活期类型，需要用到钱就取出来一些。到了学期末，学校催交学费，我才把钱拿出来交学费，从中赚点利息费。虽然不多，但是这对我后面投资起到至关重要的作用。 另外我这个人也喜欢记账，一开始接触记账是在大学快毕业那年，那时候记账频率不是很高，到现在记账已经成为我生活中不可欠缺的一部分，每天3笔账是必不可少的。不管是什么，只要涉及到资金变动的，我都会记录起来，而且越来越娴熟，分类也越来越人性化。不知不觉，我已经保持记账的习惯3年多了。偶尔会翻看以往的记账情况。分析自己的资金变动情况。合理的分配投资领域。 新年计划最后，希望自己在新的一年里，更懂事一些，更成熟一些，更理性一些，更孝顺一些，更大胆一些。 💼工作方面，希望新的一年能够有更多的机会向公司表达反馈自己及同事的真实想法与需求。争取做到一个沟通桥梁的作用。不让同事的想法被埋没。能够秉持共享精神，将此重任进行到底。同时虚心学习每个人的优点，反省自己的不足。 💻技术方面，打算学习go语言，不积极跟上潮流的程序员不是一个合格的程序员。所以我不想落后其中，这也算是对自己的鞭策。 🏖生活方面，对自己的健康需要更加的注重，年纪越大，身体机能也会大不如从前，干我们这一行的就更应该注重自己的身体健康问题。毕竟以后如果结婚了还有一家老小等着自己去养活。 👨‍👩‍👧‍👦家庭方面，争取每年带家人出去旅行，或者让父母能够享受二人世界的旅行。百善孝为先，多注重父母的健康问题是儿女应该做的。 💰理财方面，继续根据自己的想法出发，多方位投资。降低投资风险。提高投资回报率。虽然理财方面我相对来说还是个新手，但是我会在这个领域慢慢成长起来。","tags":[{"name":"年终总结","slug":"年终总结","permalink":"superdanny.link/tags/年终总结/"}]},{"title":"iOS更改AppIcon","date":"2017-07-03T10:44:00.000Z","path":"2017/07/03/iOS-Alternate-Icon/","text":"前言iOS 10.3出了挺多的新功能，其中有一个就是可以自定义更改AppIcon。这个功能以前我们只能在苹果的时钟上面看出来。但是一直没有对外开放。现在开放出来，也算是一种突破。 实现苹果在iOS 10.3中，多了一个setAlternateIconName:completionHandler:方法用于更改AppIcon。 1、我们先创建一个工程，然后在Info.plist文件里面新建一个CFBundleIcons,然后在里面配置可替换的AppIcon。 具体plist配置如下： 1234567891011121314151617181920212223242526272829&lt;key&gt;CFBundleIcons&lt;/key&gt;&lt;dict&gt; &lt;key&gt;CFBundlePrimaryIcon&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;AppIcon&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;key&gt;CFBundleAlternateIcons&lt;/key&gt; &lt;dict&gt; &lt;key&gt;icon01&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;icon01&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;key&gt;icon02&lt;/key&gt; &lt;dict&gt; &lt;key&gt;CFBundleIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;icon02&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UIPrerenderedIcon&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 2、将所有要替换的AppIcon加进工程里面，这里需要注意的是，不能放在Assets.xcassets里面，否则无效。 3、代码实现： 123456789101112131415161718192021222324252627282930//替換icon- (void)changeIconButtonClick:(NSUInteger)index &#123; if ([UIApplication sharedApplication].supportsAlternateIcons) &#123; NSLog(@\"你可以更換icon\"); [[UIApplication sharedApplication] setAlternateIconName:_iconArr[index] completionHandler:^(NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@\"成功更換成%@\",_iconArr[index]); &#125;else&#123; NSLog(@\"error:%@\",error); &#125; &#125;]; &#125; else &#123; NSLog(@\"非常抱歉，你不能更換icon\"); return; &#125;&#125; //還原icon- (void)backToPrimaryIconAction:(id)sender &#123; if ([UIApplication sharedApplication].alternateIconName != nil) &#123; //已經被替換掉了圖標 [[UIApplication sharedApplication] setAlternateIconName:nil completionHandler:^(NSError * _Nullable error) &#123; if (!error) &#123; NSLog(@\"成功還原圖標\"); &#125; else &#123; NSLog(@\"error:%@\",error); &#125; &#125;]; &#125;&#125; 最终效果如下 附上写好的Demo 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"动态icon","slug":"动态icon","permalink":"superdanny.link/tags/动态icon/"}]},{"title":"数值类型(金额)限制与判断","date":"2017-06-16T05:36:00.000Z","path":"2017/06/16/iOS-Limit-the-number-format/","text":"前言一般对于支付或者涉及数值输入时，都会判断输入是否符合规范。比如有这么一个需求，我希望能够限制输入的内容只能是两位小数的浮点型。那么这个时候我想到的就是两种办法，一种就是使用正则，一种就是监听输入内容进行判断。下面我将针对我自己的需求：限制输入小数位数以及整数位数进行判断。 代码写的有点不尽完美，但是已经满足自己的需求了。可灵活变通，一旦有完善的会及时更新代码。下面的代码直接放在UITextField的- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string代理方法里面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @author LvChanghui, 15-08-07 14:08:01 * * 限制输入数字格式（整数位数以及小数位数） * * @param textField 当前文本框 * @param nextStr 当前输入的字符 * @param range 输入字符的rang位置 * @param intLength 整数位置长度 * @param pointLength 小数位置长度 * * @return 是否允许继续输入 */+ (BOOL)limitTheNumberTextField:(UITextField *)textField andNextString:(NSString *)nextStr andRang:(NSRange)range andIntLength:(NSUInteger)intLength andPointLength:(NSUInteger)pointLength &#123; //当前文本框的字符串 NSString *currentStr = textField.text; //拼接出最新的字符串 NSString *number = [self getResultString:currentStr andNextString:nextStr andRang:range]; //第一個輸入\".\"，則自動補全成\"0.\" if ([textField.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]].length == 0 &amp;&amp; [nextStr isEqualToString:@\".\"]) &#123; textField.text = @\"0.\"; return NO; &#125; //如果第一个数字是0，且下一个字符为数字，则清空0，将下一个数字作为结果 if (number.length&gt;=2) &#123; NSString *tempNum = [number substringToIndex:2]; if (([tempNum isEqualToString:@\"00\"] || [tempNum isEqualToString:@\"01\"] || [tempNum isEqualToString:@\"02\"] || [tempNum isEqualToString:@\"03\"] || [tempNum isEqualToString:@\"04\"] || [tempNum isEqualToString:@\"05\"] || [tempNum isEqualToString:@\"06\"] || [tempNum isEqualToString:@\"07\"] || [tempNum isEqualToString:@\"08\"] || [tempNum isEqualToString:@\"09\"]) &amp;&amp; [CheckTools isPureInt:nextStr]) &#123; textField.text = [number substringFromIndex:1]; return NO; &#125; &#125; //如果删除之后只剩下小数点，则直接清空文本框 if ([number isEqualToString:@\".\"]) &#123; textField.text = @\"\"; return NO; &#125; if (number.length == 0) &#123; return YES; &#125; //第一位是\".\"，然后整个字符串满足数字类型，则自动补全第一位 if ([[number substringToIndex:1] isEqualToString:@\".\"]) &#123; textField.text = [@\"0\" stringByAppendingString:number]; return NO; &#125; //整數部份長度 NSString *zhengShu = [NSString stringWithFormat:@\"%ld\", [number integerValue]]; NSUInteger tempIntLength = zhengShu.length; //小數部份長度，包括小數點 NSUInteger tempPointLength = [number substringFromIndex:tempIntLength].length; if (tempIntLength &gt; intLength || tempPointLength &gt; pointLength+1) &#123; return NO; &#125; //如果小數部份長度為0，說明限制數字為整數 if (pointLength == 0) &#123; if ([CheckTools isPureInt:number]) &#123; //如果没有小数点，但是第一位数字确是0开头，则不允许输入 if (![number containsString:@\".\"] &amp;&amp; number.length &gt; 1 &amp;&amp; [[number substringToIndex:1] isEqualToString:@\"0\"]) &#123; return NO; &#125; return YES; &#125; return NO; &#125; else &#123; if ([CheckTools isPureFloat:number]) &#123; //如果没有小数点，但是第一位数字确是0开头，则不允许输入 if (![number containsString:@\".\"] &amp;&amp; number.length &gt; 1 &amp;&amp; [[number substringToIndex:1] isEqualToString:@\"0\"]) &#123; return NO; &#125; return YES; &#125; return NO; &#125;&#125;#pragma mark - 获取输入文本框字符串+ (NSString *)getResultString:(NSString *)currentStr andNextString:(NSString *)nextStr andRang:(NSRange)range &#123; //拼接出最新的字符串 NSMutableString *string = currentStr.mutableCopy; if (nextStr.length) &#123; [string insertString:nextStr atIndex:range.location]; &#125; else &#123; [string replaceCharactersInRange:range withString:nextStr]; &#125; return string;&#125; 下面看看具体使用方式： 1234567891011#pragma mark - UITextFieldDelegate- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123; if (string.length) &#123; //设置整数部分最多2位，小数部分长度为0 BOOL b = [AmountTools limitTheNumberTextField:textField andNextString:string andRang:range andIntLength:2 andPointLength:0]; //如果需要实时获取文本框的值，可以使用下面的方法 NSString *tempStr = [AmountTools getResultString:textField.text andNextString:string andRang:range]; return b; &#125; return YES;&#125; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"金额","slug":"金额","permalink":"superdanny.link/tags/金额/"},{"name":"数值","slug":"数值","permalink":"superdanny.link/tags/数值/"}]},{"title":"IJKPlayer相关指南","date":"2017-05-09T07:32:00.000Z","path":"2017/05/09/iOS-IJKPlayer/","text":"需求公司以前的直播业务是用Flash开发。为了适应趋势，从去年开始，公司打算使用原生进行开发。这里整理了一些相关的资料。对自己以后也许有所帮助。所谓前人种树，后人乘凉。在此，感谢所有默默无闻分享自己一线经验的老前辈们。 参数相关IJKFFOptions参数说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//打开h265硬解ijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, \"mediacodec-hevc\", 1);/*-------------CodecOption-------------*///解码参数，画面更清晰[options setCodecOptionIntValue:IJK_AVDISCARD_DEFAULT forKey:@\"skip_loop_filter\"];[options setCodecOptionIntValue:IJK_AVDISCARD_DEFAULT forKey:@\"skip_frame\"];//以下是直播、点播参数设置不同if (直播) &#123; // Param for living //最大缓存大小是3秒，可以依据自己的需求修改 [options setPlayerOptionIntValue:3000 forKey:@\"max_cached_duration\"]; //无限读 [options setPlayerOptionIntValue:1 forKey:@\"infbuf\"]; //关闭播放器缓冲 [options setPlayerOptionIntValue:0 forKey:@\"packet-buffering\"];&#125; else &#123; // Param for playback [options setPlayerOptionIntValue:0 forKey:@\"max_cached_duration\"]; [options setPlayerOptionIntValue:0 forKey:@\"infbuf\"]; [options setPlayerOptionIntValue:1 forKey:@\"packet-buffering\"];&#125;/*-------------PlayerOption-------------*///在视频帧处理不过来的时候丢弃一些帧达到同步的效果//跳帧开关，如果cpu解码能力不足，可以设置成5，否则会引起音视频不同步，也可以通过设置它来跳帧达到倍速播放[options setPlayerOptionIntValue:5/*0*/ forKey:@\"framedrop\"];//最大fps[options setPlayerOptionIntValue:30 forKey:@\"max-fps\"];//帧速率(fps) 可以改，确认非标准桢率会导致音画不同步，所以只能设定为15或者29.97[options setPlayerOptionIntValue:29.97 forKey:@\"r\"];//设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推）[options setPlayerOptionIntValue:512 forKey:@\"vol\"];//指定最大宽度[options setPlayerOptionIntValue:960 forKey:@\"videotoolbox-max-frame-width\"];//开启/关闭 硬解码（硬件解码CPU消耗低。软解，更稳定）[options setPlayerOptionIntValue:0 forKey:@\"videotoolbox\"];//是否有声音[options setPlayerOptionIntValue:1 forKey:@\"an\"];//是否有视频[options setPlayerOptionIntValue:1 forKey:@\"vn\"];//每处理一个packet之后刷新io上下文[options setPlayerOptionIntValue:1 forKey:@\"flush_packets\"];//是否禁止图像显示(只输出音频)[options setPlayerOptionIntValue:1 forKey:@\"nodisp\"];//[options setPlayerOptionIntValue:0 forKey:@\"start-on-prepared\"];//[options setPlayerOptionIntValue:@\"fcc-_es2\" forKey:@\"overlay-format\"];//[options setPlayerOptionIntValue:3 forKey:@\"video-pictq-size\"];//[options setPlayerOptionIntValue:25 forKey:@\"min-frames\"];/*-------------FormatOption-------------*///如果是rtsp协议，可以优先用tcp(默认是用udp)[options setFormatOptionValue:@\"tcp\" forKey:@\"rtsp_transport\"];//播放前的探测Size，默认是1M, 改小一点会出画面更快[options setFormatOptionIntValue:1024*16*0.5 forKey:@\"probsize\"];//播放前的探测时间[options setFormatOptionIntValue:50000 forKey:@\"analyzeduration\"];//自动转屏开关[options setFormatOptionIntValue:0 forKey:@\"auto_convert\"];//重连次数[options setFormatOptionIntValue:1 forKey:@\"reconnect\"];//超时时间，timeout参数只对http设置有效。若果你用rtmp设置timeout，ijkplayer内部会忽略timeout参数。rtmp的timeout参数含义和http的不一样。[options setFormatOptionIntValue:30 * 1000 * 1000 forKey:@\"timeout\"];//[options setFormatOptionIntValue:@\"nobuffer\" forKey:@\"fflags\"];//[options setFormatOptionIntValue:@\"ijkplayer\" forKey:@\"user-agent\"];//[options setFormatOptionIntValue:0 forKey:@\"safe\"];//[options setFormatOptionIntValue:0 forKey:@\"http-detect-range-support\"];//[options setFormatOptionIntValue:4628439040 forKey:@\"ijkapplication\"];//[options setFormatOptionIntValue:6176477408 forKey:@\"ijkiomanager\"]; 注意skip_loop_filter参数相关 1234567891011// for codec option 'skip_loop_filter' and 'skip_frame'typedef enum IJKAVDiscard &#123; /* We leave some space between them for extensions (drop some * keyframes for intra-only or drop just some bidir frames). */ IJK_AVDISCARD_NONE =-16, ///&lt; discard nothing IJK_AVDISCARD_DEFAULT = 0, ///&lt; discard useless packets like 0 size packets in avi IJK_AVDISCARD_NONREF = 8, ///&lt; discard all non reference IJK_AVDISCARD_BIDIR = 16, ///&lt; discard all bidirectional frames IJK_AVDISCARD_NONKEY = 32, ///&lt; discard all frames except keyframes IJK_AVDISCARD_ALL = 48, ///&lt; discard all&#125; IJKAVDiscard; 前面两个都看得懂第三个是抛弃非参考帧（I帧）第四个是抛弃B帧第五个是抛弃除关键帧以外的，比如B，P帧第六个是抛弃所有的帧，这我就奇怪了，之前Android默认的就是48，难道把所有帧都丢了？那就没有视频帧了，所以应该不是这么理解，应该是skip_loop_filter和skip_frame的对象要过滤哪些帧类型。 skip_loop_filter这个是解码的一个参数，叫环路滤波，设置成48和0，图像清晰度对比，0比48清楚，理解起来就是，0是开启了环路滤波，过滤的是大部分，而48基本没启用环路滤波，所以清晰度更低，但是解码性能开销小skip_loop_filter（环路滤波）简言之：a:环路滤波器可以保证不同水平的图像质量。b:环路滤波器更能增加视频流的主客观质量，同时降低解码器的复杂度。 具体参考：http://blog.csdn.net/h514434485/article/details/52241778http://www.cnblogs.com/TaigaCon/p/5500110.htmlskip_frame我没完全理解意思，应该是等同上面这个类似。 相关问题以及解决方案1、达不到秒开，首屏显示慢，后来把播放前探测时间改为1 //播放前的探测时间[options setFormatOptionIntValue:1 forKey:@”analyzeduration”]; 2、音画不同步，有同事发现在模拟器的情况下音画不同步，刚开始理解以为是CPU处理画面处理不过来，所以加了framedrop参数 做了丢帧处理，后来才明白是因为模拟器处理效率低，不需要做丢帧处理 //开启硬解码（硬件解码CPU消耗低。软解，更稳定）[options setPlayerOptionIntValue:1 forKey:@”videotoolbox”]; 3、延迟产生的原因以及优化 产生原因保证直播的流畅性是指在直播过程中保证播放不发生卡顿，卡顿是指在播放过程中声音和画面出现停滞，非常影响用户体验。造成卡顿的原因有几种情况:(1) 推流端网络抖动导致数据无法发送到服务器，造成播放端卡顿;(2) 播放端网络抖动导致数据累积在服务器上拉不下来，造成播放卡顿。由于从服务器到播放器的网络情况复杂，尤其是在3G和带宽较差的WIFI环境下，抖动和延迟经常发生，导致播放不流畅，播放不流畅带来的负面影响就是延时增大。如何在网络抖动的情况下保证播放的流畅性和实时性是保障直播性能的难点。 流畅度优化目前主流的直播协议是RTMP、HTTP-FLV和HLS，都是基于TCP的长连接。在播放的过程中，若播放端所处的网络环境在一个较佳的状态，此时播放会很流畅。若网络环境不是很稳定，经常会发生抖动，如果播放端没有做特殊处理，可能会经常发生卡顿，严重的甚至会出现黑屏。而移动直播由于其便捷性，用户可以随时随地发起和观看直播，我们无法保证用户的网络一直处于一个非常好的状态，所以，在网络不稳定的情况下保证播放的流畅度是非常重要的。为了解决这个问题，首先播放器需要将拉流线程和解码线程分开，并建立一个缓冲队列用于缓冲音视频数据。拉流线程将从服务器上获取到的音视频流放入队列，解码线程从队列中获取音视频数据进行解码播放，队列的长度可以调整。当网络发生抖动时，播放器无法从服务器上获取到数据或获取数据的速度较慢，此时队列中缓存的数据可以起到一个过渡的作用，让用户感觉不到网络发生了抖动。当然这是对于网络发生抖动的情况所采取的策略，如果播放端的网络迟迟不能恢复或者服务器的边缘结点 出现宕机，则需要应用层进行重连或调度。 4、软硬编解码的选择软编解码：使用CPU进行编解码，大多使用FFmpeg来编码和解压音视频数据；硬编解码：主要使用非CPU进行编解码，如GPU等。在使用中，大多直接调用系统API进行音视频编解码处理。 优点 缺点 软编解码 在不同的设备、系统版本中兼容性极高；解码时，色彩还原度更高；编解码过程可扩展性强； CPU占用高，手机易发热，耗电量大。 硬编解码 系统占用少，执行效率高。 兼容性低，需根据硬件厂商和系统版本单独适配；可控性比较差； 综合以上情况，在推流方面，iOS系统和硬件设备统一性高，使用全硬编方案效果更好；Android因机型繁杂，支持程度不一，推荐4.3以上使用硬编。在播放解码方面，iOS硬解和软解支持性都较高，软解功耗更高，但是在部分细节方面表现较优，可控性强，具体视项目情况选择；Android推荐4.1版本以上使用硬解，以下版本使用软解。 未完待续… 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"ijkPlayer","slug":"ijkPlayer","permalink":"superdanny.link/tags/ijkPlayer/"}]},{"title":"扩展NSDecimalNumber实现高精度金额计算","date":"2017-04-27T09:35:00.000Z","path":"2017/04/27/iOS-High-precision-calculation02/","text":"前言之前转过一篇谈论NSDecimalNumber实现金融类等高精度计算的文章。现在将自己完善封装的工具类放出来，供大家使用。如果有任何优化改善的地方，麻烦留言。 NSString+Calculate.h文件 12345678910111213141516171819202122@interface NSString (Calculate)///加上bString- (NSString *)stringByAdding:(NSString *)bString;///减去bString- (NSString *)stringBySubtracting:(NSString *)bString;///乘以bString- (NSString *)stringByMultiplyingBy:(NSString *)bString;///除以bString- (NSString *)stringByDividingBy:(NSString *)bString;///是否大于bString- (BOOL)isBig:(NSString *)bString;///比较两个数大小- (NSComparisonResult)ob_compare:(NSString *)bString;///去掉尾巴是0或者.的位数(10.000 -&gt; 10 // 10.100 -&gt; 10.1)- (NSString *)ridTail;///保留数据类型2位小数(如果是10.000 -&gt; 10 // 10.100 -&gt; 10.1)+ (NSString *)formatterNumber:(NSNumber *)number;///保留数据类型fractionDigits位小数+ (NSString *)formatterNumber:(NSNumber *)number fractionDigits:(NSUInteger)fractionDigits;@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135@implementation NSString (Calculate)- (NSString *)stringByAdding:(NSString *)bString &#123; NSString *aString = self; if ([NSString filterNULLValue:aString].length == 0) &#123; aString = @\"0\"; &#125; if ([NSString filterNULLValue:bString].length == 0) &#123; bString = @\"0\"; &#125; NSDecimalNumber *a = [[NSDecimalNumber alloc]initWithString:aString]; NSDecimalNumber *b = [[NSDecimalNumber alloc]initWithString:bString]; NSDecimalNumber *c = [a decimalNumberByAdding:b]; NSString *cString = [NSString stringWithFormat:@\"%@\", c]; NSString *rid = [cString ridTail]; return rid;&#125;- (NSString *)stringBySubtracting:(NSString *)bString &#123; NSString *aString = self; if ([NSString filterNULLValue:aString].length == 0) &#123; aString = @\"0\"; &#125; if ([NSString filterNULLValue:bString].length == 0) &#123; bString = @\"0\"; &#125; NSDecimalNumber *a = [[NSDecimalNumber alloc] initWithString:aString]; NSDecimalNumber *b = [[NSDecimalNumber alloc] initWithString:bString]; NSDecimalNumber *c = [a decimalNumberBySubtracting:b]; NSString *cString = [NSString stringWithFormat:@\"%@\", c]; NSString *rid = [cString ridTail]; return rid;&#125;- (NSString *)stringByMultiplyingBy:(NSString *)bString &#123; NSString *aString = self; if ([NSString filterNULLValue:aString].length == 0) &#123; aString = @\"0\"; &#125; if ([NSString filterNULLValue:bString].length == 0) &#123; bString = @\"0\"; &#125; NSDecimalNumber *a = [[NSDecimalNumber alloc] initWithString:aString]; NSDecimalNumber *b = [[NSDecimalNumber alloc] initWithString:bString]; NSDecimalNumber *c = [a decimalNumberByMultiplyingBy:b]; NSString *cString = [NSString stringWithFormat:@\"%@\", c]; NSString *rid = [cString ridTail]; return rid;&#125;- (NSString *)stringByDividingBy:(NSString *)bString &#123; NSString *aString = self; if ([NSString filterNULLValue:aString].length == 0) &#123; aString = @\"0\"; &#125; if ([NSString filterNULLValue:bString].length == 0) &#123; bString = @\"0\"; &#125; if ([[bString ridTail] isEqualToString:@\"0\"]) &#123; NSLog(@\"除数为0\"); return @\"0\"; &#125; NSDecimalNumber *a = [[NSDecimalNumber alloc] initWithString:aString]; NSDecimalNumber *b = [[NSDecimalNumber alloc] initWithString:bString]; NSDecimalNumber *c = [a decimalNumberByDividingBy:b]; NSString *cString = [NSString stringWithFormat:@\"%@\", c]; NSString *rid = [cString ridTail]; return rid; return [NSString stringWithFormat:@\"%@\", c];&#125;- (BOOL)isBig:(NSString *)bString &#123; NSString *aString = self; if ([NSString filterNULLValue:aString].length == 0) &#123; aString = @\"0\"; &#125; if ([NSString filterNULLValue:bString].length == 0) &#123; bString = @\"0\"; &#125; NSDecimalNumber *a = [[NSDecimalNumber alloc] initWithString:aString]; NSDecimalNumber *b = [[NSDecimalNumber alloc] initWithString:bString]; if ([a compare:b] == NSOrderedAscending) &#123;//上升 return NO; &#125; else if ([a compare:b] == NSOrderedDescending) &#123;//下降 return YES; &#125; else &#123;//相等 return NO; &#125;&#125;- (NSComparisonResult)ob_compare:(NSString *)bString &#123; NSString *aString = self; if ([NSString filterNULLValue:aString].length == 0) &#123; aString = @\"0\"; &#125; if ([NSString filterNULLValue:bString].length == 0) &#123; bString = @\"0\"; &#125; NSDecimalNumber *a = [[NSDecimalNumber alloc] initWithString:aString]; NSDecimalNumber *b = [[NSDecimalNumber alloc] initWithString:bString]; return [a compare:b];&#125;- (NSString *)ridTail &#123; NSString *string = self; if (![string containsString:@\".\"]) &#123; return string; &#125; if ([string hasSuffix:@\"0\"]) &#123; string = [string substringToIndex:string.length - 1]; string = [string ridTail]; &#125; else if ([string hasSuffix:@\".\"]) &#123; string = [string substringToIndex:string.length - 1]; return string; &#125; else &#123; return string; &#125; return string;&#125;+ (NSString *)formatterNumber:(NSNumber *)number &#123; return [self formatterNumber:number fractionDigits:2];&#125;+ (NSString *)formatterNumber:(NSNumber *)number fractionDigits:(NSUInteger)fractionDigits &#123; NSNumberFormatter *numberFormatter = [[NSNumberFormatter alloc] init]; [numberFormatter setMaximumFractionDigits:fractionDigits]; [numberFormatter setMinimumFractionDigits:0]; [numberFormatter setMinimumIntegerDigits:1]; return [numberFormatter stringFromNumber:number];&#125;@end 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"金额计算","slug":"金额计算","permalink":"superdanny.link/tags/金额计算/"}]},{"title":"UITableView/UICollectionView使用技巧","date":"2017-03-10T08:42:00.000Z","path":"2017/03/10/iOS-UITableView-UICollectionView-Skill/","text":"前言知识是无穷无尽，技术需要积累，记录一点一滴，让成长的时间轴上变得充实一些。今天就讲讲UITableView/UICollectionView的一些使用技巧。结合自己项目情况进行展开。 Header/Footer高度、悬停设置高度设置有时候我们需要设置 TableView 的头部和尾部的间距，头部尾部的高度只需要在代理里面设置高度就行。 示例代码如下： 12345678910111213141516171819- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return 0.01f;&#125;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kScreenWidth, 20)]; view.backgroundColor = [UIColor clearColor]; return view;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123; return 10;&#125;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, kScreenWidth, 1)]; view.backgroundColor = [UIColor clearColor]; return view;&#125; 小结：通过上面的代码实现的效果可以看出，当自定义头部和尾部视图时，即使自定义头部和尾部视图设置了高度。高度最终还是由tableView:heightForHeaderInSection:和tableView:heightForFooterInSection:两个代理方法决定。当没有实现这两个代理方法时，高度为默认高度。 悬停TableView的悬停功能只有在 Style 是 UITableViewStylePlain 的时候才有。如果有这么一种需求，就是需要有Header悬停，同时每个section之间需要有间隔。效果如下： 方式一(全部悬停)：1234567891011121314151617181920212223242526272829303132333435363738394041- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return kHeaderHeight+9;&#125;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; BillListModel *model = _sectionArr[section]; UIView *header = (&#123; UIView *bgView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, KScreenWidth, kHeaderHeight+9)]; bgView.backgroundColor = [UIColorTools colorWithTheme:UIColorThemeAppBgColor]; UILabel *titleLab = [[UILabel alloc] initWithFrame:CGRectMake(0, 9, KScreenWidth, kHeaderHeight)]; titleLab.backgroundColor = [UIColorTools colorWithTheme:UIColorThemeWhite]; titleLab.textColor = [UIColorTools colorWithTheme:UIColorThemeBlack]; titleLab.text = model.time; [bgView addSubview:titleLab]; UIImageView *lineHBottom = [[UIImageView alloc] initWithFrame:CGRectMake(0.0, titleLab.mj_max_y - 0.5, KScreenWidth, 0.5)]; lineHBottom.backgroundColor = [UIColorTools colorWithTheme:UIColorThemeSeparatorColor]; [bgView addSubview:lineHBottom]; bgView; &#125;); return header;&#125;- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; if (scrollView == _tableView) &#123; UITableView *tableview = (UITableView *)scrollView; CGFloat sectionHeaderHeight = kHeaderHeight; CGFloat sectionFooterHeight = 9; CGFloat offsetY = tableview.contentOffset.y; if (offsetY &gt;= 0 &amp;&amp; offsetY &lt;= sectionFooterHeight) &#123; tableview.contentInset = UIEdgeInsetsMake(-offsetY, 0, -sectionHeaderHeight, 0); &#125; else if (offsetY &gt;= sectionFooterHeight &amp;&amp; offsetY &lt;= tableview.contentSize.height - tableview.frame.size.height - sectionHeaderHeight) &#123; tableview.contentInset = UIEdgeInsetsMake(-sectionFooterHeight, 0, 0, 0); &#125; else if (offsetY &gt;= 0 &amp;&amp; tableview.contentSize.height &gt;= tableview.contentSize.height) &#123; tableview.contentInset = UIEdgeInsetsMake(-sectionFooterHeight, 0, 0, 0); &#125; &#125;&#125; 方式二(部分悬停)：12345678910111213141516171819202122232425262728- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; if (section == 0) &#123; return 10.f; &#125; else if (section == 2) &#123; return 0; &#125; return kHeight4_7(35);&#125;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123; return 10.f;&#125;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; UIView *headerView = [UIView new]; headerView.backgroundColor = [UIColorTools colorWithTheme:UIColorThemeWhite]; if (section == 0) &#123; headerView.backgroundColor = [UIColor clearColor]; &#125; return headerView;&#125;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123; UIView *footerView = [[UIView alloc] init]; footerView.backgroundColor = [UIColor clearColor]; return footerView;&#125; CollectionView的悬停功能只有在 Style 是 UITableViewStylePlain 的时候才有。如果有这么一种需求，就是需要有Header悬停，同时每个section之间需要有间隔。效果如下： 滚动监听 UIScrollView 减速可能通过decelerationRate的属性来设置，它的值域是（0.0，1.0）,当decelerationRate设置为0.1时，当手指touch up时就会很慢的停下来。 UIScrollView 如何判断停止滑动这里停止滑动的意思要明确一下，有两种: 1、第一种是指手指停止ScrollView。 当手指停止滑动时，iOS会调UIScrollView的delegate 1- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate 如果decelerate还为NO时，它最终停下，否则它还没最终停下 2、第二种是指ScrollView停止滑动，指的滚动条完全停止下来。 当decelerate = true时，iOS才会调UIScrollView的delegate 1- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView 那UIScrollView真正停止滑动，应该怎么判断呢？解决方法如下： 123456789- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123; if(!decelerate) &#123; //OK,真正停止了，do something &#125;&#125;//然后- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; //OK,真正停止了,do something&#125; UIScrollView左右滑动到某个位置时，禁止继续向左或者向右滑动123456789101112131415161718- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat contentOffsetX = scrollView.contentOffset.x; if (contentOffsetX&lt;=0 || contentOffsetX&gt;=kScreenWidth) &#123; //当滑动到最左边或者最右边时，禁止继续滑动 scrollView.scrollEnabled = NO; &#125; else &#123; scrollView.scrollEnabled = YES; &#125;&#125;- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123; scrollView.scrollEnabled = YES;&#125;- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123; scrollView.scrollEnabled = YES;&#125; 消息传递当手指触摸后，scrollView会暂时拦截触摸事件，使用一个计时器，假如在计时器到点后，没有发生手指移动事件，那么，scrollView发送tracking events到被点击的subView。假如在计时器到点前，发生了移动事件，那么scrollView取消tracking自己发生滚动。 子类可以重载touchesShouldBegin:withEvent:inContentView:决定自己是否接收touch事件。当pagingEnabled值为YES，会自动滚动到subView的边界，默认是NO。 touchesShouldCancelInContentView:开始发送tracking messages消息给subView的时候调用这个方法，决定是否发送tracking messages消息到subview，假如返回NO，则发送，YES则不发送。 假如canCancelContentTouches属性是NO，则不调用这个方法来影响如何处理滚动手势。 修改tableView中headerView的位置(类似美团外卖首页)实现原理就是监听滚动情况，重设scrollView.contentInset即可效果如下： 123456789101112131415161718192021222324- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat contentOffsety = scrollView.contentOffset.y; _contentOffSet_y = contentOffsety; //这个header其实是section的header到顶部的距离 CGFloat header = kBannerHight+[HSFuntionCell cellHeight]+kFooterViewHeight-64; NSLog(@\"=======%lf=====%lf\", contentOffsety, header); if (contentOffsety&lt;=header&amp;&amp;contentOffsety&gt;=0) &#123; //当视图滑动的距离小于header时 scrollView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0); self.headerView.layer.borderColor = [UIColorTools colorWithTheme:UIColorThemeWhite].CGColor; &#125; else if (contentOffsety&gt;header) &#123; //当视图滑动的距离大于header时，这里就可以设置section的header的位置，设置的时候要考虑到导航栏的透明对滚动视图的影响 scrollView.contentInset = UIEdgeInsetsMake(64, 0, 0, 0); self.headerView.layer.borderColor = [UIColorTools colorWithTheme:UIColorThemeSeparatorColor].CGColor; &#125; self.headerView.borderWhich = DDViewBorderTop; //设置导航条透明度 [self setNavigationColor:contentOffsety];&#125; 顶部拉伸效果(头像拉伸)实现思路：自定义一个ViewA，作为TableView的headerView，然后监听TableView的滚动，将回调传递给ViewA即可。 效果如下： 下面是自定义MOActivityTopView.h文件 1234567@interface MOActivityTopView : UIView@property (nonatomic, strong) MOActivityModel *model;- (void)didScroll:(CGFloat)contentOffSetY;@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#import \"MOActivityTopView.h\"#define kViewHeight (kScreenWidth*340/750.)#define kTopHeight (kScreenWidth*240/750.)#define kBottomHeight (kScreenWidth*100/750.)@interface MOActivityTopView ()/// 背景图@property (nonatomic, strong) UIImageView *backgroundImgV;/// 毛玻璃@property (nonatomic, strong) UIVisualEffectView *visualEffectView;/// 活動圖@property (nonatomic, strong) UIImageView *activityImgV;/// 活動名稱@property (nonatomic, strong) UILabel *activityLab;@end@implementation MOActivityTopView- (instancetype)init &#123; if (self = [super initWithFrame:CGRectMake(0, 0, kScreenWidth, kViewHeight)]) &#123; [self setUp]; &#125; return self;&#125;#pragma mark - Getter-(UIImageView *)backgroundImgV &#123; if (_backgroundImgV == nil) &#123; _backgroundImgV = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.dd_w, kTopHeight)]; [_backgroundImgV setContentMode:UIViewContentModeScaleAspectFill]; [_backgroundImgV setClipsToBounds:YES]; &#125; return _backgroundImgV;&#125;- (void)setUp &#123; [self addSubview:self.backgroundImgV]; UIVisualEffect *blurEffect; blurEffect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; _visualEffectView = [[UIVisualEffectView alloc] initWithEffect:blurEffect]; // _visualEffectView.alpha = 0.8; _visualEffectView.frame = self.backgroundImgV.frame; [self addSubview:_visualEffectView]; UIView *bgView = [[UIView alloc] initWithFrame:CGRectMake(0, self.backgroundImgV.dd_max_y, kScreenWidth, kBottomHeight)]; bgView.backgroundColor = [UIColorTools colorWithTheme:UIColorThemeWhite]; [self addSubview:bgView]; CGFloat height = (kScreenWidth*160/750.); CGFloat width = height/(16/21.); _activityImgV = [[UIImageView alloc] initWithFrame:CGRectMake(15, bgView.dd_h-7-height, width, height)]; [bgView addSubview:_activityImgV]; _activityLab = [[UILabel alloc] initWithFrame:CGRectMake(_activityImgV.dd_max_x+8, 0, kScreenWidth-_activityImgV.dd_max_x-8-15, kBottomHeight)]; _activityLab.textColor = [UIColorTools colorWithTheme:UIColorThemeBlack]; _activityLab.numberOfLines = 2;// _activityLab.adjustsFontSizeToFitWidth = YES; [bgView addSubview:_activityLab];&#125;- (void)layoutSubviews &#123; [super layoutSubviews]; _activityImgV.clipsToBounds = YES; _activityImgV.layer.masksToBounds = YES; _activityImgV.layer.borderWidth = 1.5; _activityImgV.layer.borderColor = [UIColorTools colorWithTheme:UIColorThemeWhite].CGColor; _activityImgV.layer.cornerRadius = kViewCornerRadius;&#125;- (void)setModel:(MOActivityModel *)model &#123; _model = model; [_activityImgV sd_setImageWithURL:kMOImageUrlSet(model.ActivityURL) placeholderImage:[UIImage placeholderImage_activity]]; [_backgroundImgV sd_setImageWithURL:kMOImageUrlSet(model.ActivityURL) placeholderImage:kImageSet(@\"Icon-noti\")]; _activityLab.text = model.ActivityName;&#125;- (void)didScroll:(CGFloat)contentOffSetY &#123; //图片高度 CGFloat imageHeight = self.dd_h; //图片宽度 CGFloat imageWidth = kScreenWidth; //图片上下偏移量 CGFloat imageOffsetY = contentOffSetY; // NSLog(@\"图片上下偏移量 imageOffsetY:%f -&gt;\",imageOffsetY); //下拉 if (imageOffsetY &lt; 0) &#123; CGFloat totalOffset = imageHeight + ABS(imageOffsetY); CGFloat f = totalOffset / imageHeight; self.backgroundImgV.frame = CGRectMake(-(imageWidth * f - imageWidth) * 0.5, imageOffsetY, imageWidth * f, totalOffset); &#125; // //上拉// if (imageOffsetY &gt; 0) &#123;// CGFloat totalOffset = imageHeight - ABS(imageOffsetY);// CGFloat f = totalOffset / imageHeight;// [self.backgroundImgV setFrame:CGRectMake(-(imageWidth * f - imageWidth) * 0.5, imageOffsetY, imageWidth * f, totalOffset)];// &#125; _visualEffectView.frame = self.backgroundImgV.frame;&#125;@end 监听滚动123456789101112- (UIView *)topHeaderView &#123; if (!_topHeaderView) &#123; _topHeaderView = [[MOActivityTopView alloc] init]; _topHeaderView.model = _model; &#125; return _topHeaderView;&#125;- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; CGFloat contentOffSetY = scrollView.contentOffset.y; [self.topHeaderView didScroll:contentOffSetY];&#125; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"苹果应用内购指南资料","date":"2017-03-07T07:53:00.000Z","path":"2017/03/07/iOS-In-App-Purchase/","text":"最近想自己搞一个APP，就顺便查阅了相关苹果资料。这里记录一下，方便以后查阅。 iTunes Connect 的 In-App Purchase 配置指南 iOS 和 OS X 中的 In-App Purchase 使用入门 将 In-App Purchase 添加到您的 iOS 和 Mac 应用程序中 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"应用内购","slug":"应用内购","permalink":"superdanny.link/tags/应用内购/"}]},{"title":"为自己的 APP 瘦身","date":"2017-03-03T06:17:00.000Z","path":"2017/03/03/App-Thinning/","text":"问题每次产品迭代的次数越多，你就会发现安装包的大小也会随之增大，因为有很多废弃的代码，UI素材堆积在项目里面，导致了冗余。这边按照自己亲身经验对APP进行瘦身。 说干就干优化编译选项1、BuildSettings -&gt; Optimization Level，Xcode默认设置为“Fastest, Smallest”，保持默认即可。2、Build Settings -&gt; Linking -&gt; Dead Code Stripping 设置成 YES。3、Deployment Postprocessing 设置成 YES。4、Strip Linked Product 设置成 YES。5、工程的 Enable C++ Exceptions 和 Enable Objective-C Exceptions 选项都设置为 NO，手动管理异常（本人没有关闭）。6、symbols hidden by default 选项设置为 YES。 瘦身结果 总结 没什么变化 配置编译选项未必能够减少安装包大小，根据实际情况而定。 优化图片 Targets -&gt; Build Settings -&gt; Compress PNG Files 设置为 NO。 全部或绝大部分图要用压图软件手动压缩（推荐使用TinyPNG软件）。 不同尺寸兼容建议(如下) 当遇到使用全屏帮助页时，一开始我是这样做的： 这样做导致了如果我帮助页多的话，就会导致安装包变大。其实这种情况一般能将这些帮助页放在网页是最合适不过的，因为使用频率不高。没必要放在项目中。但是如果非要放在项目中的话，我们就需要尽可能的想办法较少占用。 我们知道，iPhone的屏幕尺寸有着几种： 设备型号 尺寸 逻辑分辨率(point) 设备分辨率(pixel) 高宽比 iPhone 4,4s 3.5寸 320x480 640x960 640/960 = 1.5 iPhone SE,5,5s,5c 4寸 320x568 640x1136 1136/640 = 1.775 iPhone 8,7,6s,6 4.7寸 375x667 750x1334 1334/750 = 1.775 iPhone 8P,7P,6sP,6P 5.5寸 414x736 1242x2208 2208/1242 = 1.778 iPhone X 5.8寸 375x812 1125x2436 2436/1125 = 2.165 那么是不是美工妹妹要切4套图呢，如果这样，编译的APP就非常大了！有经验的美工只会给你两套图！为什么呢？请看各型号手机的高宽比，发现了吧：只有4/4s的高宽比是1.5其他都近视1.775！也就是说，我们通过判断手机的屏幕高度来区分加载那套图，然后做适当的等比例放大就行了！为了保险起见，个人建议保留3.5寸和4.7寸两套图(如下图)，然后根据如果是非3.5寸的屏幕时，固定宽度，高度=宽度*1.778。另外需要特别说明，4.7寸的图最好底部多留几个像素，方便拉伸。 2018-06-12补充由于出了iPhone X的缘故，高宽比跟原本保留的两套不一样，所以需要再加一套图进行适配。 代码实现： 123456789101112131415161718192021222324252627#pragma mark - 获取对应屏幕尺寸图片+ (UIImage *)getCurrentDrviceSizeLaunchImage &#123; //得到当前屏幕的尺寸 CGRect rect_screen = [[UIScreen mainScreen] bounds]; CGSize size_screen = rect_screen.size; //获得scale CGFloat scale_screen = [UIScreen mainScreen].scale; //获取设备分辨率 CGFloat width = size_screen.width*scale_screen; CGFloat height = size_screen.height*scale_screen; NSString *sizeStr = @\"DefaultLaunch_3.5\"; if (width == 640 &amp;&amp; height == 1136) &#123; sizeStr = @\"DefaultLaunch_4\"; &#125; else if (width == 750 &amp;&amp; height == 1334) &#123; sizeStr = @\"DefaultLaunch_4\"; &#125; else if (width == 1242 &amp;&amp; height == 2208) &#123; sizeStr = @\"DefaultLaunch_4\"; &#125; else if (width == 640 &amp;&amp; height == 960) &#123; sizeStr = @\"DefaultLaunch_3.5\"; &#125; else if (width == 1125 &amp;&amp; height == 2436) &#123; sizeStr = @\"DefaultLaunch_5.8\"; &#125; return [UIImage imageNamed:sizeStr];&#125; 瘦身结果 总结 瘦身显著，UI素材从17.9M压缩到8.1M UI素材一定要进行一遍压缩，因为UI人员未必会帮你压缩之后发给你，所以有时候一张素材少则几KB，多则几百KB不止。 尾巴通过上面的各种折腾，安装包从原来的47.6M缩小为27.2M。当然，上传到AppStore之后会再大一些，不过总体来说已经缩小了很多了。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"iOS数据库操作之Realm初探","date":"2017-02-22T07:44:00.000Z","path":"2017/02/22/iOS-Realm/","text":"前提以前了解过 Realm 这个第三方数据库操作，但是没有深入的了解。这两天有空花了点时间看了一下文档，这边根据文档摘抄记录一下，方便以后使用到可以查阅。 数据模型Realm数据模型是基于标准 Objective‑C 类来进行定义的，使用属性来完成模型的具体定义。 通过简单的继承 RLMObject 或者一个已经存在的模型类，您就可以创建一个新的 Realm 数据模型对象。 Realm模型对象在形式上基本上与其他 Objective‑C 对象相同 - 您可以给它们添加您自己的方法(method)和协议(protocol)，和在其他对象中使用类似。 主要的限制是某个对象只能在其被创建的那个线程中使用, 并且您无法访问任何存储属性的实例变量(ivar)。 12345678910111213141516171819202122232425#import &lt;Realm/Realm.h&gt;@class Person;// 狗狗的数据模型@interface Dog : RLMObject@property NSString *name;@property Person *owner;@endRLM_ARRAY_TYPE(Dog) // 定义RLMArray&lt;Dog&gt;// 狗狗主人的数据模型@interface Person : RLMObject@property NSString *name;@property NSDate *birthdate;@property RLMArray&lt;Dog&gt; *dogs;@endRLM_ARRAY_TYPE(Person) // 定义RLMArray&lt;Person&gt;// 实现文件@implementation Dog@end // 暂时没用@implementation Person@end // 暂时没用 由于 Realm 中定义的所有模型在程序启动时就会被解析，所以即使代码中没有调用，它们都需要被初始化。 在 Swift 中使用 Realm 的时候，Swift.reflect(_:) 函数可用于确定您模型中的信息，这需要确保 init() 已被成功调用。这意味着所有非可选的属性必须添加一个默认值。 通过 RLMObject 可查看更多细节。 支持的类型Realm支持以下的属性类型：BOOL、bool、int、NSInteger、long、long long、float、double、NSString、NSDate、NSData 以及被特殊类型标记)的 NSNumber 。 CGFloat 属性的支持被取消了，因为它不具备平台独立性。 您可以使用RLMArray 和 RLMObject的子类来建立诸如一对多、一对一之类的关系模型。 在 Xcode 7 以及之后的版本中，RLMArray支持编译时的 Objective‑C 泛型(generics)。下面是不同属性定义方法的意义以及用途： RLMArray: 属性类型。 &lt;Object *&gt;: 属性的特别化(generic specialization)，这可以阻止在编译时使用错误对象类型的数组。 &lt;Object&gt;: 此 RLMArray 遵守的协议，可以让 Realm 知晓如何在运行时确定数据模型的架构。 属性特性(attributes)注意由于 Realm 在自己的引擎内部有很好的语义解释系统，所以 Objective‑C 的许多属性特性将被忽略，如nonatomic, atomic, strong, copy 和 weak 等。 因此为了避免误解，我们推荐您在编写数据模型的时候不要使用任何的属性特性。 当然，如果您已经设置了这些属性特性，那么在 RLMObject 对象被写入 Realm 数据库前，这些特性会一直生效。 无论 RLMObject 对象是否受到 Realm 管理，您为其编写的自定义 getter 和 setter 方法都能正常工作。 如果您在 Swift 中使用 Objective-C 版本的 Realm 的话，模型的属性前面需要加上 dynamic var，这是为了让这些属性能够被底层数据库数据所访问。 可空属性(Optional Properties)通常情况下，NSString *、NSData * 以及 NSDate * 属性可以设置为 nil。如果你不需要实现此功能，你可以重写您的 RLMObject 子类的 +requiredProperties 方法。 比如对于以下的模型定义来说，如果尝试给 name 属性设置为 nil 将会抛出一个异常，但是将 birthday 属性设置为 nil 却是允许的： 12345678910@interface Person : RLMObject@property NSString *name;@property NSDate *birthday;@end@implementation Person+ (NSArray *)requiredProperties &#123; return @[@\"name\"];&#125;@end 存储可空数字目前已经可以通过 NSNumber * 属性完成。 由于 Realm 对不同类型的数字采取了不同的存储格式，因此设置可空的数字属性必须是 RLMInt、RLMFloat、RLMDouble 或者 RLMBool 类型。所有赋给属性的值都会被转换为其特定的类型。 比如说，如果我们存储一个用户的年龄(age)而不是存储他们的生日，同时还要允许当您不知道该用户的年龄的时候将 age 属性设置为 nil： 12345678910@interface Person : RLMObject@property NSString *name;@property NSNumber&lt;RLMInt&gt; *age;@end@implementation Person+ (NSArray *)requiredProperties &#123; return @[@\"name\"];&#125;@end RLMProperty 的子类属性始终都可以为 nil，因此这些类型不能够放在 requiredProperties中，并且 RLMArray 不支持存储 nil 值。 索引属性(Indexed Properties)重写 +indexedProperties 方法可以为数据模型中需要添加索引的属性建立索引： 12345678910@interface Book : RLMObject@property float price;@property NSString *title;@end@implementation Book+ (NSArray *)indexedProperties &#123; return @[@\"title\"];&#125;@end Realm 支持字符串、整数、布尔值以及 NSDate 属性作为索引。 对属性进行索引可以减少插入操作的性能耗费，加快比较检索的速度（比如说 = 以及 IN 操作符）。 属性默认值重写+defaultPropertyValues 可以每次在对象创建之后为其提供默认值。 12345678910@interface Book : RLMObject@property float price;@property NSString *title;@end@implementation Book+ (NSDictionary *)defaultPropertyValues &#123; return @&#123;@\"price\" : @0, @\"title\": @\"\"&#125;;&#125;@end 主键(Primary Keys)重写 +primaryKey 可以设置模型的主键。声明主键之后，对象将允许进行查询，并且更新速度更加高效，而这也会要求每个对象保持唯一性。 一旦带有主键的对象被添加到 Realm 之后，该对象的主键将不可修改。 12345678910@interface Person : RLMObject@property NSInteger id;@property NSString *name;@end@implementation Person+ (NSString *)primaryKey &#123; return @\"id\";&#125;@end 对象存储 对对象的所有更改（添加，修改和删除）都必须通过写入事务(transaction)完成。 Realm 的对象可以被实例化并且作为unmanaged对象使用（也就是还未添加到 Realm 数据库中的对象），和其他常规Objective‑C对象无异。 如果您想要在多个线程中共享对象，或者在应用重启后重复使用对象，那么您必须将其添加到 Realm 数据库中——这个操作必须在写入事务中完成。 因为写入事务将会产生不可忽略的性能消耗，因此你应当检视你的代码以确保减少写入事务的次数。 由于写入事务像其余硬盘读写操作一样，会出现失败的情况，因此 -[RLMRealm transactionWithBlock:] 以及 -[RLMRealm commitWriteTransaction] 可以选择加上 NSError 指针参数 因此你可以处理和恢复诸如硬盘空间溢出之类的错误。此外，其他的错误都无法进行恢复。简单起见，我们的代码示例并不会处理这些错误，但是您应当在您应用当中注意到这些问题。 创建对象当定义完数据模型之后，您可以将您的 RLMObject 子类实例化，然后向 Realm 中添加新的实例。我们以下面这个简单的模型为例： 123456789// 狗狗的数据模型@interface Dog : RLMObject@property NSString *name;@property NSInteger age;@end// 实现文件@implementation Dog@end 我们可以用多种方法创建一个新的对象： 12345678910// (1) 创建一个狗狗对象，然后设置其属性Dog *myDog = [[Dog alloc] init];myDog.name = @\"大黄\";myDog.age = 10;// (2) 通过字典创建狗狗对象Dog *myOtherDog = [[Dog alloc] initWithValue:@&#123;@\"name\" : @\"豆豆\", @\"age\" : @3&#125;];// (3) 通过数组创建狗狗对象Dog *myThirdDog = [[Dog alloc] initWithValue:@[@\"豆豆\", @3]]; 使用指定初始化器(designated initializer)创建对象是最简单的方式。请注意，所有的必需属性都必须在对象添加到 Realm 前被赋值。通过使用恰当的键值，对象还可以通过字典完成创建。最后，RLMObject 子类还可以通过数组完成实例化，数组中的值必须和数据模型中对应属性的次序相同。 嵌套属性(Nested Object)如果某个对象中有 RLMObject 或者 RLMArray 类型的属性，那么通过使用嵌套的数组或者字典便可以对这些属性递归地进行设置。您只需要简单的用表示其属性的字典或者数组替换每个对象即可： 123456// 这里我们就可以使用已存在的狗狗对象来完成初始化Person *person1 = [[Person alloc] initWithValue:@[@\"李四\", @30, @[aDog, anotherDog]]];// 还可以使用多重嵌套Person *person2 = [[Person alloc] initWithValue:@[@\"李四\", @30, @[@[@\"小黑\", @5], @[@\"旺财\", @6]]]]; 即使是数组以及字典的多重嵌套，Realm 也能够轻松完成对象的创建。注意 RLMArray 只能够包含 RLMObject 类型，不能包含诸如NSString之类的基础类型。 添加数据向 Realm 中添加数据的步骤如下： 12345678910111213141516171819// 创建对象Person *author = [[Person alloc] init];author.name = @\"大卫·福斯特·华莱士\";// 获取默认的 Realm 实例RLMRealm *realm = [RLMRealm defaultRealm];// 每个线程只需要使用一次即可// 通过事务将数据添加到 Realm 中// 方式一：[realm beginWriteTransaction];[realm addObject:author];[realm commitWriteTransaction];// 方式二：[realm transactionWithBlock:^&#123; [realm addObject:author];&#125;]; 等您将某个对象添加到 Realm 数据库之后，您可以继续使用它，并且您对其做的任何更改都会被保存（必须在一个写入事务当中完成）。当写入事务提交之后，使用相同 Realm 数据源的其他线程才能够对这个对象进行更改。 请注意，如果在进程中存在多个写入操作的话，那么单个写入操作将会阻塞其余的写入操作，并且还会锁定该操作所在的当前线程。 这个特性与其他持久化解决方案类似，我们建议您使用该方案常规的最佳做法：将写入操作转移到一个独立的线程中执行。 由于 Realm 采用了 MVCC 设计架构，读取操作 并不会 因为写入事务正在进行而受到影响。除非您需要立即使用多个线程来同时执行写入操作，不然您应当采用批量化的写入事务，而不是采用多次少量的写入事务。 查看RLMRealm和RLMObject来获得更多内容。 未完待续。。。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Realm","slug":"Realm","permalink":"superdanny.link/tags/Realm/"}]},{"title":"重装 Mac 系统","date":"2017-02-05T08:36:00.000Z","path":"2017/02/05/Reinstall-the-MacOS/","text":"今天公司从保险柜里面拿出两台笔记本让我修理下，顿时心里一万只小绵羊奔腾而过，我是搞开发的，不是修电脑的。。。但是没办法，谁叫我比较好说话，妥协了。。。 准备工作1、安装Mac OS X系统的苹果电脑2、重置出厂系统将会清空硬盘数据，需转移硬盘所有文件 方式一：在线安装这种方式比较直接，通过联网下载系统包在线安装，不过下载安装时间取决于网速和硬件。 重启Mac电脑时按住Command+R或Command+Option+R进入OS X实用工具，如果不行，则关闭电脑，同时按住Command+Option+R，然后开机，直到看到屏幕上出现一个地球才松开键盘上的键，需要注意的是，一些旧的机型不支持在线恢复； 点击第4个选项“磁盘工具”，继续； 选择硬盘，点击“抹掉”标签，格式选择“Mac OS扩展(日志式)”，输入硬盘名称“Macintosh HD”，点击“抹掉”； 点击“磁盘工具”—“退出磁盘工具”，点击“重新安装OS X”； 点击“继续”开始下载和安装，时间会比较长，需耐心等待； 选择硬盘，点击“安装”即可。 以上就是通过恢复出厂设置的方式重装Mac OS X系统的方法，安装过程中全自动，无需点击任何按键，可以触碰触摸板查看进度。 方式二：U盘安装我比较喜欢这一种，因为系统版本可以自己制定，另外不依赖网络即可完成安装。 预先准备一支不小于8G的U盘，用磁盘工具按图示顺序操作，U盘名称为USB01，直到提示抹盘成功： 用Apple官方推荐的 createinstallmedia 命令制作条件：在 App Store 下载了Install OS X El Capitan.app，或者从其它途径（例如共享的网盘）得到了（一般是dmg镜像中的）app安装包，请按以下步骤操作： 1、打开终端，然后以下两种方法任选一种 方法一：（适合小白） 前提：下载得到的原版安装包（中文系统中显示为安装 OS X El Capitan，文件名为Install OS X El Capitan.app）已经默认在应用程序文件夹内，且U盘命名为USB01。 直接将以下命令全部复制、粘贴到终端： 1sudo /Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/USB01 --applicationpath /Applications/Install\\ OS\\ X\\ El\\ Capitan.app --nointeraction 命令解释： 1234567sudo #获取超级用户权限执行以下命令/Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia #指定运行路径为为/Applications/Install OS X El Capitan.app/Contents/Resources/中的createinstallmedia这个“创建安装媒体”的程序，路径的文件名中的空格前添加的反斜杠“\\”是转义字符，以便将“文件名中的空格”和“命令行中的参数之间的空格”区别开来。--volume #该选项要求指定在哪个volume中创建安装媒体（安装U盘）/Volumes/USB01 #你要创建的安装盘（U盘）的路径--applicationpath #该选项是要求指定写入到U盘的OS X系统安装包的路径/Applications/Install\\ OS\\ X\\ El\\ Capitan.app #所指定的要写入U盘的系统安装包在电脑中的路径--nointeraction #该选项表示运行程序 createinstallmedia 的过程中不交互。如果不用这个选项，可能会弹出一个提示，跟你说接下来要干什么，问你是否确定，确定就按y，然后回车继续。 方法二：输入命令+手动拖入终端操作（明显比较繁琐，适合熟悉终端的高手）。 此法对安装包Install OS X El Capitan.app的路径和文件名、版本（只要是版本&gt;=10.9的OS X app安装包）没有限制，甚至安装包也可以在移动硬盘中；U盘也不一定要命名为USB01。 过程： （1）输入 1sudo空格 （2）打开Finder，找到Install OS X El Capitan.app，定位到 Install OS X El Capitan.app(右键显示包内容)/Contents/Resources/createinstallmedia，将createinstallmedia拖入终端；（3）接着输入 1--volume空格 （4）接着将U盘拖入终端；（5）接着输入 1--applicationpath空格 （6）接着，将Install OS X El Capitan.app拖入终端；（7）接着输入 1--nointeraction 此时，终端中的命令类似于方法一，只是相关路径可能有所不同。 2、回车。3、输入当前系统密码（看起来没有反应，实际是密码不可见），回车。4、等待十几~几十分钟（视硬件而定），直到出现 1234Making disk bootable...Copying boot files...Copy complete.Done. 如图所示： 安装U盘制作完成。 安装1、重启需要重装系统的Mac电脑时按住Option进入启动盘选择界面2、选择刚刚制作的U盘3、这里需要注意，本人在重装的过程中出现了 OS X could not be installed on your computer. No packages were eligible for install. 错误提示。经过查询，需要重置系统时间。具体步骤是：点击顶部菜单栏 Utilities-Terminal 进入终端界面，然后输入指令 date {month}{day}{hour}{minute}{year} 例如2017年02月05日17:40的指令是date 02051740174、接下来就是根据提示安装，然后等待十几分钟安装完成。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Mac","slug":"Mac","permalink":"superdanny.link/tags/Mac/"},{"name":"MacOS","slug":"MacOS","permalink":"superdanny.link/tags/MacOS/"}]},{"title":"如何正确设置导航栏透明度","date":"2017-01-04T15:12:00.000Z","path":"2017/01/04/iOS-NavigationBar-Alpha/","text":"需求很多时候，希望导航栏能够透明，同时item不透明，看了网上的做法，参测不齐。这里作为过来人自己走过的坑有必要说说。 需求一：希望导航栏一直透明，且item也透明1[self.navigationController setNavigationBarHidden:YES animated:NO]; 需求二：希望导航栏一直透明，item不透明1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; self.edgesForExtendedLayout = UIRectEdgeAll; self.automaticallyAdjustsScrollViewInsets = NO;&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.shadowImage = [UIImage new]; self.navigationController.navigationBar.translucent = YES;&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.navigationController.navigationBar setBackgroundImage:[UIImage imageWithColor:RGBACOLOR(56.0, 25.0, 114.0, 1.0)] forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.shadowImage = [UIImage imageWithColor:RGBACOLOR(56.0, 25.0, 114.0, 1.0)]; self.navigationController.navigationBar.translucent = NO;&#125; 需求三：希望导航栏随着UIScrollView/UITableView滑动变化颜色，且item不透明 这里需要借助第三方LTNavigationBar 12345678910111213141516171819202122232425262728293031323334#import \"UINavigationBar+Awesome.h\"- (void)viewDidLoad &#123; [super viewDidLoad]; self.edgesForExtendedLayout = UIRectEdgeAll; self.automaticallyAdjustsScrollViewInsets = NO;&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.shadowImage = [UIImage new]; self.navigationController.navigationBar.translucent = YES;&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.navigationController.navigationBar lt_reset];&#125;- (void)setNavigationColor:(CGFloat)contentOffSet_y &#123; if (contentOffSet_y &gt;= -10.0) &#123; if (contentOffSet_y &lt;= 0) &#123; [self.navigationController.navigationBar lt_setBackgroundColor:RGBACOLOR(56.0, 25.0, 114.0, 0.0)]; &#125; if (contentOffSet_y &gt;= 0) &#123; if (contentOffSet_y &lt;= 130.0) &#123; [self.navigationController.navigationBar lt_setBackgroundColor:RGBACOLOR(56.0, 25.0, 114.0, 1.0 / 130.0 * contentOffSet_y)]; &#125; else &#123; [self.navigationController.navigationBar lt_setBackgroundColor:RGBACOLOR(56.0, 25.0, 114.0, 1.0)]; &#125; &#125; &#125; [self.navigationController.navigationBar setShadowImage:[UIImage new]];&#125;- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; [self setNavigationColor:scrollView.contentOffset.y];&#125; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"关于Autolayout制作动画的坑","date":"2016-12-22T15:13:00.000Z","path":"2016/12/22/iOS-Autolayout-and-animation/","text":"需求一直以来iOS的 Autolayout 都是一个很不错的功能，结合第三方 Masonry 可以节省很多工作成本。但是如果使用 Autolayout 来制作动画，那么就需要注意一下。不然就会像我一样，遇坑踩坑，越陷越深。 使用xib实现动画使用情景：自定义一个UIView ViewA，实现由下往上弹窗效果。 效果如下 假如我们是使用xib创建自定义弹窗视图，一般我们都会在xib上做好了约束的条件，之后在.m文件里面实现视图的初始化操作。 实现动画的原则是，在ViewA执行动画之前，需要将ViewA最终约束条件设置好，之后在执行动画代码块里面只需要调用layoutIfNeeded即可。 另外调用layoutIfNeeded方法的对象必须是ViewA的父视图，不然会出现ViewA的子视图跟着执行动画的情况。 如下面的代码中，ViewA的父视图就是window，所以调用layoutIfNeeded方法的对象是window 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (instancetype)init &#123; self = [[[NSBundle mainBundle] loadNibNamed:@\"DDJoinView\" owner:self options:nil] lastObject]; if (self) &#123; self.frame = CGRectMake(0, kScreenHeight, kScreenWidth, 195); &#125; return self;&#125;- (void)show &#123; UIWindow *window = [UIApplication sharedApplication].keyWindow; _bgView = [[UIButton alloc] init]; _bgView.backgroundColor = UIColorHex(0x000000); _bgView.alpha = 0.25; _bgView.frame = CGRectMake(0, 0, kScreenWidth, kScreenHeight); [_bgView addTarget:self action:@selector(close:) forControlEvents:UIControlEventTouchUpInside]; [window addSubview:_bgView]; [window addSubview:self]; [self mas_updateConstraints:^(MASConstraintMaker *make) &#123; (void)make.left; (void)make.centerX; make.height.offset(195); make.bottom.offset(0); &#125;]; [UIView animateWithDuration:0.3f animations:^&#123; [window layoutIfNeeded]; &#125;];&#125;#pragma mark - 關閉- (void)close:(id)sender &#123; UIWindow *window = [UIApplication sharedApplication].keyWindow; [self mas_updateConstraints:^(MASConstraintMaker *make) &#123; (void)make.left; (void)make.centerX; make.height.offset(195); make.bottom.offset(195); &#125;]; [UIView animateWithDuration:0.3f animations:^&#123; [window layoutIfNeeded]; &#125; completion:^(BOOL finished) &#123; for (UIView *v in [self subviews]) &#123; [v removeFromSuperview]; &#125; [self removeFromSuperview]; [_bgView removeFromSuperview]; &#125;];&#125; 总结12345678//...//执行下面动画前，设置自定义view的最终位置的约束条件//...[UIView animateWithDuration:0.3f animations:^&#123; [xxx layoutIfNeeded]; &#125; completion:^(BOOL finished) &#123; //do something&#125;]; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Autolayout","slug":"Autolayout","permalink":"superdanny.link/tags/Autolayout/"},{"name":"动画","slug":"动画","permalink":"superdanny.link/tags/动画/"}]},{"title":"NSDecimalNumber实现金融类等高精度计算(转改)","date":"2016-12-14T09:43:00.000Z","path":"2016/12/14/iOS-High-precision-calculation/","text":"需求平时我们进行数值计算时，使用常用的数据类型进行加减乘除是不会有什么问题的，但是一旦涉及精度高的，特别是计算金额时，就特别容易踩坑，本人就经历过两次，回想起来血淋淋的场面依然历历在目。 苹果其实很早就推出过计算高精度类型的API。只不过我没发现。感觉自己还是too young too simple。话不多说，直奔主题。 本文转载至天狐博客 NSDecimalNumberNSDecimalNumber,不可变NSNumber 的子类,提供了一个面向对象的十进制运算包装器 。实例可以代表任意数值,表示为(mantissa)尾数x 10 ^(exponent)指数,(mantissa)尾数是一个十进制整数到38位长,(exponent)指数是一个整数从-128年到127。 参数名 意义 Mantissa 十进制整数 Exponent 小数位数 Flag(Sign) 是否为负数 创建Decimal Number+ (NSDecimalNumber *)decimalNumberWithMantissa:(unsigned long long)mantissa exponent:(short)exponent isNegative:(BOOL)flag 参数表示 一个number的科学记数法 ,要求(mantissa)尾数是一个整数。例如,如果表示的数是-12.345,它是表示为12345 x10 ^ 3 -mantissa 是12345;(exponent)指数是3;和isNegative(一个布尔值,用于指定number 的(sign)符号是负的)是YES,如下例所示。 123NSDecimalNumber *number = [NSDecimalNumber decimalNumberWithMantissa:12345 exponent:-3 isNegative:YES]; + (NSDecimalNumber *)decimalNumberWithDecimal:(NSDecimal)decimal 给定一个NSDecimal数据结构,创建并返回一个等价的 NSDecimalNumber对象 + (NSDecimalNumber )decimalNumberWithString:(NSString )numericString 创建并返回一个NSDecimalNumber对象值相当于个给定的数字字符串。 numericString:除了数字字符串,numericString可以包括一个“+”或“-”,一个“E”或“E”,用科学记数法表示一个数的指数,和一个NSLocaleDecimalSeparator划分的部分数的有效组成部分。 + (NSDecimalNumber )decimalNumberWithString:(NSString )numericString locale:(id)locale locale:一个字典定义语言环境(特别是NSLocaleDecimalSeparator),在进行解析numericString的时候 numericString:除了数字字符串,numericString可以包括一个“+”或“-”,一个“E”或“E”,用科学记数法表示一个数的指数,和一个NSLocaleDecimalSeparator划分的部分数的有效组成部分。 1234//以\",\"当做分隔符格式NSDictionary *locale = @&#123;NSLocaleDecimalSeparator :@\",\"];//123.4NSDecimalNumber *discountAmount = [NSDecimalNumber decimalNumberWithString:@\"123,40\" locale:locale]; 以下是numericString的一些正确示例: “2500.6” (or “2500,6”, 取决于 locale) “–2500.6” (or “–2500,6”) “–2.5006e3” (or “–2,5006e3”) “–2.5006E3” (or “–2,5006E3”) 以下是numericString的一些错误示例: “2,500.6” “2500 3/5” “2.5006x10e3” “two thousand five hundred and six tenths” + (NSDecimalNumber *)one 一个 等同于 1.0的NSDecimalNumber对象 + (NSDecimalNumber *)zero 一个 等同于 0.0的NSDecimalNumber对象 + (NSDecimalNumber *)notANumber 没有指定数值的NSDecimalNumber对象 常用于对比，比如：[[NSDecimalNumber notANumber] isEqualToNumber:myNumber]; 初始化Decimal Number- (instancetype)initWithDecimal:(NSDecimal)decimal 一个NSDecimalNumber使用给定decimal对象初始化 - (instancetype)initWithMantissa:(unsigned long long)mantissa exponent:(short)exponent isNegative:(BOOL)flag 使用(mantissa)尾数, (exponent)指数 number 的(sign)符号,来初始化NSDecimalNumber - (instancetype)initWithString:(NSString *)numericString 创建并返回一个NSDecimalNumber对象值相当于个给定的numericString数字字符串。 numericString:除了数字字符串,numericString可以包括一个“+”或“-”,一个“E”或“E”,用科学记数法表示一个数的指数,和一个NSLocaleDecimalSeparator划分的部分数的有效组成部分。 - (instancetype)initWithString:(NSString *)numericString locale:(id)locale 以numericString,locale初始化NSDecimalNumber对象 locale:一个字典定义语言环境(特别是NSLocaleDecimalSeparator),在进行解析numericString的时候 numericString:除了数字字符串,numericString可以包括一个“+”或“-”,一个“E”或“E”,用科学记数法表示一个数的指数,和一个NSLocaleDecimalSeparator划分的部分数的有效组成部分。 加法运算- (NSDecimalNumber )decimalNumberByAdding:(NSDecimalNumber )decimalNumber 返回一个新的NSDecimalNumber对象, 值 是接收方与另一个给定NSDecimalNumber对象的总和。 - (NSDecimalNumber )decimalNumberByAdding:(NSDecimalNumber )decimalNumber withBehavior:(nullable id )behavior 加上decimalNumber给接受者并返回一个新创建的NSDecimalNumber对象。 behavior:指定的如何处理计算错误和舍入行为。 减法运算- (NSDecimalNumber )decimalNumberBySubtracting:(NSDecimalNumber )decimalNumber 返回一个新的NSDecimalNumber对象,其值是调用者减去另一个给定NSDecimalNumber对象的值。 - (NSDecimalNumber )decimalNumberBySubtracting:(NSDecimalNumber )decimalNumber withBehavior:(id)behavior 返回一个新的NSDecimalNumber对象,其值是调用者减去另一个给定NSDecimalNumber对象的值。 behavior:指定的如何处理计算错误和舍入行为。 乘法运算- (NSDecimalNumber )decimalNumberByMultiplyingBy:(NSDecimalNumber )decimalNumber 返回一个新的NSDecimalNumber对象,其值是调用者乘以另一个给定NSDecimalNumber对象的值。 - (NSDecimalNumber )decimalNumberByMultiplyingBy:(NSDecimalNumber )decimalNumber withBehavior:(nullable id )behavior 返回一个新的NSDecimalNumber对象,其值是调用者乘以另一个给定NSDecimalNumber对象的值。 behavior:指定的如何处理计算错误和舍入行为。 除法运算- (NSDecimalNumber )decimalNumberByDividingBy:(NSDecimalNumber )decimalNumber 返回一个新的NSDecimalNumber对象,其值是调用者除以另一个给定NSDecimalNumber对象的值。 - (NSDecimalNumber )decimalNumberByDividingBy:(NSDecimalNumber )decimalNumber withBehavior:(nullable id )behavior 返回一个新的NSDecimalNumber对象,其值是调用者除以另一个给定NSDecimalNumber对象的值。 behavior:指定的如何处理计算错误和舍入行为。 a的N次方- (NSDecimalNumber *)decimalNumberByRaisingToPower:(NSUInteger)power 返回一个新的NSDecimalNumber对象,其值是调用者 的power次方。 - (NSDecimalNumber *)decimalNumberByRaisingToPower:(NSUInteger)power withBehavior:(nullable id )behavior 返回一个新的NSDecimalNumber对象,其值是调用者 的power次方。 behavior:指定的如何处理计算错误和舍入行为。 指数运算- (NSDecimalNumber *)decimalNumberByMultiplyingByPowerOf10:(short)power 返回一个新的NSDecimalNumber对象,其值是调用者乘以10的power次方。 - (NSDecimalNumber *)decimalNumberByMultiplyingByPowerOf10:(short)power withBehavior:(nullable id )behavior 返回一个新的NSDecimalNumber对象,其值是调用者乘以10的power次方。 behavior:指定的如何处理计算错误和舍入行为。 四舍五入- (NSDecimalNumber *)decimalNumberByRoundingAccordingToBehavior:(nullable id )behavior 返回一个新的NSDecimalNumber对象,其值是调用者四舍五入过后的值。 behavior:指定的如何处理计算错误和舍入行为。 12345678NSDecimalNumberHandler * handler =[[NSDecimalNumberHandler alloc] initWithRoundingMode:NSRoundPlain scale:scale raiseOnExactness:NO raiseOnOverflow:YES raiseOnUnderflow:YES raiseOnDivideByZero:YES];NSDecimalNumber *result = [number decimalNumberByRoundingAccordingToBehavior:handler]; 描述不同的舍入方式,查看NSDecimalNumberBehaviors协议规范的roundingMode方法。 roundingMode四舍五入策略 1234567// Original// value 1.2 1.21 1.25 1.35 1.27// NSRoundPlain 1.2 1.2 1.3 1.4 1.3// NSRoundDown 1.2 1.2 1.2 1.3 1.2// NSRoundUp 1.2 1.3 1.3 1.4 1.3// NSRoundBankers 1.2 1.2 1.2 1.4 1.3 访问值@property(readonly) NSDecimal decimalValue 十进制数最近似的double值。(只读) - (NSString *)descriptionWithLocale:(id)locale 根据给定的locale返回number的字符串 @property(readonly) const char *objCType Objective- C的C字符串类型的数据,包含小数对象。(只读) 管理 Behavior+ (id)defaultBehavior 返回的算术的方法、像decimalNumberByAdding:四舍五入和处理错误的条件。默认情况下,算术方法使用NSRoundPlain行为;也就是说,四舍五入最可能的返回值的方法。方法假定你需要精度不超过38个有效数字,当他们试图除以0或产生一个数表示太大或太小的时候发生异常。 如果这种默认行为不适合您的应用程序,您应该使用这个方法,让您可以指定行为,像decimalNumberByAdding:withBehavior:。如果你发现自己一直使用一个特定的行为,您可以指定一个不同的默认行为setDefaultBehavior:。 在你的应用程序中默认行为是单独为每个线程维护。 比较 Decimal Numbers- (NSComparisonResult)compare:(NSNumber *)decimalNumber 返回一个NSComparisonResult值表明调用者和另一个给定的数字NSDecimalNumber对象的顺序大小。 NSOrderedAscending 如果decimalNumber的价值大于调用者; NSOrderedSame 如果它们相等; NSOrderedDescending 如果decimalNumber小于调用者的值。 12345678910NSDecimalNumber *discount1 = [NSDecimalNumber decimalNumberWithString:@\"1.2\"];NSDecimalNumber *discount2 = [NSDecimalNumber decimalNumberWithString:@\"1.3\"];NSComparisonResult result = [discount1 compare:discount2];if (result == NSOrderedAscending) &#123; NSLog(@\"1.2 &lt; 1.3\");&#125; else if (result == NSOrderedSame) &#123; NSLog(@\"1.2 == 1.3\");&#125; else if (result == NSOrderedDescending) &#123; NSLog(@\"1.2 &gt; 1.3\");&#125; 获取 最大最小可能值+ (NSDecimalNumber *)maximumDecimalNumber 返回一个NSDecimalNumber对象的最大可能值。 + (NSDecimalNumber *)minimumDecimalNumber 返回一个NSDecimalNumber对象的最小可能值。 常量 ConstantsNSDecimalNumber 异常名称 列出了各种异常的名字 表明NSDecimalNumber计算错误。 1234extern NSString *NSDecimalNumberExactnessException; //如果出现一个精确的错误extern NSString *NSDecimalNumberOverflowException; // 溢出extern NSString *NSDecimalNumberUnderflowException; //下溢extern NSString *NSDecimalNumberDivideByZeroException; //除数为0 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"金额计算","slug":"金额计算","permalink":"superdanny.link/tags/金额计算/"}]},{"title":"CocoaPods之repo换源和gem换源","date":"2016-12-04T07:21:00.000Z","path":"2016/12/04/CocoaPods-update-gem-and-repo/","text":"由于淘宝gem源维护困难，所以已经不再维护。目前已经有了替代方案。 安装CocoaPods之前的CocoaPods安装过程已经提及过，这里就不再累赘。 gem换源请尽可能用比较新的 RubyGems 版本，建议 2.6.x 以上。 123gem update --system # 这里请翻墙一下gem -v2.6.6 1234gem sources --add https://gems.ruby-china.org/ --remove http://ruby.taobao.org/gem sources -lhttps://gems.ruby-china.org# 确保只有 gems.ruby-china.org pod repo换源1pod repo 会出现以下的字眼（本人以前有多个源，后来全部去掉了。自己直接使用的官方源） 12345678910111213141516artsy- Type: git (master)- URL: https://github.com/Artsy/Specs.git- Path: /Users/superdanny/.cocoapods/repos/artsygetuilaboratory- Type: git (master)- URL: https://github.com/GetuiLaboratory/Specs.git- Path: /Users/superdanny/.cocoapods/repos/getuilaboratorymaster- Type: git (master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/superdanny/.cocoapods/repos/master3 repos 如果有出现跟我一样的多个源时，可以删除不需要的源 123pod repo remove 源的名字# 比如我上面的‘getuilaboratory’、‘artsy’等pod repo remove artsy 接下来就是更换源 123pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update Cocoapods使用技巧每次我们执行pod install、pod update时都会更新整个specs库，这样非常费时，所以想在不更新specs库的前提下安装三方库。 只有当觉得specs库太旧了之后或者specs库里面找不到某个三方库时才进行更新specs库。 12pod install --verbose --no-repo-updatepod update --verbose --no-repo-update 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"终端","slug":"终端","permalink":"superdanny.link/tags/终端/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"superdanny.link/tags/CocoaPods/"},{"name":"Gem","slug":"Gem","permalink":"superdanny.link/tags/Gem/"}]},{"title":"2016，我的年终总结-写给自己的一封信","date":"2016-11-26T11:49:00.000Z","path":"2016/11/26/2016-Year-end-summary/","text":"今年已经是我第二个年头写总结了，相比去年的工作总结，今年的总结，我侧重说说自己一年来的感悟，工作上的事情会涉及比较少。 能力与责任不知不觉，已经在公司呆了快2年，公司的事业也一步步走向正轨，回想起当初兴致勃勃的来到公司时，对比起现在多了几分愁容（愁在买房），少了几分幼稚。我想，这应该是每个人都会经历的事情。随着年龄的增长，考虑的事情也就越来越多，压力也就慢慢随着增大，随之而来的就有可能是这几种结果： 1、身心疲惫，几近瓦解；2、事业有成，踌躇满志；3、平平淡淡，得过且过； 我想，每个人都应该很清楚自己目前的状态。但是，不管是好是坏，只要能够认清自己，明确目标，始终不放弃，我想，再落寞也能够“拨开云雾见青天”。我这个人有一个缺点，就是心态时好时坏，但是我有一个不认输的心。因为我会考虑后果，所以很多事情我都会考虑到后果，哪些应该做，哪些不应该做。当然我不是做的最好，但是我一直在努力。 低调做事有度，切勿自大自打我踏出社会之后，很多事情看破了，也看淡了许多。看待事情的态度也就不会像当初那样较真。年轻那会好胜心强（好像把自己说老了…），什么事情都喜欢较真，一定要分出一个是非对错，孰高孰低，孰优孰略。即便最后自己胜利了，满足了自己的好胜心，结果也只会两败俱伤，吃力不讨好。所以凡事都要有个“度”，既要大度、有度量，又要适可而止，别太较真。回想起以往自己的性格，就是过于较真，所以很多时候总是吃力不讨好。现在想想觉得实在是太幼稚了(৹ᵒ̴̶̷᷄﹏ᵒ̴̶̷᷅৹)。 另外自大是一个人最致命的弱点，不懂得谦虚的人是成不了大器的，因为这样只会让别人疏远你。梁启超说过，“自信与骄傲有异；自信者常沉着，而骄傲者常浮扬。”。我们每一个人都有自己的弱点，学会隐藏自己的弱点何尝不是一件好事。但是缺点就不一样，我们应该是改掉缺点，而不是将其藏埋于心。一个人之所以能够很出色，很成功，绝大部分原因是这个人能够看清自己的缺点，学习别人的优点，从而弥补自己的不足。正所谓“金无足赤，人无完人”。 好了，上面扯了一大堆大道理，我只是想表达自己这一年来的感慨以及自己以往幼稚的性格与心态。希望通过总结，反思自己。 买房风波中国有一个很明显的特色，就是每个人到了一定年龄都会操心买房。我也不例外，我今年因为买房的事情可以说是操碎了心，身心疲惫，几近崩溃。不过从那以后我也更加认清自己，凡事都不能太过急于求成。至于中间发生了什么就不多说了。此处省略一万个字… 健康为本俗话说得好，身体是革命的本钱。人再有钱，身体垮了，再多钱也无福消受。尤其是干我们 IT 这一行的更应该清楚的认识到，并且把它看做是第一位。今年我就不再发自己的自拍照，因为我太胖了，身体大不如去年，所以在最近的这段时间，我开始锻炼身体，不想因为由于工作的缘故而把自己的身体搞出毛病。今年我看过最多的就是“某某公司某某员工猝死”之类的新闻，想想都觉得不寒而栗。父母辛辛苦苦把我们养大，不是想看到这种结果。身体是自己的，我希望每个人都应该认真看待。 未来道路2016这一年来，我的能力提升相比去年步调慢下来了，由于种种因素使得我放慢步调，开始思考接下来的人生道路。随着 IT 时代的发展，社会竞争也越来越激烈。以往的技术已经无法再满足需求，企业对新技术新领域的开拓也就越来越强烈，一个人只懂得一门技术已经完全不能满足当前社会的需要。所以职业的发展道路方向的选择也就变得复杂多。是一直平淡无奇的当着一个小码农？还是从技术转管理？亦或者是横向发展？每个人的选择都不同。我的方向一直是明确的，但是要想实现当初的目标，我发现不单单只会一门技术就行，唯有横向发展之后，了解了不同技术领域，之后方可纵观全局，处理问题时才不至于过于片面。 2016已经接近尾声，即将迎来的是崭新的2017。我希望经过2016这一年的经历与感悟之后，能够给我的2017带来帮助。我也希望能够更加的接近我的目标，一步一个脚印的朝着我的目标前进。不管前路多坎坷，目标也不能有一丝的动摇。 希望自己不要只是纸上谈兵。还是应该付诸行动，“少壮不努力，老来被唾弃”。","tags":[{"name":"年终总结","slug":"年终总结","permalink":"superdanny.link/tags/年终总结/"}]},{"title":"Xcode8，你为什么这么坑","date":"2016-09-26T08:02:00.000Z","path":"2016/09/26/Xcode8-pit/","text":"开启吐槽模式为了迎合Xcode8所带来的更新，我是惊喜万分(奔溃至极)。丝毫不敢怠慢，生怕跟不上入坑的队伍😂 坑一：storyboard或xib部分图片真机显示不了12345- (void)awakeFromNib &#123; [super awakeFromNib]; //加上这句 [self layoutIfNeeded];&#125; 坑二：打包之后无法在开发者中间看到新构建的版本（或iOS10访问相机、相册等闪退）原因是iOS10为了保护隐私，需要在 info.plist 里添加配置，包括定位、摄像头、麦克风、相册、相机等等。 访问权限一览表 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 通讯录 --&gt; &lt;key&gt;NSContactsUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问通讯录&lt;/string&gt; &lt;!-- 相册 --&gt; &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问相册&lt;/string&gt; &lt;!-- 相机 --&gt; &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问相机&lt;/string&gt; &lt;!-- 麦克风 --&gt; &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问麦克风&lt;/string&gt; &lt;!-- 位置 --&gt; &lt;key&gt;NSLocationUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问位置&lt;/string&gt; &lt;!-- 在使用期间访问位置 --&gt; &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;/string&gt; &lt;!-- 始终访问位置 --&gt; &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能始终访问位置&lt;/string&gt; &lt;!-- 日历 --&gt; &lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问日历&lt;/string&gt; &lt;!-- 提醒事项 --&gt; &lt;key&gt;NSRemindersUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问提醒事项&lt;/string&gt; &lt;!-- 运动与健身 --&gt; &lt;key&gt;NSMotionUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问运动与健身&lt;/string&gt; &lt;!-- 健康更新 --&gt; &lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问健康更新 &lt;/string&gt; &lt;!-- 健康分享 --&gt; &lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问健康分享&lt;/string&gt; &lt;!-- 蓝牙 --&gt; &lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问蓝牙&lt;/string&gt; &lt;!-- 媒体资料库 --&gt; &lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;/string&gt; 如果不起作用,可以请求后台权限,类似于这样:123456&lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt; &lt;!-- 在这里写上你在后台模式下要使用权限对应的key --&gt; &lt;string&gt;location&lt;/string&gt;...&lt;/array&gt; 或者在Xcode里选中当前的target，选择 Capabilities ，找到 Background Modes ，打开它，在里面选择对应权限 坑三：控制面板输出不完整1#define NSLog(format, ...) printf(\"\\n[%s] %s [第%d行] %s\\n\", __TIME__, __FUNCTION__, __LINE__, [[NSString stringWithFormat:format, ## __VA_ARGS__] UTF8String]); 坑四：NSUserDefaults问题NSUserDefaults问题 坑五：插件无法使用问题如何优雅的使用Xcode8或iOS10 SDK 坑六：Xcode8之xibXcode8 打开Xib之后，Xcode7 无法打开当我们使用Xcode8打开以前的旧工程的xib文件时，会弹窗提示我们选择设备。 当我们选择之后虽然Xcode8可以查看xib文件，但是当我们使用旧版本Xcode打开查看xib文件是就会提示无法查看，需要使用高版本Xcode打开。 想要能够在低版本Xcode查看Xib，需要在Xcode8上面重新选择xib打开的版本为Xcode7.x Xcode8 打开Xib更新之后，约束报警告被xib坑完之后，接下来就是崩溃的时刻，所有有涉及约束的视图全部报警告。我们需要更新所有存在警告视图的frame。 坑七：应用提交AppStore失败使用旧版本的Application Loader进行提交。","tags":[{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"iOS10","slug":"iOS10","permalink":"superdanny.link/tags/iOS10/"},{"name":"Xcode8","slug":"Xcode8","permalink":"superdanny.link/tags/Xcode8/"}]},{"title":"如何优雅的使用Xcode8或iOS10 SDK","date":"2016-09-16T15:59:00.000Z","path":"2016/09/16/How-to-use-Xcode8-or-iOS10_SDK/","text":"需求由于Xcode8 不再支持第三方插件，对于大部分开发者来说是一个噩耗！我也不例外，为了能够找到解决方案，我出去外面查阅了很多资料，总的来说有两种方案，一种是重签名Xcode8，另外一种是变相使用Xcode7.3.1运行iOS10 SDK。目前我采用的是方案二。 方案一：重签名Xcode8本方案转载至Vong 编译 MakeXcodeGr8Again 并且导出其 product (关于 MakeXcodeGr8Again，下文会详细说到)。 退出 Xcode8，同时运行刚刚导出的 MakeXcodeGr8Again，将 Xcode8 拖入其中，等待一段时间(3~10分钟)。 等菊花转完后，应用程序文件夹下会生成一个 XcodeGr8 的应用，运行命令 sudo xcode-select -s /Applications/XcodeGr8.app/Contents/Developer 将 Xcode 开发路径指向刚生成的 XcodeGr8。 既然 Xcode8 的签名已被移除，那么就可以继续使用上面的修复插件失效代码。但是上面的脚本要稍微改一下就是把 Xcode.app 换成 XcodeGr8.app 即可。代码如下： 1find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/XcodeGr8.app/Contents/Info.plist DVTPlugInCompatibilityUUID` 下面我们来看下步骤1提到的 MakeXcodeGr8Again，其 ReadMe 也有对应的介绍。这里大概摘录一下: 苹果为了避免类似 Xcode Ghost 👻 事件的再次发生，Xcode8 禁用了插件机制，而开放了另一种形式：Source Editor extensions，但是这种形式局限性太大。MakeXcodeGr8Again 只是去除了它的签名，这样使得 Xcode8 也可以继续使用插件了。由于签名被移除，所以它的安全性又重回 Xcode7 时代，也就是还有可能受到类似 Xcode Ghost 的攻击。所以不推荐用 XcodeGr8 来提交应用到 Appstore。Use at your own risk. 可能遇到的问题 生成了 XcodeGr8 之后，打不开。 解决方法：重启。 如果之前对其它版本的 Xcode-beat 也有使用这种方式，再对 Xcode8 GM 也是用该方式可能 MakeXcodeGr8Again 这个 APP 会一直闪退。 解决方法：卸载之前生成的 XcodeGr8，再重试。卸载后记得将开发路径重新指回原来的路径，即 sudo xcode-select -s /Applications/Xcode.app/Contents/Developer。如果这种方式还不行，卸载所有版本的 Xcode，然后再安装 GM 版，重复上述步骤。 如果要卸载 XcodeGr8，记得将重新开发路径置回初始状态。 最后，重要的事情说三遍： 不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！ 不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！ 不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！ 方案二：在Xcode7.3.1中使用iOS10 SDK本方案来至how-use-xcode-7-with-ios-10 文章的意思就是将Xcode8的iOS10 SDK拷贝到Xcode7上面，然后再创建一个软链接即可。 You need use DeveloperDiskImage from Xcode 8. For this extract Xcode 8 app and copy DeveloperDiskImage for iOS 10 to your Xcode folder. Suppose you extract Xcode to /Applications/Xcode8.app 1cp -r /Applications/Xcode8.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/10.0\\ \\(14A345\\) /Applications/Xcode7.3.1.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport After copy DeveloperDiskImage you should start Xcode and connect iOS device to your mac. Edit:With a standard Xcode install one can create a soft link: 123sudo ln -s \\/Applications/Xcode8.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/10.0\\ \\(14A345\\) \\/Applications/Xcode7.3.1.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/10.0 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"iOS10","slug":"iOS10","permalink":"superdanny.link/tags/iOS10/"},{"name":"Xcode8","slug":"Xcode8","permalink":"superdanny.link/tags/Xcode8/"}]},{"title":"升级CocoaPods后存在的问题","date":"2016-05-16T06:19:00.000Z","path":"2016/05/16/CocoaPods-concrete-target/","text":"问题今天由于需要，去升级了CocoaPods的版本，更新版本完成之后，在执行pod install指令时出现了问题。 12[!] The dependency `AFNetworking` is not used in any concrete target.The dependency `SDWebImage` is not used in any concrete target. 根据提示，是说我没有给这些第三方库指明对应的target。Podfile升级之后到最新版本，pod里的内容必须明确指出所用第三方库的target，否则会出现The dependency `` is not used in any concrete target这样的错误。 解决方法原本我工程里面Podfile是这样写的： 1234platform :ios, &apos;8.0&apos;use_frameworks!pod &apos;AFNetworking&apos;pod &apos;SDWebImage&apos; 现在需要修改Podfile的写法： 123456platform :ios, &apos;8.0&apos;use_frameworks!target &quot;Project target&quot; dopod &apos;AFNetworking&apos;pod &apos;SDWebImage&apos;end 这样再运行pod install指令就会成功了。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"终端","slug":"终端","permalink":"superdanny.link/tags/终端/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"superdanny.link/tags/CocoaPods/"}]},{"title":"iOS修改导航堆栈视图","date":"2016-04-26T09:46:00.000Z","path":"2016/04/26/iOS-Change-navigation-stack/","text":"需求有时候我们需要在视图跳转时，或者某些操作时需要将导航堆栈中的某个视图或多个视图移除堆栈中，目的是为了让返回过程中不会经过需要移除的视图。 实现代码12345678910//比如：vc1 push vc2。vc2 push vc3。然后vc2从导航堆栈中移除。//可以在vc2中实现如下代码//跳转到vc3ViewController *vc3 = [[ViewController alloc] init];[self.navigationController pushViewController:vc3 animated:YES]; NSMutableArray *arr = self.navigationController.viewControllers.mutableCopy;//操作arr[arr removeObject:weakSelf];self.navigationController.viewControllers = arr; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"导航栏","slug":"导航栏","permalink":"superdanny.link/tags/导航栏/"}]},{"title":"CocoaPods切换国内镜像源以及镜像源制作","date":"2016-04-20T12:13:00.000Z","path":"2016/04/20/Change-CocoaPods-Source/","text":"需求很多时候我们需要借助CocoaPods管理第三方开源类库，但是由于国内开发者直接使用CocoaPods是经常速度缓慢导致更新或者安装时候需要等待非常长的时间。 方法有几种： 借助VPN来解决 很多时候是通过切换成国内的镜像源来达到目的。 在pod install、pod update的时候不升级specs库 12$ pod install --verbose --no-repo-update$ pod update --verbose --no-repo-update 切换镜像源1234pod repo remove masterpod repo add master 镜像源地址pod repo updatepod setup 镜像源制作当然，以来与别人的镜像源也不是最好的办法。我们也可以尝试自己制作属于自己的镜像源。 初始化1git clone --mirror https://github.com/CocoaPods/Specs.git 编辑config文件12345678910111213[core] repositoryformatversion = 0 filemode = true bare = true[remote &quot;origin&quot;] fetch = +refs/heads/*:refs/heads/* fetch = +refs/tags/*:refs/tags/* mirror = true url = https://github.com/CocoaPods/Specs.git[remote &quot;mirrors&quot;] url = git@gitcafe.com:lloydsheng/Specs.git mirror = true skipDefaultUpdate = true 定期同步编辑同步脚本specssync.sh，添加： 12git fetch remotegit push mirrors 设置cronjob每半个小时同步一次 1230 * * * * /home/git/specssync.sh &gt; /var/log/specssync.log 2&gt;&amp;1 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"终端","slug":"终端","permalink":"superdanny.link/tags/终端/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"superdanny.link/tags/CocoaPods/"}]},{"title":"swift中的枚举,结构体和类(简译)","date":"2016-03-09T01:40:00.000Z","path":"2016/03/09/Swift-Getting-to-Know-Enums-Structs-and-Classes/","text":"前言本文将对阅读的国外文章进行自己的理解翻译，有哪些不对的地方还望指正。 Swift类型Swift有三个吸引人的地方就是它的安全，快速，简单。 安全意味着它很难在你编写完程序之后在运行期间出现某些错误，导致你无法捕获。并且在编写代码期间它也能够检测到代码存在的问题并加以提示，而不是等到运行程序之后有问题你才去寻找问题所在。 此外，Swift可以让你更清楚的知道代码的作用是什么，并且帮助优化你的代码。 Swift的核心在于简单和高度规范化。实现这个的关键在于Swift的类型系统： 系统由4个命名类型： protocol(协议), enum(枚举), struct(结构体), class(类) 以及2个组合类型：tuple(元组), function(函数) 组成。 可能你会觉得还有其他的基本类型：Bool, Int, UInt, Float, Double, Character, String, Array, Set, Dictionary, Optional 等等。其实他们都是建立在命名类型上并且作为Swift标准库中的一部分。 本文只针对命名类型中的enum(枚举), struct(结构体), class(类)进行展开。 枚举当我们需要给某些属性赋已经规定好值的时候。如果我们自己手动拼写字符串的形式，那么很容易出现拼错的情况。就比如，人类根据肤色可以分为三种：黄种人(yellow)，白种人(white)，黑种人（black）假如我们使用通过手动拼写字符串的形式进行赋值时，那么可能会出现下面这种情况： 12let human: Human = Human()human.skinColor = \"whit\" 由于采用字符串的方式输入，导致我们错误的将white写成了whit这个时候就不能将这个人正确的分类。 这个时候枚举就起到作用了。我们使用枚举的形式将特定的类型封装好，在使用的时候，通过选择的方式，避免了输入有误的情况发生。 枚举成员的值的类型可以是字符串，字符，或是一个整型值或浮点数 123456789101112131415161718//方式一：手动赋值enum ColorName: String &#123; case Yellow = \"Yellow\" case White = \"White\" case Black = \"Black\"&#125;//方式二：编译器自动将成员名以字符串形式作为其值enum ColorName: String &#123; case Yellow case White case Black&#125;let human: Human = Human()//这个时候编译器会告知你输入错误human.skinColor = ColorName.Whit//正确识别human.skinColor = ColorName.White 关联值(Associated Values)就比如上面的颜色例子来说，我们表示颜色的有多种形式：名称, RGB, HSL(色调(H)、饱和度(S)、亮度(L))等等。我们如何将这些统一规范起来呢？ 1234enum ColorModel &#123; case Named(ColorName) case RGB(UInt8, UInt8, UInt8)&#125; 通过上面存储关联值的做法，我们就可以利用 ColorModel 中其中一种状态来表示颜色。这样的好处在于： 成员 Named 也只能用已经给定的属性进行赋值 RGB中的UInt8取值范围在0~255，符合取值范围 通过 Protocols 协议配合 extension 扩展枚举功能 在Swift中，像enum(枚举)等命名类型都可以通过继承 Protocols 协议进行功能扩展，达到我们需要的功能。 形式一：通过继承 CustomStringConvertible 协议扩展枚举打印功能 123456789101112131415161718extension ColorModel : CustomStringConvertible &#123; var description: String &#123; switch self &#123; case .Named(let colorName): return colorName.rawValue case .RGB(let red, let green, let blue): return String(format: \"#%02X%02X%02X\", red,green,blue) &#125; &#125;&#125;//通过 extension 扩展和继承，实现枚举的`description`功能let color1 = ColorModel.Named(.Red)let color2 = ColorModel.RGB(0xAA, 0xAA, 0xAA)//color1.description//color2.descriptionprint(\"color1 = \\(color1), color2 = \\(color2)\")// prints color1 = Red, color2 = #AAAAAA 形式二：扩展枚举初始化功能 123456789extension ColorModel &#123; init(gray: UInt8) &#123; self = .RGB(gray, gray, gray) &#125;&#125;//通过 extension 扩展，实现初始化枚举类型时赋值初始值let color3 = ColorModel(gray: 0xaa)print(color3) // prints #AAAAAA 命名空间上述例子中，我们定义的 ColorName 枚举仅仅是为了给 ColorModel 枚举使用，没必要将 ColorName 给外部知道。所以可以将 ColorName 的定义放在 ColorModel 的扩展里面。作为其一部分即可。 12345extension ColorModel &#123; enum ColorName : String &#123; case Black, Silver, Gray, White, Maroon, Red, Purple, Fuchsia, Green, Lime, Olive, Yellow, Navy, Blue, Teal, Aqua &#125;&#125; Note: Swift的一个特点之一就是你不需要在使用这个命名类型之前声明它。这也是与C/C++/Objective-C的不同之处。 另外，在Swift中是没有宏定义的说法的，那么我们可以通过枚举的方式将部分数学宏封装起来。比如经常用到的 M_PI 我们通过定义枚举 Math。 123enum Math &#123; static let pi = 3.1415926535897932384626433832795028841971694&#125; 结构体值类型 vs 引用类型未完待续… 类未完待续… 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"superdanny.link/tags/Swift/"},{"name":"读书笔记","slug":"读书笔记","permalink":"superdanny.link/tags/读书笔记/"}]},{"title":"Apple Pay 入门（转）","date":"2016-02-20T05:30:00.000Z","path":"2016/02/20/iOS-Apple-Pay/","text":"Pay官方参考资料 概述利用 Apple Pay，用户可以在您的 App 中轻松安全地购买实物商品和服务。客户更喜欢使用 Apple Pay，因为他们在购物时无需输入账单、送货和联系人详细信息。而且，Apple Pay 具有更高的安全性，能让客户和开发者安心使用。Apple 不会存储或共享客户的实际信用卡和借记卡卡号，因此商家和 App 开发者无需负责管理和保护实际的信用卡和借记卡卡号。进一步了解 Apple Pay 的安全与隐私政策。 由于具备这些优点，在按照推荐方式实施了 Apple Pay 之后，开发者的结账转换率提高为原来的 2 倍，结账时间也大幅缩短；而且，在整合了 Apple Pay 之后，客户的忠诚度和购买频率也都提高了。 在您的 App 中，用户可以使用 Touch ID 为付款授权，以释放安全地存储在 iPhone 和 iPad 上的令牌化信用卡和借记卡付款凭证。此外，用户还可将其账单、送货和联系人信息存储在 Wallet 这一 App 中。这样一来，当客户在您的 App 中使用 Touch ID 为购买项目授权时，系统就会随付款凭证一道提供这些信息。 目前，Apple Pay 可在澳大利亚、加拿大、中国、英国和美国使用。 Apple Pay 或 App 内购买项目了解 Apple Pay 和“App 内购买项目”之间的区别非常重要。使用 Apple Pay 可销售实物商品，如食品杂货、服装和电器。也可通过 Apple Pay 提供各种服务，如俱乐部会员、酒店预订和活动门票。而使用“App 内购买项目”则可销售虚拟商品，如适用于您的 App 的优质内容及订阅数字内容。 《Apple Pay 编程指南》（“Apple Pay Programming Guide”）提供了有关如何使用 PassKit 框架整合 Apple Pay 的详细信息。《App 内购买项目编程指南》（“In-App Purchase Programming Guide”）提供了有关如何使用 StoreKit 框架整合 App 内购买项目的详细信息。 先决条件除了使用 PassKit 框架实施 Apple Pay 之外，您还必须： 通过付款处理机构或网关设置一个帐户。 通过“证书、标识符和描述文件”（“Certificates, Identifiers &amp; Profiles”）注册一个商家 ID。 生成一个 Apple Pay 证书，用于加密和解密付款令牌。 在您的 App 中包括一个 Apple Pay 授权。 遵循“应用审核准则”的第 29 节中列出的要求。 遵循《App 审核准则》(“App Review Guidelines”)第 29 节中列出的要求。 支付供应商强烈建议选择支持 Apple Pay 并提供 SDK 的支付供应商。您也可以提供自己的服务器端解决方案，以用于从您的 App 接收付款、解密付款令牌并与支付供应商进行互动。信用卡和借记卡付款的处理可能非常复杂。如果您不具备相应的专业知识和系统，又希望您的 App 支持 Apple Pay，使用支付供应商提供的 SDK 是最为便捷可靠的一种方式。 显示 Apple Pay 按钮PassKit 提供了各种 API，您的 App 可以使用这些 API 来确定自己所在的设备上是否装有 Secure Element，以及设备是否已加载您所支持的付款卡。 如果设备已启用 Apple Pay，则您应该使用 PassKit 内提供的 API 来显示“用 Apple Pay 购买”按钮。 如果设备没有 Apple Pay，则您可以显示“设置 Apple Pay”按钮以代替“用 Apple Pay 购买”按钮，以便用户方便地设置 Apple Pay。或者，您也可以选择不显示 Apple Pay 按钮。 在您的 App 中放置 Apple Pay 按钮时，必须遵循《Apple Pay 识别标志指南》（“Apple Pay Identity Guidelines”）。 显示付款单在您的用户选择好要购买的商品或服务，并选择 Apple Pay 作为付款方式时，您会创建一个付款请求，并要求 PassKit 向客户显示付款单。请参见图 1。在用户轻点 Apple Pay 按钮后，付款单必须立即显示，中间不能出现任何临时屏幕或弹出窗口。 您的 App 可以指定付款单的内容，但无法控制用户与其进行的互动。您必须确定，向用户显示送货信息、账单信息、送货方式和其他行项目是否有意义。您只应请求处理交易所需的信息。 有关为您的 App 整合 Apple Pay 按钮和定制 Apple Pay 付款单的详细信息，请参考《iOS 人机界面准则》（“iOS Human Interface Guidelines”）。 图1 付款令牌在用户使用 Touch ID 和银行 PIN 码进行授权（必要时）后，您的 App 会从 PassKit 收到一个付款令牌。该付款令牌内含有完成付款交易所需的信息，包括设备特定的帐户编号、金额以及唯一的一次性密码。已加密的付款套装可由商家使用私有密钥证书来解密，也可由付款处理机构使用 SDK 替商家代为解密。 在有些情况下，开发者可能未被设置为负责记录和处理付款的商家。在这种情况下，开发者可以解密付款令牌，并将解密后的令牌传递给下游合适的商家，以便相应的处理机构进行处理。App 必须清楚表明自己只是一个中介方。更多详细信息，请参考《iOS 人机界面准则》（“iOS Human Interface Guidelines”）。 图 2 展示了一个典型的付款流程。首先，App 会检查其是否支持 Apple Pay 作为付款方式。在本例中，App 需要与所选送货地址相应的邮政编码，以计算送货成本并更新应付的总金额。在用户完成付款授权后，您的 App 会通过 PassKit 从 Secure Element 收到一个付款令牌。 最后， App 会调用付款处理机构 SDK 中的相应 API，以将付款信息传送至付款处理机构，交由其处理。 图2 支持的交易类型要处理以下类型的电子商务交易，必须要有支持 Apple Pay 的付款处理机构 SDK。 12345授权 付款处理机构 在客户的帐户上预留资金收款 付款处理机构 在订单成功完成后将资金转账到您的银行帐户部分发货 付款处理机构 针对无法一同发货的商品将某次购物分成多次付款（在中国不可用）重复付款 付款处理机构 - 应在 App 中清楚标出 处理针对服务的重复付款，如按月支付的健身房会费（在中国不可用）退单 付款处理机构 处理欺诈性交易或存在争议的交易 最佳做法查看《iOS 人机界面准则》（“iOS Human Interface Guidelines”）和 WWDC 研讨会视频“App 内的 Apple Pay”（“Apple Pay Within Apps”），并按照其中的指南操作。此外，请遵循以下最佳做法，以便让您的 App 呈现最佳效果。 不必要求用户注册。除非确有必要，否则用户在使用 Apple Pay 购物时不必要求他们注册。您可以在客户购物时获得必需的联系信息；客户遇到的阻碍越少，其改变付款方式的机率就越低。 在产品详细信息页面和购物车结账页面添加 Apple Pay 按钮。在产品详细信息页面上，除了“添加到购物车”按钮之外，还要放置一个 Apple Pay 按钮，以便客户在找到想要购买的产品后立即结账。还要确保在购物车结账页面上添加 Apple Pay 作为付款选项。 在醒目的位置显示 Apple Pay 按钮，或将默认付款方式设为 Apple Pay。对于已经在其 iOS 设备上设置了 Apple Pay 的用户，提供 Apple Pay 作为主要的付款选项。 请勿要求用户提供除 Apple Pay 付款单之外的其他信息。Apple Pay 付款单中含有送货地址、账单地址、电话号码、电子邮件和姓名。客户也可以在付款单中选择送货方式。要求用户提供付款单之外的其他信息会增加阻碍，这可能会导致客户放弃购买。 常见问题解答1. 哪些付款提供商支持此服务？ 有关付款提供商列表，请参阅 Apple Pay 开发者信息页面。 2. 支持哪些支付网络？ 支持参加计划的银行所发行的 Visa、MasterCard、American Express、Discover 和中国银联信用卡和借记卡。 3. 支持哪些卡片类型？ 支持主要发卡行所发行的信用卡和借记卡。 4. 接受 Apple Pay 需要支付其他费用吗？ 对于使用 Apple Pay 付款的用户、商家或开发者，Apple 不会收取任何费用。 5. 我能否将 Apple Pay 整合到采用 Web 结账方式的 App 中？ Apple Pay 支持原生和混合 App。对于那些采用 Web 结账方式的商家，请使用 WebKit 桥接允许数据从 Web 内容传送至原生 API（反之亦然）。 6. 我能否在不知道最终金额的情况下使用 Apple Pay 购物？ 对于使用 iOS 9 和更高版本的客户，您可以将金额设为“待定”。对于 iOS 9 之前的版本，您应该收取基本的金额，并在 Apple Pay 付款单的“PAY”（付款）行中指明最终金额待定。 在中国，商家/PSP/中国银联的付款流程均不支持此项功能，需在知晓最终金额的情况下进行购买。 官方Demo 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Apple Pay","slug":"Apple-Pay","permalink":"superdanny.link/tags/Apple-Pay/"}]},{"title":"iOS开发证书\"此证书的签发者无效\"解决方法","date":"2016-02-15T02:13:00.000Z","path":"2016/02/15/iOS-Certificate-has-an-invalid-issuer/","text":"前言哎，每次过完节都要有一个坑给自己跳。逃不过这个魔爪。这不，一过完春节，回来就发现公司证书出现”此证书的签发者无效”。 问题原因经过一番查找，苹果官方给出了回答。 Thanks for bringing this to the attention of the community and apologies for the issues you’ve been having. This issue stems from having a copy of the expired WWDR Intermediate certificate in both your System and Login keychains. To resolve the issue, you should first download and install the new WWDR intermediate certificate (by double-clicking on the file). Next, in the Keychain Access application, select the System keychain. Make sure to select “Show Expired Certificates” in the View menu and then delete the expired version of the Apple Worldwide Developer Relations Certificate Authority Intermediate certificate (expired on February 14, 2016). Your certificates should now appear as valid in Keychain Access and be available to Xcode for submissions to the App Store. 看来是由于苹果系统的安全证书过期问题导致。 苹果早在一个多月前就提醒开发者使用新证书。开发者如果不及时更新，不仅会影响到自己的开发工作，还有可能对用户造成困扰。这一份通知面向的是那些开发应用与 Apple Wallet、Safari 推送中心又或者是 Safari 插件相关的开发者。苹果还在通知中表示，开发者需要在 2016 年 2 月 14 日结束之前更新他们的安全证书。更新之后，安全证书的下一个失效期为 2023 年 2 月。 解决办法既然知道了原因，那么就可以对症下药了。我们通过下载苹果提供的最新的安全证书并双击安装。 然后打开钥匙串，在导航栏上，依次选择显示-显示已过期的证书 选择登录-所有项目 在搜索栏下输入 apple w 删除对应过期的安全证书 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"证书无效","slug":"证书无效","permalink":"superdanny.link/tags/证书无效/"}]},{"title":"iOS推送的那些事","date":"2016-02-02T05:40:00.000Z","path":"2016/02/02/iOS-Apple-Push-Notification-Service/","text":"关于推送关于苹果的推送网上已经有非常多的资源讲解，我在这里就不再累赘。直接切入主题，讲讲如何模拟推送以及处理推送消息。在进入主题之前，我先说几个关键流程： 创建Push SSL Certification(推送证书) iOS客户端注册Push功能并获得DeviceToken 使用Provider向APNS发送Push消息 iOS客户端接收处理由APNS发来的消息 推送流程图： Provider：就是为指定iOS设备应用程序提供Push的服务器。如果iOS设备的应用程序是客户端的话，那么Provider可以理解为服务端(推送消息的发起者)APNs：Apple Push Notification Service(苹果消息推送服务器)Devices：iOS设备，用来接收APNs下发下来的消息Client App：iOS设备上的应用程序，用来接收APNs下发的消息到指定的一个客户端app(消息的最终响应者) 获取Device tokenApp 必须要向 APNs 请求注册以实现推送功能，在请求成功后，APNs 会返回一个设备的标识符即 DeviceToken 给 App，服务器在推送通知的时候需要指定推送通知目的设备的 DeviceToken。在 iOS 8 以及之后，注册推送服务主要分为四个步骤： 使用 registerUserNotificationSettings:注册应用程序想要支持的推送类型 通过调用 registerForRemoteNotifications方法向 APNs 注册推送功能 请求成功时，系统会在应用程序委托方法中返回 DeviceToken，请求失败时，也会在对应的委托方法中给出请求失败的原因。 将 DeviceToken 上传到服务器，服务器在推送时使用。 上述第一个步骤注册的 API 是 iOS 8 新增的，因此在 iOS 7，前两个步骤需更改为 iOS 7 中的 API。 DeviceToken 有可能会更改，因此需要在程序每次启动时都去注册并且上传到你的服务器端。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; if ([application respondsToSelector:@selector(registerUserNotificationSettings:)]) &#123; NSLog(@\"Requesting permission for push notifications...\"); // iOS 8 UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes: UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil]; [UIApplication.sharedApplication registerUserNotificationSettings:settings]; &#125; else &#123; NSLog(@\"Registering device for push notifications...\"); // iOS 7 and earlier [UIApplication.sharedApplication registerForRemoteNotificationTypes: UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound]; &#125; return YES;&#125;- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)settings &#123; NSLog(@\"Registering device for push notifications...\"); // iOS 8 [application registerForRemoteNotifications];&#125;- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)token &#123; NSLog(@\"Registration successful, bundle identifier: %@, mode: %@, device token: %@\", [NSBundle.mainBundle bundleIdentifier], [self modeString], token);&#125;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error &#123; NSLog(@\"Failed to register: %@\", error);&#125;- (void)application:(UIApplication *)application handleActionWithIdentifier:(NSString *)identifier forRemoteNotification:(NSDictionary *)notification completionHandler:(void(^)())completionHandler &#123; NSLog(@\"Received push notification: %@, identifier: %@\", notification, identifier); // iOS 8 completionHandler();&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)notification &#123; NSLog(@\"Received push notification: %@\", notification); // iOS 7 and earlier&#125;- (NSString *)modeString &#123;#if DEBUG return @\"Development (sandbox)\";#else return @\"Production\";#endif&#125; 处理推送消息 当程序未启动，用户接收到消息。需要在AppDelegate中的didFinishLaunchingWithOptions得到消息内容 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; //... NSDictionary *payload = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; if (payload) &#123; //... &#125; //...&#125; 当程序在前台运行，接收到消息不会有消息提示（提示框或横幅）。当程序运行在后台，接收到消息会有消息提示，点击消息后进入程序，AppDelegate的didReceiveRemoteNotification函数会被调用，消息做为此函数的参数传入 12345678910111213141516171819202122- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)payload &#123; NSLog(@\"remote notification: %@\",[payload description]); NSString* alertStr = nil; NSDictionary *apsInfo = [payload objectForKey:@\"aps\"]; NSObject *alert = [apsInfo objectForKey:@\"alert\"]; if ([alert isKindOfClass:[NSString class]]) &#123; alertStr = (NSString*)alert; &#125; else if ([alert isKindOfClass:[NSDictionary class]]) &#123; NSDictionary* alertDict = (NSDictionary*)alert; alertStr = [alertDict objectForKey:@\"body\"]; &#125; application.applicationIconBadgeNumber = [[apsInfo objectForKey:@\"badge\"] integerValue]; if ([application applicationState] == UIApplicationStateActive &amp;&amp; alertStr != nil) &#123; UIAlertView* alertView = [[UIAlertView alloc] initWithTitle:@\"Pushed Message\" message:alertStr delegate:nil cancelButtonTitle:@\"OK\" otherButtonTitles:nil]; [alertView show]; &#125;&#125; 自定义通知提示音你可以在 App 的 Bundle 中加入一段自定义提示音文件。然后当通知到达时可以指定播放这个文件。必须为以下几种数据格式： Linear PCM MA4（IMA/ADPCM） μLaw aLaw 你可以将它们打包为aiff、wav或caf文件。自定义的声音文件时间必须小于 30秒，如果超过了这个时间，将被系统声音代替。 PayloadPayload 是通知的一部分，每一条推送通知都包含一个 Payload。它包含了系统提醒用户通知到达的方式，还可以添加自定义的数据。即通知主要传递的数据为 Payload。 Payload 本身为 JSON 格式的字符串，它内部必须要包含一个键为 aps 的字典。aps 中可以包含以下字段中的一个或多个： alert：其内容可以为字符串或者字典，如果是字符串，那么将会在通知中显示这条内容badge：其值为数字，表示当通知到达设备时，应用的角标变为多少。如果没有使用这个字段，那么应用的角标将不会改变。设置为 0 时，会清除应用的角标。sound：指定通知展现时伴随的提醒音文件名。如果找不到指定的文件或者值为 default，那么默认的系统音将会被使用。如果为空，那么将没有声音。content-available：此字段为 iOS 7 silent remote notification 使用。不使用此功能时无需包含此字段。 如果需要添加自定义的字段，就让服务器的小伙伴们跟aps同一层级添加一个数组（以Json为例）： 12345&#123; &quot;aps&quot; : &#123;&quot;alert&quot; : &quot;This is the alert text&quot;, &quot;badge&quot; : 1, &quot;sound&quot; :&quot;default&quot; &#125;, &quot;server&quot; : &#123;&quot;serverId&quot; : 1, &quot;name&quot; : &quot;Server name&quot;&#125;&#125; 这样收到的 Payload 里面会多一个 server 的字段。 模拟推送现在常用的后台server中，一般将推送证书以及推送证书的私钥导出.p12交给后台人员即可。 生成后台需要的推送证书准备： 苹果服务器证书端设置正确！打包证书、描述文件正确！！ 下载推送证书(cer格式)，导入keyChain，保证私钥存在，不存在去找创建这个证书的电脑要一份过来。 从钥匙串导出的根证书(推送证书)私钥(p12格式) 第三步根证书的私钥这里是一个坑！因为一个App的推送证书的创建可以和根证书创建的电脑不同，也就是keyChain产生的certSigningRequest不一样，所以私钥也是不一样的，在这里生成Pem时，注意要使用推送证书的私钥！ PHP需要的.Pem证书PHP有点调皮，需要转换成pem 操作过程： 把推送证书(.cer)转换为.pem文件，执行命令： 1$ openssl x509 -in 推送证书.cer -inform der -out 推送证书.pem 把推送证书导出的私钥(.p12)文件转化为.pem文件： 12345678$ openssl pkcs12 -nocerts -out 推送证书私钥.pem -in 推送证书私钥.p12 $ Enter Import Password: //先输入私钥的密码$ MAC verified OK$ Enter PEM pass phrase: //设置两次相同的密码短语\u0010$ Verifying – Enter PEM pass phrase:// 你首先需要为.p12文件输入pass phrase密码短语，这样OpenSSL可以读它。然后你需要键入一个新的密码短语来加密PEM文件。你需要选择一些更安全的密码短语。为了方便管理，例如我统一使用`pushchat`来作为PEM的密码短语。// 注意：如果你没有键入一个PEM passphrase，OpenSSL将不会返回一个错误信息，但是产生的.pem文件里面将不会含有私钥。 对生成的这两个pem文件再生成一个pem文件，来把证书和私钥整合到一个文件里： 1$ cat 推送证书.pem 推送证书私钥.pem &gt;PHPPush.pem 然后把这个PHPPush.pem给后台基友们，就可以下班啦。 Java/.Net需要的.p12证书若使用Java/.Net服务器需要将生成的私钥per文件和cer生成的per文件合并成一个.p12文件 前两个步骤同PHP需要的Pem证书步骤是一样的，只是第三个步骤有些许不同。 注意：第三个步骤这里还需要一个.certSigningRequest(csr)文件。 1$ openssl pkcs12 -export -in 推送证书.pem -inkey 推送证书私钥.pem -certfile CertificateSigningRequest.certSigningRequest -name &quot;项目名_Production(或项目名_Development)&quot; -out 项目名_Production(或项目名_Development).p12 然后把这个项目名_Production(或项目名_Development).pem给后台基友们，就可以下班啦。 当然测试推送也比较麻烦，需要模拟真实的推送环境，一般需要后台提供帮助，但是遇到一些后台同事，他们有强烈地信仰着鄙视链的话，很鄙视iOS，心里早就称呼你“死前端”多年了，还那么多事…… 所以关于调试推送，这里有两种方式实现自推！不麻烦别人。 注意：如果出现“unable to load certificates”，把第三条命令的 -certfile CertificateSigningRequest.cerSigningRequest参数去掉即可 另外可参考如下文章：生成服务端推送证书 模拟推送一：通过终端推送123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// devicetoken $deviceToken = '你的deviceToken';// 私钥密码，生成pem的时候输入的$passphrase = '123456';// 定制推送内容，有一点的格式要求，详情Apple文档$message = array( 'body'=&gt;'你收到一个新订单');$body['aps'] = array( 'alert' =&gt; $message, 'sound' =&gt; 'default', 'badge' =&gt; 100, );$body['type']=3;$body['msg_type']=4;$body['title']='新订单提醒';$body['msg']='你收到一个新消息';$ctx = stream_context_create();stream_context_set_option($ctx, 'ssl', 'local_cert', 'push.pem');//记得把生成的push.pem放在和这个php文件同一个目录stream_context_set_option($ctx, 'ssl', 'passphrase', $passphrase);$fp = stream_socket_client( //这里需要特别注意，一个是开发推送的沙箱环境，一个是发布推送的正式环境，deviceToken是不通用的 'ssl://gateway.sandbox.push.apple.com:2195', $err, //'ssl://gateway.push.apple.com:2195', $err, $errstr, 60, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);if (!$fp) exit(\"Failed to connect: $err $errstr\" . PHP_EOL);echo 'Connected to APNS' . PHP_EOL;$payload = json_encode($body);$msg = chr(0) . pack('n', 32) . pack('H*', $deviceToken) . pack('n', strlen($payload)) . $payload;$result = fwrite($fp, $msg, strlen($msg));if (!$result) echo 'Message not delivered' . PHP_EOL;else echo 'Message successfully delivered' . PHP_EOL;fclose($fp);?&gt; 将上面的代码复制，保存成push.php 然后根据上面PHP需要的Pem证书的步骤生成push.pem 两个文件放在同一目录 执行下面的命令 1$ php push.php 结果为 12Connected to APNSMessage successfully delivered 模拟推送二：通过工具推送Github 上面有位大神分享了他的推送工具NWPusher，大大减少了开发人员的工作量。具体用法说明上面写的很清楚，这里就不再重复。 补充2016年02月18日 昨天由于有个应用的推送证书过期了，所以需要重新生成新的推送证书。偶然之间发现苹果的推送证书更新了，一开始还觉得有些跟以前不同，在这里记录一下，方面后人不入坑。 Apple Push Notification Service UpdateDecember 17, 2015At WWDC 2015 we announced a new HTTP/2 based provider API and simplified certificate management process for developers using the Apple Push Notification service. You can now take advantage of this new provider API and create a single SSL certificate for each of your iOS apps, allowing you to connect to both APNs environments. To learn more, read the Local and Remote Notification Programming Guide and watch What’s New in Notifications. 2016年02月20日 当上线产品推送证书过期时，不要惊慌，我们不需要更新推送证书之后重新提交 AppStore 。只需要替换服务器端的推送证书即可(记得重启服务器，不然推送在测试环境下有效，但是在真实环境下是无效的)。 2016年12月27日 iOS 10 已经出了好长一段时间，一直想补充这一块推送的差异，今天趁这个空闲，补充一下。从 iOS 10 新增的 UserNotifications Framework 可以发现，Apple 整合了原有散乱的 API，并且增加了许多强大的功能。以 Apple 官方的角度来看，也必然是相当重视推送服务对 App 的影响、以及对 Apple iOS 生态圈长远发展的影响。 这里直接引用别人写的博文，个人认为写的很全面，这边就不做展开。 玩转 iOS 10 推送 —— UserNotifications Framework（上）玩转 iOS 10 推送 —— UserNotifications Framework（中）玩转 iOS 10 推送 —— UserNotifications Framework（下） 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"推送","slug":"推送","permalink":"superdanny.link/tags/推送/"}]},{"title":"iOS图片压缩上传","date":"2016-01-28T03:55:00.000Z","path":"2016/01/28/iOS-Upload-Image/","text":"需求很多时候我们上传图片经常遇到一些问题，要不就是图片质量变差，要不就是图片太大等等问题。这里，我找到了一个算是目前比较符合需求的解决方案。在原有基础上增加了动态压缩系数，改写成Swift版本，最底下贴出OC版本。 实现思路先调整分辨率，分辨率可以自己设定一个值，大于的就缩小到这分辨率，小余的就保持原本分辨率。然后再根据图片最终大小来设置压缩比，比如传入maxSize = 30KB，最终计算大概这个大小的压缩比。基本上最终出来的图片数据根据当前分辨率能保持差不多的大小同时不至于太模糊，跟微信，微博最终效果应该是差不多的，代码仍然有待优化！ 实现代码Swift3.0之前旧版本压缩模式（建议不用，性能太差）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// MARK: - 降低质量 func resetSizeOfImageData(source_image: UIImage, maxSize: Int) -&gt; NSData &#123; //先调整分辨率 var newSize = CGSize(width: source_image.size.width, height: source_image.size.height) let tempHeight = newSize.height / 1024 let tempWidth = newSize.width / 1024 if tempWidth &gt; 1.0 &amp;&amp; tempWidth &gt; tempHeight &#123; newSize = CGSize(width: source_image.size.width / tempWidth, height: source_image.size.height / tempWidth) &#125; else if tempHeight &gt; 1.0 &amp;&amp; tempWidth &lt; tempHeight &#123; newSize = CGSize(width: source_image.size.width / tempHeight, height: source_image.size.height / tempHeight) &#125; UIGraphicsBeginImageContext(newSize) source_image.drawAsPatternInRect(CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() //先判断当前质量是否满足要求，不满足再进行压缩 var finallImageData = UIImageJPEGRepresentation(newImage,1.0) let sizeOrigin = Int64((finallImageData?.length)!) let sizeOriginKB = Int(sizeOrigin / 1024) if sizeOriginKB &lt;= maxSize &#123; return finallImageData! &#125; //保存压缩系数 let compressionQualityArr = NSMutableArray() let avg = CGFloat(1.0/250) var value = avg for var i = 250; i&gt;=1; i-- &#123; value = CGFloat(i)*avg compressionQualityArr.addObject(value) &#125; //调整大小 //说明：压缩系数数组compressionQualityArr是从大到小存储。 //思路：折半计算，如果中间压缩系数仍然降不到目标值maxSize，则从后半部分开始寻找压缩系数；反之从前半部分寻找压缩系数 finallImageData = UIImageJPEGRepresentation(newImage, CGFloat(compressionQualityArr[125] as! NSNumber)) if Int(Int64((UIImageJPEGRepresentation(newImage, CGFloat(compressionQualityArr[125] as! NSNumber))?.length)!)/1024) &gt; maxSize &#123; //拿到最初的大小 finallImageData = UIImageJPEGRepresentation(newImage, 1.0) //从后半部分开始 for idx in 126..&lt;250 &#123; let value = compressionQualityArr[idx] let sizeOrigin = Int64((finallImageData?.length)!) let sizeOriginKB = Int(sizeOrigin / 1024) print(\"当前降到的质量：\\(sizeOriginKB)\") if sizeOriginKB &gt; maxSize &#123; print(\"\\(idx)----\\(value)\") finallImageData = UIImageJPEGRepresentation(newImage, CGFloat(value as! NSNumber)) &#125; else &#123; break &#125; &#125; &#125; else &#123; //拿到最初的大小 finallImageData = UIImageJPEGRepresentation(newImage, 1.0) //从前半部分开始 for idx in 0..&lt;125 &#123; let value = compressionQualityArr[idx] let sizeOrigin = Int64((finallImageData?.length)!) let sizeOriginKB = Int(sizeOrigin / 1024) print(\"当前降到的质量：\\(sizeOriginKB)\") if sizeOriginKB &gt; maxSize &#123; print(\"\\(idx)----\\(value)\") finallImageData = UIImageJPEGRepresentation(newImage, CGFloat(value as! NSNumber)) &#125; else &#123; break &#125; &#125; &#125; return finallImageData! &#125; Swift3.0版本二分法压缩模式（推荐）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// MARK: - 降低质量 func resetSizeOfImageData(sourceImage: UIImage!, maxSize: Int) -&gt; NSData &#123; //先判断当前质量是否满足要求，不满足再进行压缩 var finallImageData = UIImageJPEGRepresentation(sourceImage,1.0) let sizeOrigin = finallImageData?.count let sizeOriginKB = sizeOrigin! / 1024 if sizeOriginKB &lt;= maxSize &#123; return finallImageData! as NSData &#125; //获取原图片宽高比 let sourceImageAspectRatio = sourceImage.size.width/sourceImage.size.height //先调整分辨率 var defaultSize = CGSize(width: 1024, height: 1024/sourceImageAspectRatio) let newImage = self.newSizeImage(size: defaultSize, sourceImage: sourceImage) finallImageData = UIImageJPEGRepresentation(newImage,1.0); //保存压缩系数 let compressionQualityArr = NSMutableArray() let avg = CGFloat(1.0/250) var value = avg var i = 250 repeat &#123; i -= 1 value = CGFloat(i)*avg compressionQualityArr.add(value) &#125; while i &gt;= 1 /* 调整大小 说明：压缩系数数组compressionQualityArr是从大到小存储。 */ //思路：使用二分法搜索 finallImageData = self.halfFuntion(arr: compressionQualityArr.copy() as! [CGFloat], image: newImage, sourceData: finallImageData!, maxSize: maxSize) //如果还是未能压缩到指定大小，则进行降分辨率 while finallImageData?.count == 0 &#123; //每次降100分辨率 let reduceWidth = 100.0 let reduceHeight = 100.0/sourceImageAspectRatio if (defaultSize.width-CGFloat(reduceWidth)) &lt;= 0 || (defaultSize.height-CGFloat(reduceHeight)) &lt;= 0 &#123; break &#125; defaultSize = CGSize(width: (defaultSize.width-CGFloat(reduceWidth)), height: (defaultSize.height-CGFloat(reduceHeight))) let image = self.newSizeImage(size: defaultSize, sourceImage: UIImage.init(data: UIImageJPEGRepresentation(newImage, compressionQualityArr.lastObject as! CGFloat)!)!) finallImageData = self.halfFuntion(arr: compressionQualityArr.copy() as! [CGFloat], image: image, sourceData: UIImageJPEGRepresentation(image,1.0)!, maxSize: maxSize) &#125; return finallImageData! as NSData &#125; // MARK: - 调整图片分辨率/尺寸（等比例缩放） func newSizeImage(size: CGSize, sourceImage: UIImage) -&gt; UIImage &#123; var newSize = CGSize(width: sourceImage.size.width, height: sourceImage.size.height) let tempHeight = newSize.height / size.height let tempWidth = newSize.width / size.width if tempWidth &gt; 1.0 &amp;&amp; tempWidth &gt; tempHeight &#123; newSize = CGSize(width: sourceImage.size.width / tempWidth, height: sourceImage.size.height / tempWidth) &#125; else if tempHeight &gt; 1.0 &amp;&amp; tempWidth &lt; tempHeight &#123; newSize = CGSize(width: sourceImage.size.width / tempHeight, height: sourceImage.size.height / tempHeight) &#125; UIGraphicsBeginImageContext(newSize) sourceImage.draw(in: CGRect(x: 0, y: 0, width: newSize.width, height: newSize.height)) let newImage = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return newImage! &#125; // MARK: - 二分法 func halfFuntion(arr: [CGFloat], image: UIImage, sourceData finallImageData: Data, maxSize: Int) -&gt; Data? &#123; var tempFinallImageData = finallImageData var tempData = Data.init() var start = 0 var end = arr.count - 1 var index = 0 var difference = Int.max while start &lt;= end &#123; index = start + (end - start)/2 tempFinallImageData = UIImageJPEGRepresentation(image, arr[index])! let sizeOrigin = tempFinallImageData.count let sizeOriginKB = sizeOrigin / 1024 print(\"当前降到的质量：\\(sizeOriginKB)\\n\\(index)----\\(arr[index])\") if sizeOriginKB &gt; maxSize &#123; start = index + 1 &#125; else if sizeOriginKB &lt; maxSize &#123; if maxSize-sizeOriginKB &lt; difference &#123; difference = maxSize-sizeOriginKB tempData = tempFinallImageData &#125; if index&lt;=0 &#123; break &#125; end = index - 1 &#125; else &#123; break &#125; &#125; return tempData &#125; 补充 OC 版本（推荐）基于网友的要求，我把 OC 版本的代码也贴出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104- (NSData *)resetSizeOfImageData:(UIImage *)source_image maxSize:(NSInteger)maxSize &#123; //先判断当前质量是否满足要求，不满足再进行压缩 __block NSData *finallImageData = UIImageJPEGRepresentation(sourceImage,1.0); NSUInteger sizeOrigin = finallImageData.length; NSUInteger sizeOriginKB = sizeOrigin / 1000; if (sizeOriginKB &lt;= maxSize) &#123; return finallImageData; &#125; //获取原图片宽高比 CGFloat sourceImageAspectRatio = sourceImage.size.width/sourceImage.size.height; //先调整分辨率 CGSize defaultSize = CGSizeMake(1024, 1024/sourceImageAspectRatio); UIImage *newImage = [self newSizeImage:defaultSize image:sourceImage]; finallImageData = UIImageJPEGRepresentation(newImage,1.0); //保存压缩系数 NSMutableArray *compressionQualityArr = [NSMutableArray array]; CGFloat avg = 1.0/250; CGFloat value = avg; for (int i = 250; i &gt;= 1; i--) &#123; value = i*avg; [compressionQualityArr addObject:@(value)]; &#125; /* 调整大小 说明：压缩系数数组compressionQualityArr是从大到小存储。 */ //思路：使用二分法搜索 finallImageData = [self halfFuntion:compressionQualityArr image:newImage sourceData:finallImageData maxSize:maxSize]; //如果还是未能压缩到指定大小，则进行降分辨率 while (finallImageData.length == 0) &#123; //每次降100分辨率 CGFloat reduceWidth = 100.0; CGFloat reduceHeight = 100.0/sourceImageAspectRatio; if (defaultSize.width-reduceWidth &lt;= 0 || defaultSize.height-reduceHeight &lt;= 0) &#123; break; &#125; defaultSize = CGSizeMake(defaultSize.width-reduceWidth, defaultSize.height-reduceHeight); UIImage *image = [self newSizeImage:defaultSize image:[UIImage imageWithData:UIImageJPEGRepresentation(newImage,[[compressionQualityArr lastObject] floatValue])]]; finallImageData = [self halfFuntion:compressionQualityArr image:image sourceData:UIImageJPEGRepresentation(image,1.0) maxSize:maxSize]; &#125; return finallImageData;&#125;#pragma mark 调整图片分辨率/尺寸（等比例缩放）- (UIImage *)newSizeImage:(CGSize)size image:(UIImage *)sourceImage &#123; CGSize newSize = CGSizeMake(sourceImage.size.width, sourceImage.size.height); CGFloat tempHeight = newSize.height / size.height; CGFloat tempWidth = newSize.width / size.width; if (tempWidth &gt; 1.0 &amp;&amp; tempWidth &gt; tempHeight) &#123; newSize = CGSizeMake(sourceImage.size.width / tempWidth, sourceImage.size.height / tempWidth); &#125; else if (tempHeight &gt; 1.0 &amp;&amp; tempWidth &lt; tempHeight) &#123; newSize = CGSizeMake(sourceImage.size.width / tempHeight, sourceImage.size.height / tempHeight); &#125; UIGraphicsBeginImageContext(newSize); [sourceImage drawInRect:CGRectMake(0,0,newSize.width,newSize.height)]; UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125;#pragma mark 二分法- (NSData *)halfFuntion:(NSArray *)arr image:(UIImage *)image sourceData:(NSData *)finallImageData maxSize:(NSInteger)maxSize &#123; NSData *tempData = [NSData data]; NSUInteger start = 0; NSUInteger end = arr.count - 1; NSUInteger index = 0; NSUInteger difference = NSIntegerMax; while(start &lt;= end) &#123; index = start + (end - start)/2; finallImageData = UIImageJPEGRepresentation(image,[arr[index] floatValue]); NSUInteger sizeOrigin = finallImageData.length; NSUInteger sizeOriginKB = sizeOrigin / 1024; NSLog(@\"当前降到的质量：%ld\", (unsigned long)sizeOriginKB); NSLog(@\"\\nstart：%zd\\nend：%zd\\nindex：%zd\\n压缩系数：%lf\", start, end, (unsigned long)index, [arr[index] floatValue]); if (sizeOriginKB &gt; maxSize) &#123; start = index + 1; &#125; else if (sizeOriginKB &lt; maxSize) &#123; if (maxSize-sizeOriginKB &lt; difference) &#123; difference = maxSize-sizeOriginKB; tempData = finallImageData; &#125; if (index&lt;=0) &#123; break; &#125; end = index - 1; &#125; else &#123; break; &#125; &#125; return tempData;&#125; 【更新日志】2017年10月09日：修复了网友提出的二分法存在index为0时闪退问题。 2018年05月25日：将原本默认设置图片尺寸为1024*1024改成等比放大，同时降低分辨力也改成等比降低。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"superdanny.link/tags/Swift/"},{"name":"图片上传","slug":"图片上传","permalink":"superdanny.link/tags/图片上传/"}]},{"title":"iOS获取设备IP地址","date":"2016-01-27T06:30:00.000Z","path":"2016/01/27/iOS-get-device-ip-address/","text":"以前做过获取设备IP地址的功能，但是由于当时代码管理不当，很多代码已经遗失，现在只能重新过一遍，也让自己更有基情激情的学习。网上关于这方面的文章很多，但是找到自己真正需要的却不容易，经过几番周折。终于在著名的stackoverflow上面找到了我想要的答案。 代码如下：(最新代码，请往下翻) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#import &lt;ifaddrs.h&gt;#import &lt;arpa/inet.h&gt;#import &lt;net/if.h&gt;#define IOS_CELLULAR @\"pdp_ip0\"#define IOS_WIFI @\"en0\"#define IOS_VPN @\"utun0\"#define IP_ADDR_IPv4 @\"ipv4\"#define IP_ADDR_IPv6 @\"ipv6\"#pragma mark - 获取设备当前本地IP地址+ (NSString *)getIPAddress:(BOOL)preferIPv4&#123; NSArray *searchArray = preferIPv4 ? @[ IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6 ] : @[ IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4 ] ; NSDictionary *addresses = [self getIPAddresses]; NSLog(@\"addresses: %@\", addresses); __block NSString *address; [searchArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop) &#123; address = addresses[key]; //筛选出IP地址格式 if([self isValidatIP:address]) *stop = YES; &#125; ]; return address ? address : @\"0.0.0.0\";&#125;+ (BOOL)isValidatIP:(NSString *)ipAddress &#123; if (ipAddress.length == 0) &#123; return NO; &#125; NSString *urlRegEx = @\"^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\" \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\" \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\" \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\"; NSError *error; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:urlRegEx options:0 error:&amp;error]; if (regex != nil) &#123; NSTextCheckingResult *firstMatch=[regex firstMatchInString:ipAddress options:0 range:NSMakeRange(0, [ipAddress length])]; if (firstMatch) &#123; NSRange resultRange = [firstMatch rangeAtIndex:0]; NSString *result=[ipAddress substringWithRange:resultRange]; //输出结果 NSLog(@\"%@\",result); return YES; &#125; &#125; return NO;&#125;+ (NSDictionary *)getIPAddresses&#123; NSMutableDictionary *addresses = [NSMutableDictionary dictionaryWithCapacity:8]; // retrieve the current interfaces - returns 0 on success struct ifaddrs *interfaces; if(!getifaddrs(&amp;interfaces)) &#123; // Loop through linked list of interfaces struct ifaddrs *interface; for(interface=interfaces; interface; interface=interface-&gt;ifa_next) &#123; if(!(interface-&gt;ifa_flags &amp; IFF_UP) /* || (interface-&gt;ifa_flags &amp; IFF_LOOPBACK) */ ) &#123; continue; // deeply nested code harder to read &#125; const struct sockaddr_in *addr = (const struct sockaddr_in*)interface-&gt;ifa_addr; char addrBuf[ MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN) ]; if(addr &amp;&amp; (addr-&gt;sin_family==AF_INET || addr-&gt;sin_family==AF_INET6)) &#123; NSString *name = [NSString stringWithUTF8String:interface-&gt;ifa_name]; NSString *type; if(addr-&gt;sin_family == AF_INET) &#123; if(inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, addrBuf, INET_ADDRSTRLEN)) &#123; type = IP_ADDR_IPv4; &#125; &#125; else &#123; const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)interface-&gt;ifa_addr; if(inet_ntop(AF_INET6, &amp;addr6-&gt;sin6_addr, addrBuf, INET6_ADDRSTRLEN)) &#123; type = IP_ADDR_IPv6; &#125; &#125; if(type) &#123; NSString *key = [NSString stringWithFormat:@\"%@/%@\", name, type]; addresses[key] = [NSString stringWithUTF8String:addrBuf]; &#125; &#125; &#125; // Free memory freeifaddrs(interfaces); &#125; return [addresses count] ? addresses : nil;&#125; 2017年01月11日 很多朋友说这个方法只能获取到内网IP，无法获取公网IP，确实，这边补充下获取公网IP方式。(由于访问网络缓慢，最新做法请往下翻) 1234567891011121314//方法一：NSError *error; NSURL *ipURL = [NSURL URLWithString:@\"http://ifconfig.me/ip\"];NSString *ip = [NSString stringWithContentsOfURL:ipURL encoding:NSUTF8StringEncoding error:&amp;error];//方法二：个人推荐用这个请求，速度比较快/*http://ipof.in/jsonhttp://ipof.in/xmlhttp://ipof.in/txtIf you want HTTPS you can use the same URLs with https prefix. The advantage being that even if you are on a Wifi you will get the public address. */NSError *error; NSURL *ipURL = [NSURL URLWithString:@\"http://ipof.in/txt\"];NSString *ip = [NSString stringWithContentsOfURL:ipURL encoding:NSUTF8StringEncoding error:&amp;error]; 2017年08月04日 增加部分公开API 1、淘宝API 12345678910111213141516171819202122232425261. 请求接口（GET）：查询某ip信息：http://ip.taobao.com/service/getIpInfo.php?ip=ip地址查询自己的ip信息：http://ip.taobao.com/service/getIpInfo.php?ip=myip2. 响应信息：（json格式的）国家 、省（自治区或直辖市）、市（县）、运营商3. 返回数据格式：&#123; &quot;code&quot;: 0, &quot;data&quot;: &#123; &quot;country&quot;: &quot;中国&quot;, &quot;country_id&quot;: &quot;CN&quot;, &quot;area&quot;: &quot;华南&quot;, &quot;area_id&quot;: &quot;800000&quot;, &quot;region&quot;: &quot;广东省&quot;, &quot;region_id&quot;: &quot;440000&quot;, &quot;city&quot;: &quot;深圳市&quot;, &quot;city_id&quot;: &quot;440300&quot;, &quot;county&quot;: &quot;&quot;, &quot;county_id&quot;: &quot;-1&quot;, &quot;isp&quot;: &quot;电信&quot;, &quot;isp_id&quot;: &quot;100017&quot;, &quot;ip&quot;: &quot;121.35.211.41&quot; &#125;&#125;其中code的值的含义为，0：成功，1：失败。4. 访问限制：为了保障服务正常运行，每个用户的访问频率需小于10qps。 参数名 含义 code 状态码，正常为0，异常的时候为非0。 data 查询到的结果。 country 国家。 country_id 国家代码。 area 地区名称（华南、华北…）。 area_id 地区编号。 region 省名称。 region_id 省编号。 city 市名称。 city_id 市编号。 county 县名称。 county_id 县编号。 isp ISP服务商名称（电信/联通/铁通/移动…）。 isp_id ISP服务商编号。 ip 查询的IP地址。 2、站长工具API 123http://ip.chinaz.com/getip.aspx返回数据格式：&#123;ip:&apos;121.35.211.41&apos;,address:&apos;广东省深圳市 电信&apos;&#125; 2017年11月17日 今天将上面的资料整一块整理下，由于获取ip地址的需求有很多，有的需要内网ip，有的需要外网ip，这里全部整理一下。之前上面使用的获取外网ip的方式请求缓慢，这边替换成最新的方式。也比较适合国内用户。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#import &lt;ifaddrs.h&gt;#import &lt;arpa/inet.h&gt;#import &lt;net/if.h&gt;#define IOS_CELLULAR @\"pdp_ip0\"#define IOS_WIFI @\"en0\"#define IOS_VPN @\"utun0\"#define IP_ADDR_IPv4 @\"ipv4\"#define IP_ADDR_IPv6 @\"ipv6\"#pragma mark - 获取设备当前网络IP地址+ (NSString *)getNetworkIPAddress &#123; //方式一：淘宝api NSURL *ipURL = [NSURL URLWithString:@\"http://ip.taobao.com/service/getIpInfo.php?ip=myip\"]; NSData *data = [NSData dataWithContentsOfURL:ipURL]; NSDictionary *ipDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSString *ipStr = nil; if (ipDic &amp;&amp; [ipDic[@\"code\"] integerValue] == 0) &#123; //获取成功 ipStr = ipDic[@\"data\"][@\"ip\"]; &#125; return (ipStr ? ipStr : @\"0.0.0.0\"); //方式二：新浪api NSError *error; NSURL *ipURL = [NSURL URLWithString:@\"http://pv.sohu.com/cityjson?ie=utf-8\"]; NSMutableString *ip = [NSMutableString stringWithContentsOfURL:ipURL encoding:NSUTF8StringEncoding error:&amp;error]; //判断返回字符串是否为所需数据 if ([ip hasPrefix:@\"var returnCitySN = \"]) &#123; //对字符串进行处理，然后进行json解析 //删除字符串多余字符串 NSRange range = NSMakeRange(0, 19); [ip deleteCharactersInRange:range]; NSString * nowIp =[ip substringToIndex:ip.length-1]; //将字符串转换成二进制进行Json解析 NSData * data = [nowIp dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary * dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSLog(@\"%@\",dict); return dict[@\"cip\"] ? dict[@\"cip\"] : @\"0.0.0.0\"; &#125; return @\"0.0.0.0\"; &#125;#pragma mark - 获取设备当前本地IP地址+ (NSString *)getLocalIPAddress:(BOOL)preferIPv4 &#123; NSArray *searchArray = preferIPv4 ? @[ IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6 ] : @[ IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4 ] ; NSDictionary *addresses = [self getIPAddresses]; NSLog(@\"addresses: %@\", addresses); __block NSString *address; [searchArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop) &#123; address = addresses[key]; //筛选出IP地址格式 if([self isValidatIP:address]) *stop = YES; &#125; ]; return address ? address : @\"0.0.0.0\";&#125;+ (BOOL)isValidatIP:(NSString *)ipAddress &#123; if (ipAddress.length == 0) &#123; return NO; &#125; NSString *urlRegEx = @\"^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\" \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\" \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\" \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\"; NSError *error; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:urlRegEx options:0 error:&amp;error]; if (regex != nil) &#123; NSTextCheckingResult *firstMatch=[regex firstMatchInString:ipAddress options:0 range:NSMakeRange(0, [ipAddress length])]; if (firstMatch) &#123; NSRange resultRange = [firstMatch rangeAtIndex:0]; NSString *result=[ipAddress substringWithRange:resultRange]; //输出结果 NSLog(@\"%@\",result); return YES; &#125; &#125; return NO;&#125;+ (NSDictionary *)getIPAddresses &#123; NSMutableDictionary *addresses = [NSMutableDictionary dictionaryWithCapacity:8]; // retrieve the current interfaces - returns 0 on success struct ifaddrs *interfaces; if(!getifaddrs(&amp;interfaces)) &#123; // Loop through linked list of interfaces struct ifaddrs *interface; for(interface=interfaces; interface; interface=interface-&gt;ifa_next) &#123; if(!(interface-&gt;ifa_flags &amp; IFF_UP) /* || (interface-&gt;ifa_flags &amp; IFF_LOOPBACK) */ ) &#123; continue; // deeply nested code harder to read &#125; const struct sockaddr_in *addr = (const struct sockaddr_in*)interface-&gt;ifa_addr; char addrBuf[ MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN) ]; if(addr &amp;&amp; (addr-&gt;sin_family==AF_INET || addr-&gt;sin_family==AF_INET6)) &#123; NSString *name = [NSString stringWithUTF8String:interface-&gt;ifa_name]; NSString *type; if(addr-&gt;sin_family == AF_INET) &#123; if(inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, addrBuf, INET_ADDRSTRLEN)) &#123; type = IP_ADDR_IPv4; &#125; &#125; else &#123; const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)interface-&gt;ifa_addr; if(inet_ntop(AF_INET6, &amp;addr6-&gt;sin6_addr, addrBuf, INET6_ADDRSTRLEN)) &#123; type = IP_ADDR_IPv6; &#125; &#125; if(type) &#123; NSString *key = [NSString stringWithFormat:@\"%@/%@\", name, type]; addresses[key] = [NSString stringWithUTF8String:addrBuf]; &#125; &#125; &#125; // Free memory freeifaddrs(interfaces); &#125; return [addresses count] ? addresses : nil;&#125; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"获取IP","slug":"获取IP","permalink":"superdanny.link/tags/获取IP/"}]},{"title":"如何从项目中移除CocoaPods(译)","date":"2016-01-18T09:44:00.000Z","path":"2016/01/18/Remove-CocoaPods-from-project/","text":"原文地址：How to remove CocoaPods from a project? 使用CocoaPod管理第三方代码是非常方便的，但是当不需要使用的时候，删除起来就非常麻烦，这里我根据国外朋友的方案翻译了一下。不足之处望见谅。 操作步骤 删除本地文件(Podfile、Podfile.lock、Pods文件夹) 删除本地生成的xcworkspace文件 打开项目，在Frameworks文件夹下，删除Pods.xcconfig和libPods.a 进入项目Build Phases，删除Copy Pods Resources、Embed Pods Frameworks和Check Pods Manifest.lock 三项。 因为删除了CocoaPod管理的第三方代码，所以在工程里面之前引用的第三方代码都会报错。这时候需要删除对应的代码。 通过第三方插件删除我们可以通过CocoaPod的核心团队成员开源的插件cocoapods-dependencies进行操作。这样能保证删除操作根据CocoaPod的更新而保持最新的。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"superdanny.link/tags/CocoaPods/"}]},{"title":"OS X El Capitan系统下使用brew报错问题","date":"2016-01-18T08:36:00.000Z","path":"2016/01/18/Brew-OSX_EI-error/","text":"今天想使用brew下载个工具，发现无端端报错了，不能正常使用。顿时心血来潮——又有博客写了😄 因为从10.11开始，对几个重要目录的权限苹果有了新的限制，特别是/usr目录，所以官方有一个解决方法：El_Capitan_and_Homebrew 这里我按照我的思路来解决这个问题！ 报错如下内容 12345678Error: The /usr/local directory is not writable.Even if this directory was writable when you installed Homebrew, othersoftware may change permissions on this directory. Some versions of the&quot;InstantOn&quot; component of Airfoil are known to do this.You should probably change the ownership and permissions of /usr/localback to your user account. sudo chown -R $(whoami):admin /usr/local 根据错误提示，我们只需要执行提示中最后一句指令sudo chown -R $(whoami):admin /usr/local 执行完指令之后，我们再使用brew doctor指令检测一下，按照提示操作就行。当然有些提示我们是可以忽略的。比如： 123456789Warning: Suspicious git origin remote found.With a non-standard origin, Homebrew won&apos;t pull updates fromthe main repository. The current git origin is: https://git.coding.net/homebrew/homebrew.gitUnless you have compelling reasons, consider setting theorigin remote to point at the main repository, located at: https://github.com/Homebrew/homebrew.git 这里提示我有可疑的brew源地址，但是其实这个源地址是安全的，因为是我自己设置的。所以我忽略了这个警告。 另外一个警告是这样子的： 12345Warning: You have unlinked kegs in your CellarLeaving kegs unlinked can lead to build-trouble and cause brews that depend onthose kegs to fail to run properly once built. Run `brew link` on these: carthage python 道理一样，我们按照提示执行指令brew link python 解决完提示的问题之后就可以正常使用啦！ 如果什么都不行的话，试下执行xcode-select --install 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"superdanny.link/tags/Homebrew/"},{"name":"brew","slug":"brew","permalink":"superdanny.link/tags/brew/"}]},{"title":"iTunes Connect(二) —— 应用上架过程中App状态指南","date":"2016-01-15T03:56:00.000Z","path":"2016/01/15/iOS-iTunes_Connect_2-App-Statuses/","text":"关于 app 状态无论 app 版本列于 iTunes Connect 中的哪个位置，您都可以看到版本的状态（如Waiting For Upload（正在等待上传）或Ready for Sale（可以销售））或状态指示器（如 ， 或 ）。状态会立即告知您是否需要关注您的 app： 红色状态指示器表示您需要先执行某个操作，然后您的 app 才能在商店中提供。 黄色状态指示器表示正在进行某个进程（由您或 Apple 控制）。 绿色状态指示器表示 app 已在商店中提供。 状态 状态名称 说明 Prepare for Submission(准备上传) 已为 app 创建了 iTunes Connect 记录，但是未准备好上传二进制文件。您可能仍要配置元数据、屏幕快照、价格、In-App Purchase、Game Center、iAd App Network 设置等等。 Waiting For Review(正在等待审核) 您已提交新的 app 或更新后的版本，而且 Apple 已收到，但是尚未开始审核该 app。在 app 正在等待审核时，您可以：1、拒绝您的二进制文件，以将其从 Apple 审核队列中移除。请参阅 拒绝您的二进制文件。2、编辑某些 app 信息。 In Review(审核中) Apple 正在审核您的 app。由于提交的每个 app 都不相同，因此没有固定的审核时间。您可以通过拒绝二进制文件将您的二进制文件从审核队列中移除。请参阅 拒绝您的二进制文件。 Pending Contract(合同挂起) 您的 app 已通过审核，并可以销售，但是您的合同尚未生效。在“Contracts, Tax &amp; Banking”（合同、税务和银行）模块中检查合同进度。请参阅 查看合同和合同状态。 Waiting For Export Compliance(等待出口合规) 您的 app 已通过审核，并可以销售，但正在审核您的 CCATS 文件的出口合规。 Pending Developer Release(等待开发者发布) 您的 app 版本已获得 Apple 批准，正在等待您进行发布。您可以选择手动控制发布或将发布日期定于将来的某个日期。当一切准备就绪时，将 app 版本发布到商店。请参阅 指定应用程序版本发布时间。 Processing for App Store(正在针对 App Store 进行处理) 正在处理您的二进制文件，并且可在 24 小时内准备销售。 Pending Apple Release(等待 Apple 发布) Apple 保留您的 app 版本，直到相应的 Apple iOS 或 OS 版本公开发布。如果您认为 app 应在现有的 iOS 或 OS 版本上进行发布，则检查在您的 app 二进制文件中设置的部署目标。如果您使用不同的部署目标重建 app 二进制文件，则拒绝此版本的二进制文件，并提交新的版本。 Ready for Sale(可以销售) Apple 已经批准该 app 版本，并将其发布到商店。在此状态下可进行的更改是：1、从商店中移除 app。请参阅 在商店中取消 app 销售的步骤。2、使用新版本更新 app。请参阅 将您的 app 替换为新版本。 Rejected(已拒绝) Apple 拒绝了二进制文件。具有管理员或技术人员角色的 iTunes Connect 用户会收到包含拒绝原因的通知。请参阅 使用解决方案中心。 Metadata Rejected(已拒绝元数据) 元数据项目（除您的二进制文件外）未通过审核。请参阅 使用解决方案中心。要解决该问题，请编辑 iTunes Connect 中的元数据。当你解决这个问题,再次提交审查的程序。 Removed From Sale(已取消销售) 您的 app 已从商店中移除。如果您的 app 存在从商店中移除的风险，则 Apple 会与您联系，以尽量在移除您的 app 前解决相关问题。 Developer Rejected(开发者已拒绝) 您已拒绝审核流程中的二进制文件，并将其从审核队列中移除。当您准备就绪时，重新提交您的二进制文件或提交新的二进制文件。请参阅 拒绝您的二进制文件。 Developer Removed From Sale(开发者已取消销售) 您已从商店中移除 app。请参阅 重新销售 app 的步骤。 Invalid Binary(无效的二进制文件) Apple 拒绝了您的二进制文件，因为它没有满足所有上传要求。解决二进制文件中的所有问题后，在 构建版本 模块中删除不符合的二进制文件，选择一个新的文件，然后保存提交审核。 查看状态历史 进入iTunes Connect 选择某一个app进入详情界面 依次选择App Store Versions(App Store版本) — Activity(活动) 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"上架","slug":"上架","permalink":"superdanny.link/tags/上架/"},{"name":"AppStore","slug":"AppStore","permalink":"superdanny.link/tags/AppStore/"},{"name":"iTunes Connect","slug":"iTunes-Connect","permalink":"superdanny.link/tags/iTunes-Connect/"}]},{"title":"iTunes Connect(一) —— iOS应用上架到AppStore","date":"2016-01-13T11:13:00.000Z","path":"2016/01/13/iOS-iTunes_Connect_1-Uploading-APP-to-Appstore/","text":"前言 基于本人对苹果的开发流程的渴望。所以很多东西一旦自己经历了，或者是别人经常会用到的时候，我就喜欢研究。并将自己以及别人的心得记录下来，方便自己及他人学习。 本篇，我将按照自己的思路对iOS应用上架整体流程进行讲解，本文也是iOS证书申请、开发、打包、排查等系列教学中的一部分，欢迎各位朋友扩展学习。 博文回顾在前面我完善了我的iOS开发者证书的那些事文章，开篇就讲到了关于发布时的必备条件，在这里我就不再累赘。直接进入本文主题。 上架前准备工作👉我们需要事先完成这几个步骤，确保接下来的工作能够顺利进行。Boss才会对我们的工作表示认可👈 1、注册App ID(应用ID)App ID是识别不同应用程序的唯一标示符。每个App都需要一个App ID或者App标识。目前有两种类型的App标识：一个是精确的App ID(explicit App ID)，一个是通配符App ID(wildcard App ID)。 使用通配符的App ID可以用来构建和安装多个程序。尽管通配符App ID非常方便，但是一个精确的App ID也是需要的，尤其是当App使用iCloud或者使用其他iOS功能的时候，比如Game Center、Push Notifications或者IAP。关于如何创建App ID，苹果官方有相关的文档说明👉注册App IDs 2、创建Distribution Certificate(发布证书)发布证书，也是根证书。它是所有应用发布的基础，当你创建过一次根证书之后，就不需再创建。创建的过程我以前的文章有提及过开发证书的创建，发布证书的创建过程类似。👉iOS开发者证书的那些事 3、创建商店Provisioning Profile(商店描述文件)和开发期间使用的开发描述文件类似，我们 App 上架到 AppStore 的时候也需要创建一个对应的描述文件，不过有一点不同的是，该类型的描述文件不需要选择任何设备就能创建。创建过程也非常简单，可参考开发描述文件的创建过程。 4、Build Settings(生成设置)我们需要在工程中进行相应的配置，才能提交到 AppStore。对Code Signing中的Code Signing Identity和Provisioning Profile两项进行配置。 5、Deployment Target(部署目标)非常有必要说下deployment target，Xcode中每个target都有一个deployment target，它指出app可以运行的最低操作系统。不过，一旦应用在App Store中生效，再去修改deployment target，你要考虑到一定后果。如果你在更新app的时候提高了deployment target，但是已经购买应用的用户并没有遇到新的deployment target，那么应用就不能在用户的移动设备上运行。如果用户通过iTunes(不是设备)下载了一个更新过的app，然后替代了设备上原先的版本，最后却发现新版本不能在设备上运行，这确实是个问题。 对此有两个方法： 当你决定提高现有app的deployment target时，要在新版本的版本注释中进行说明。如果你提前告知用户，那么至少有一点，你已经尽力阻止问题的发生了。 对于一款新app，我经常会把deployment target设置为最近发布的系统版本。因为新iOS版本发布后，渗透率的增长速度是令人难以置信的。很多人认为提高deployment target会失去大部分市场，这个说法并不准确，比如iOS 6，iOS 6发布后一个月，超过60%的设备已经进行了更新。但对Android而言，就是另外一回事了，Android用户并不会像iOS用户那样热衷于更新操作系统版本。 iTunes Connect 在提交App之前，我们需要进入到iTunes Connect里面创建我们的App记录。 然后点击界面左上角的+号，选择新建App 填写应用相关信息-Metadata(元数据) 其中SKU Number是一个唯一标识你的app的特殊字符串。应用发布之后就不能修改，可以使用app的Bundle ID。 之后的操作就不用介绍了，因为都是一些基本的信息设置。你只需要按提示一步一步完成设置即可。添加成功之后，应用的状态会显示Prepare for Upload(准备提交)。 接下来，在构建版本栏目下，我们看到苹果提示我们使用Xcode或者Application Loader提交我们的构建版本。此时我们就可以进行上传二进制文件了。上传之后在该栏目下就会有我们上传的二进制文件供选择，选择对应的文件之后就可以点击右上角的提交以供审核按钮，此时应用的状态会变成Waiting For Review(等待审核) 上传二进制文件苹果提供两种方式进行提交，一种是直接通过Xcode打包提交，另一种是通过Xcode自带工具Application Loader进行提交。我比较喜欢第二种，因为可以看到上传进度。更加人性化。关于上传方式，我这边不做展开，提供给大家一个学习资料。有任何疑问欢迎留言提出😊 方式一：使用 Xcode 上传我在iOS开发企业版ipa分发(In-House模式)记录一文中有讲到使用Xcode打包步骤，不过里面的少许步骤不一样而已。这里就不做详细说明。如果有什么不懂可以参阅👉上传你的App。 方式二：使用 Application Loader 上传有关详细信息，请参阅👉Using Application Loader。 知识扩展1、我们在进行版本更新的时候，App图标、名字、描述、新版本描述、关键词、支持URL、截图、联系方式、Review Notes(审核备注)均可以更改 2、Review Notes(审核备注)中，包括如下信息： 名字、姓氏、电子邮件地址、电话号码(都是必需) 在 app 审核团队有任何疑问或需要了解其他信息时应联系的您组织中人员的联系人信息。 审核注释(可选) 有助于审核团队实施审核过程的 app 其他信息。添加测试 app 可能需要的信息，如 app 专用设置、测试注册或帐户详细信息。“Review Notes”（审核备注）字段的大小上限为 4000 字节，并可本地化为任何语言版本。如果您的 app 通过蜂窝数据网络传输流媒体视频，则在“Review Notes”（审核备注）中输入测试视频流 URL。此文本仅对 Apple 审核团队可见。 用户名(可选) 拥有完整访问权限的演示帐户的用户名。此帐户在 app 审核过程中使用，不能是过期帐户。应在“Review Notes”（审核备注）字段中添加其他帐户的详细信息。 密码(可选) 拥有完整访问权限的演示帐户的密码。 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"上架","slug":"上架","permalink":"superdanny.link/tags/上架/"},{"name":"AppStore","slug":"AppStore","permalink":"superdanny.link/tags/AppStore/"},{"name":"iTunes Connect","slug":"iTunes-Connect","permalink":"superdanny.link/tags/iTunes-Connect/"}]},{"title":"UIWebView顶部添加自定义视图","date":"2016-01-12T06:39:00.000Z","path":"2016/01/12/iOS-UIWebView-add-customView/","text":"今天碰到一个需求，需要往UIWebView顶部添加一个视图。在这里我找到了一个解决方案，目前可以满足我的需求。如果哪位朋友有更好，更优的解决方案，还请不吝赐教。 核心代码如下: 1234567891011121314151617181920private func addHeaderView(headerView: UIView) &#123; let browserCanvas = webView!.bounds for subView in webView!.scrollView.subviews &#123; var subViewRect = subView.frame if(subViewRect.origin.x == browserCanvas.origin.x &amp;&amp; subViewRect.origin.y == browserCanvas.origin.y &amp;&amp; subViewRect.size.width == browserCanvas.size.width &amp;&amp; subViewRect.size.height == browserCanvas.size.height) &#123; let height = headerView.frame.size.height subViewRect.origin.y = height subViewRect.size.height = height subView.frame = subViewRect &#125; &#125; webView!.scrollView.addSubview(headerView) webView!.scrollView.bringSubviewToFront(headerView) &#125; 完整代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class ViewController: UIViewController, UIWebViewDelegate &#123; var webView: UIWebView? override func viewDidLoad() &#123; super.viewDidLoad() self.view.backgroundColor = UIColor.whiteColor() let rect = CGRect(x: 0, y: 64, width: CGRectGetWidth(self.view.frame), height: CGRectGetHeight(self.view.frame)-64) webView = UIWebView(frame: rect)// webView!.scalesPageToFit = true webView!.delegate = self let fileURL = NSBundle.mainBundle().URLForResource(\"index\", withExtension: \"html\") let request = NSURLRequest(URL: fileURL!) webView!.loadRequest(request) &#125; private func createHeaderView() -&gt; UIView &#123; let view = UILabel(frame: CGRect(x: 0, y: 0, width: CGRectGetWidth(self.view.frame), height: 50)) view.text = \"这是头部视图\" view.backgroundColor = UIColor.orangeColor() return view &#125; private func addHeaderView(headerView: UIView) &#123; let browserCanvas = webView!.bounds for subView in webView!.scrollView.subviews &#123; var subViewRect = subView.frame if(subViewRect.origin.x == browserCanvas.origin.x &amp;&amp; subViewRect.origin.y == browserCanvas.origin.y &amp;&amp; subViewRect.size.width == browserCanvas.size.width &amp;&amp; subViewRect.size.height == browserCanvas.size.height) &#123; let height = headerView.frame.size.height subViewRect.origin.y = height subViewRect.size.height = height subView.frame = subViewRect &#125; &#125; webView!.scrollView.addSubview(headerView) webView!.scrollView.bringSubviewToFront(headerView) &#125; //MARK: UIWebViewDelegate func webView(webView: UIWebView, shouldStartLoadWithRequest request: NSURLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool &#123; return true &#125; func webViewDidStartLoad(webView: UIWebView) &#123; print(\"webViewDidStartLoad\") &#125; func webViewDidFinishLoad(webView: UIWebView) &#123; print(\"webViewDidFinishLoad\") //添加头部视图 self.addHeaderView(self.createHeaderView()) self.view.addSubview(webView) &#125; func webView(webView: UIWebView, didFailLoadWithError error: NSError?) &#123; print(\"didFailLoadWithError\") &#125; // MARK: override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"Xcode Snippet（代码块）（转）","date":"2015-12-31T07:25:00.000Z","path":"2015/12/31/iOS-xcode-snippet/","text":"参考原文地址：Xcode Snippets 前言身为一只开发人猿，在经过漫长的编程历程之后，应该在开发效率上面要提升很多才对得起这么多年的艰苦岁月。所以有必要说说在开发中提升开发效率的方法。今天就讲讲Xcode里面的代码块。其实苹果官方已经帮我们封装了不少代码块，只是我们在开发过程中没有留意而已。下面将一些基本的用法以及使用方法跟大家分享一下。 使用 Xcode 代码块打开编辑器右侧的工具面板，就能看到所有可用的代码块。在工具面板的下方，有 4 个水平分布的小图标。点击{ }图标可以查看代码块仓库。 有两种方法将一个代码块插入你的代码： 你可以从代码块仓库拖到你的编辑器里面 亦或那些有快捷输入码的代码块 为了让你能够对代码块的用途有个较直观的印象，下面是 Xcode 内置代码块的概览： C enum，struct union，和 blocks 的 typedef 声明 C 控制流语句像 if，if…else，和 switch C 循环，像 for，while，和 do…while C 内联 block 变量声明 Objective-C @interface 声明（包括类扩展和分类），@implementation，@protocol Objective-C KVO 样板，包括相对模糊的 keyPathsForValuesAffecting，用来 注册相关的键 Objective-C Core Data 访问，属性存取，属性验证样板。 Objective-C 枚举 NSIndexSet 惯用语 Objective-C init，initWithCoder: 和 initWithFrame: 实现方法 Objective-C @try / @catch / @finally 和 @autorelease blocks GCD dispatch_once 和 dispatch_after 惯用语 创建 Xcode 代码块当然，代码块功能之所以强大，是因为你可以创建自定义的代码块。创建代码块的过程不是非常直观，很难用文字去描述。它使用了 OS X 系统中一个比较隐晦的功能，让用户拖拽选中文本生成“剪切文本”。看下实际操作就很好理解： 用户将自定义的代码块添加到库里面后，可以双击列表中的块去编辑。 每个块都有以下内容： Title 标题 - 块的名字（出现在代码补全和代码块库列表中） Summary 简介 - 简单描述下它是干嘛的（只出现在代码块库列表中） Platform 平台 - 限制可访问该代码块的平台。OS X，iOS，或者（“全部”） Language 语言 - 限制可访问该代码块的语言。常见的有 C，Objective-C，C++，或 Objective-C++ Completion Shortcut 输入码 - 快捷输入码。常用块的输入码应该非常简练。Xcode 不会警告冲突 / 重复的输入码，所以一定要确保新添加的不要和已有的冲突。 Completion Scopes 有效范围 - 限制可访问该代码块的范围。if / else 语句的自动补全应该只在方法或者函数的实现中有效。下面这些选项可以任意组合： All 全部 Class Implementation 类实现 Class Interface Methods 类接口方法 Class Interface Variables 类接口变量 Code Expression 代码表达式 Function or Method 函数或方法 Preprocessor Directive 预处理指令 String or Comment 字符串或注释 Top Level 最高层 ~/Library/Developer/Xcode/UserData/CodeSnippets/目录存放了所有 Xcode 代码段的文件表示 占位符在你使用其他代码块时你可能已经注意到了这些占位符： 在 Xcode 中，占位符使用 &lt;# 和 #&gt; 来分隔，中间是占位文本。赶紧打开 Xcode 试试吧，看看井号中间的文本是怎样魔法般的转换到你眼前的。 赶紧使用占位符给你的代码块添加一点动态效果吧！ 第三方 Xcode 代码块你可以在 这个 GitHub 项目 找到一些好用的代码块（欢迎提交 PR！）。就算这里没你想要的，它至少提供了一些例子来展示代码块能够做些什么。 编程并不是让大家都变成专业打字员，所以应该怎么简单就怎么来。只要你意识到你正在写一些无聊透顶，死记硬背的代码，那就赶紧抽点时间弄个代码块吧！ 👉前方高能本人在博主的项目基础上面增加了自己的一些代码块，并增加了另外一个开发的Swift代码块，有效的提升开发效率。欢迎朋友一同完善。(^__^) 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny 2015 年 12月 31日","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"superdanny.link/tags/Swift/"},{"name":"代码块","slug":"代码块","permalink":"superdanny.link/tags/代码块/"}]},{"title":"2015，我的年终总结","date":"2015-12-30T03:36:00.000Z","path":"2015/12/30/2015-Year-end-summary/","text":"岁月是把杀🐵刀，把我从一个 小鲜肉 熏陶成一个 老腊肉 年终总结，对于我来说是第一次写。因为我今年才刚毕业，很多事情在学校那会都没有养成这种习惯。出于对个人能力的提高，我觉得写总结非常有必要。不是说为了装装逼，而是通过写总结，不仅有助于自己表达能力以及写作能力的提升，而且可以让更多的朋友看到、了解到一个真实的我。 辞旧迎新2015年，这是不平凡的一年。我刚毕业，通过我大学期间的刻苦努力，我找到了我的第二份工作。为什么说是第二份呢？因为我的第一份工作是在我读大学期间找到的。在那家公司，我的工作内容是帮公司管理技术团队并时刻准备项目的交接。因为公司是刚创立，很多东西都不完善，但是办公环境我是无话可说，布置的挺温馨的。 那段时间的工作涉及技术领域的颇少，大部分时间是了解新知识。对于刚毕业的我来说，我迷失了原本的航向。所以我毅然决然选择了辞职，离开了同我一起工作生活过的伙伴们。 离开了那家公司之后，我找到了第二家公司。 艰苦历练在这一家公司期间，开始了我为期一年的历练。我学到了不少在学校学不到的新东西，新知识。因为公司给我提供了一个平台以及资源，让我有了学习热情。 这也奠定了我的技术基础，在大学期间自学的知识得到了整合。于是我开始了我的博客生涯，将我自己所了解以及遇到过的问题发布出来。让更多的人能够避开这些坑。 成绩： 建立了属于自己的博客平台，为开发者们提供学习 学习到了不少新知识，同时自学能力又能进一步的提高 开始尝试开源 得与失在毕业出来的这一年里，我学了不少新知识，也巩固了我的旧知识，并且有了新的认识。众所周知，一旦在某个领域上面又有所造诣，那么你肯定会有更多学习的热情与动力。我就是这样，一旦对知识有了更深的了解时，我会非常激动。因为这不仅仅是一种自豪感，也是自己技术能力的提升表现。这也是推动我一直学习的源泉。 同时，由于本人 是一个话唠 性格比较随和，去到哪里都跟大家聊得很来。小至20出头，大至40多岁，我都能够聊得来。 但是，事物都是有两面性，有好也有坏。在我尝尽了甜头的时候，我意识到一个致命的问题，由于我太多执着于技术与工作。当我清醒过来的时候，我才发现我忽略了我以前的朋友。这是我一个缺点之一，在我写下这篇总结的时候，我一定要努力改掉这个毛病。因为，不管你的技术再牛逼，亦或者你成就有多高，如果身边连一个朋友都没有的话，那是一件很失败的事情。 总结昨天已成为历史，明天还是个未知数。把今天的做好，让自己无憾这才是现在该做的。 学好技术，懂得分享，乐观面对，快乐生活 莫忘旧友，懂得感恩 事业虽重，朋友家人亦更深","tags":[{"name":"年终总结","slug":"年终总结","permalink":"superdanny.link/tags/年终总结/"}]},{"title":"UIDocumentInteractionController之程序间文档共享","date":"2015-12-26T03:43:00.000Z","path":"2015/12/26/iOS-UIDocumentInteractionController/","text":"iOS中的沙盒可以让平台更加的安全，这也是沙盒给用户带来的最主要好处。不过由于沙盒的严格限制，导致程序之间共享数据比较麻烦。一般在程序间共享文档可以通过UIDocumentInteractionController类实现通讯。它支持在你的app中用其他app预览和显示文档。同时也支持文件关联，允许其他app通过你的程序打开文件。这些技术包括了UIKit中提供的UIDocumentInteractionController类（UIDocumentInteractionController Class Reference)，以及Quick Look框架（Quick Look Framework Reference)。 本文将就如何在应用之间进行文件共享进行基本探究。还请大牛勿喷。 苹果官方文档 效果图 预览文档和呈现选项菜单如果你的app需要打开它不支持的文件(PDF文件、图像文件，等等)，或者需要将app的文件传输给另外一个允许接收此类型文件的app时。可以使用文件交互控制器(UIDocumentInteractionController类的实例)为用户提供可接收程序来处理文件，说的简单点就是通过Quick Look框架判断文档是否能被另一个app打开和预览。 UIDocumentInteractionController在iOS3.2中就已经存在了，使用起来非常灵活，功能也比较强大。它除了支持同设备上app之间的文档共享外，还可以实现文档的预览、打印、发邮件以及复制。 要使用一个文件交互控制器(UIDocumentInteractionController类的实例)，需要以下步骤： 为每个你想打开的文件创建一个UIDocumentInteractionController类的实例 实现UIDocumentInteractionControllerDelegate代理 显示预览窗口/显示菜单。 一、创建实例DocumentInteraction Controller使用静态方法interactionControllerWithURL创建实例，这个方法使用一个NSURL作为参数。 1234//创建实例NSURL *filePath = [NSURL fileURLWithPath:path];UIDocumentInteractionController *documentController = [UIDocumentInteractionController interactionControllerWithURL:[NSURL fileURLWithPath:filePath]]; 二、显示预览窗口Document Interaction Controller对象使用presentPreviewAnimated方法弹出一个全屏的文档预览窗口。 1BOOL b = [documentController presentPreviewAnimated:YES]; 三、显示菜单如果你不想在本应用里面打开文件，那么可以通过第三方应用打开预览文件。通过OptionsMenu(选项菜单)，显示能够接收该类型文件的应用，由用户选择相应的操作。 显示菜单可以使用下列方法： 1234- presentOptionsMenuFromRect:inView:animated:- presentOptionsMenuFromBarButtonItem:animated:- presentOpenInMenuFromRect:inView:animated:- presentOpenInMenuFromBarButtonItem:animated: 这些方法都是类似的，只是显示位置有区别而已。以下代码演示其中一个方法的使用。 12345CGRect navRect = self.navigationController.navigationBar.frame;navRect.size = CGSizeMake(1500.0f, 40.0f);[documentController presentOptionsMenuFromRect:navRect inView:self.view animated:YES]; 四、使用委托如果你显示一个Document Interaction Controller ，则必需要为delegate属性用指定一个委托。让委托告诉DocumentInteraction Controller如何显示。 1documentController.delegate = self; 委托对象需要实现一系列委托方法，最常见的包括： 123- documentInteractionControllerViewControllerForPreview:- documentInteractionControllerViewForPreview:- documentInteractionControllerRectForPreview: 这3个方法在用户点击“快速查看”菜单时依次调用。 1234567891011121314- (UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller &#123; return self;&#125;- (UIView *)documentInteractionControllerViewForPreview:(UIDocumentInteractionController *)controller &#123; return self.view;&#125;- (CGRect)documentInteractionControllerRectForPreview:(UIDocumentInteractionController *)controller &#123; return self.view.frame; &#125; //点击预览窗口的“Done”(完成)按钮时调用- (void)documentInteractionControllerDidEndPreview:(UIDocumentInteractionController *)controller &#123;&#125; 功能一：分享文件12345678910111213141516- (void)shareFile &#123; NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"皮卡丘\" ofType:@\"jpeg\"]; //创建实例(写成成员变量，不然可能导致分享出去被释放崩溃问题) _documentController = [UIDocumentInteractionController interactionControllerWithURL:[NSURL fileURLWithPath:filePath]]; //设置代理 documentController.delegate = self; BOOL canOpen = [documentController presentOpenInMenuFromRect:CGRectZero inView:self.view animated:YES]; if (!canOpen) &#123; NSLog(@\"沒有程序可以打開要分享的文件\"); &#125;&#125; 功能二：预览文件(注册应用程序支持的文件类型)1234567891011121314151617- (void)preview &#123; if (!_path) &#123; return; &#125; NSURL *fileURL = [NSURL URLWithString:[NSString stringWithFormat:@\"%@%@\", [self getURL], [_path lastPathComponent]]]; //创建实例(写成成员变量，不然可能导致分享出去被释放崩溃问题) _documentController = [UIDocumentInteractionController interactionControllerWithURL:fileURL]; //设置代理 documentController.delegate = self; [documentController presentPreviewAnimated:YES];&#125; 配置Info.plist文件 如果你的程序能够打开某种文件，你可以向系统进行注册。方便其他程序通过 iOS 的document interaction技术提供给用户一个选择，从而调用你的程序处理这些文件。 这需要在程序的Info.plist文件中添加CFBundleDocumentTypes键(查看CoreFoundation Keys)。 系统将该键中包含的内容进行登记，这样其他程序就可以通过document interaction controller访问到这些信息。 CFBundleDocumentTypes键是一个dictionary数组，每个dictionary表示了一个指定的文档类型。一个文档类型通常与某种文件类型是一一对应的。 但是，如果你的程序对多个文件类型采用同样的处理方式，你也可以把这些类型都分成一个组，统一视作一个文档类型。例如，你的程序中使用到的本地文档类型，有一个是旧格式的，还有一个新格式（似乎是影射微软office文档），则你可以将二者分成一组，都放到同一个文档类型下。这样，旧格式和新格式的文件都将显示为同一个文档类型，并以同样的方式打开。 CFBundleDocumentTypes数组中的每个 dictionary 可能包含以下键： CFBundleTypeName 指定文档类型名称。 CFBundleTypeIconFiles 是一个数组，包含多个图片文件名，用于作为该文档的图标。 LSItemContentTypes 是一个数组，包含多个UTI【Uniform Type Identifiers】类型的字符串。UTI类型是本文档类型（组）所包含的文件类型。 LSHandlerRank 表示应用程序是“拥有”还是仅仅是“打开”这种类型而已。 下表列出了Info.plist中的一个CFBundleTypeName官方示例。 自定义文件格式的文档类型 123456789101112131415&lt;dict&gt; &lt;key&gt;CFBundleTypeName&lt;/key&gt; &lt;string&gt;My File Format&lt;/string&gt; &lt;key&gt;CFBundleTypeIconFiles&lt;/key&gt; &lt;array&gt; &lt;string&gt;MySmallIcon.png&lt;/string&gt; &lt;string&gt;MyLargeIcon.png&lt;/string&gt; &lt;/array&gt; &lt;key&gt;LSItemContentTypes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.example.myformat&lt;/string&gt; &lt;/array&gt; &lt;key&gt;LSHandlerRank&lt;/key&gt; &lt;string&gt;Owner&lt;/string&gt;&lt;/dict&gt; 自己程序配置文件 1234567891011121314151617181920212223&lt;key&gt;CFBundleDocumentTypes&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeName&lt;/key&gt; &lt;string&gt;com.myapp.common-data&lt;/string&gt; &lt;key&gt;LSItemContentTypes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.microsoft.powerpoint.ppt&lt;/string&gt; &lt;string&gt;public.item&lt;/string&gt; &lt;string&gt;com.microsoft.word.doc&lt;/string&gt; &lt;string&gt;com.adobe.pdf&lt;/string&gt; &lt;string&gt;com.microsoft.excel.xls&lt;/string&gt; &lt;string&gt;public.image&lt;/string&gt; &lt;string&gt;public.content&lt;/string&gt; &lt;string&gt;public.composite-content&lt;/string&gt; &lt;string&gt;public.archive&lt;/string&gt; &lt;string&gt;public.audio&lt;/string&gt; &lt;string&gt;public.movie&lt;/string&gt; &lt;string&gt;public.text&lt;/string&gt; &lt;string&gt;public.data&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/array&gt; 打开支持的文件类型你可以在应用程序委托的application:didFinishLaunchingWithOptions:方法中获得该文件的信息。如果你的程序要处理某些自定义的文件类型，你必须实现这个委托方法（而不是applicationDidFinishLaunching: 方法) 并用这个方法启动应用程序。 application:didFinishLaunchingWithOptions:方法的option参数包含了要打开的文件的相关信息。尤其需要在程序中关心下列键： UIApplicationLaunchOptionsURLKey 包含了该文件的NSURL。 UIApplicationLaunchOptionsSourceApplicationKey 包含了发送请求的应用程序的 Bundle ID。 UIApplicationLaunchOptionsAnnotationKey 包含了源程序向目标程序传递的与该文件相关的属性列表对象。 如果UIApplicationLaunchOptionsURLKey键存在，你的程序应当立即用该 URL 打开该文件并将内容呈现给用户。其他键可用于收集与打开的文件相关的参数和信息。 如果你的应用程序处于活跃状态，此时application:didFinishLaunchingWithOptions:方法是不会被调用的。需要实现application:openURL:options:方法 【以下是本人的写法】 123456789101112131415161718192021222324252627282930313233343536373839404142- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; _vc = [[ViewController alloc] init]; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:_vc]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; self.window.rootViewController = nav; [self.window makeKeyAndVisible]; if (launchOptions) &#123; NSString *str = [NSString stringWithFormat:@\"\\n发送请求的应用程序的 Bundle ID：%@\\n\\n文件的NSURL：%@\\n\\n文件相关的属性列表对象：%@\", launchOptions[UIApplicationLaunchOptionsSourceApplicationKey], launchOptions[UIApplicationLaunchOptionsURLKey], launchOptions[UIApplicationLaunchOptionsSourceApplicationKey]]; [[[UIAlertView alloc] initWithTitle:@\"\" message:str delegate:nil cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil] show]; _vc.path = [launchOptions[UIApplicationLaunchOptionsURLKey] description]; [_vc preview]; &#125; return YES;&#125;- (BOOL)application:(UIApplication *)application openURL:(nonnull NSURL *)url options:(nonnull NSDictionary&lt;NSString *,id&gt; *)options &#123; if (options) &#123; NSString *str = [NSString stringWithFormat:@\"\\n发送请求的应用程序的 Bundle ID：%@\\n\\n文件的NSURL：%@\", options[UIApplicationOpenURLOptionsSourceApplicationKey], url]; [[[UIAlertView alloc] initWithTitle:@\"\" message:str delegate:nil cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil] show]; _vc.path = [url description]; [_vc preview]; &#125; return YES;&#125; 以下创建了一个NSString的分类，并且提供了一个对象方法，使用文件名调用即可返回当前文件的MIMEType类型 12345678910- (NSString *)MIMEType &#123; // 1.根据当前文件创建URL NSURL *url = [NSURL fileURLWithPath:self]; // 2.根据URL创建网络请求 NSURLRequest *request = [NSURLRequest requestWithURL:url]; // 3.发送请求 NSURLResponse *response = nil; [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:nil]; return response.MIMEType;&#125; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny 2015 年 12月 26日","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"文件共享","slug":"文件共享","permalink":"superdanny.link/tags/文件共享/"},{"name":"文件预览","slug":"文件预览","permalink":"superdanny.link/tags/文件预览/"}]},{"title":"软件开发的过程中，这些文档你都用到了吗（转）","date":"2015-12-24T02:24:00.000Z","path":"2015/12/24/Software-development-documentation/","text":"导读：做软件的目的就是要满足客户的需求，这个需求包括功能、外观、操作、时间及性能等各方面。那么，在软件开发过程中那部分最重要呢，程序员说“毋庸置疑，我编写的程序实现了客户提出的功能以及业务流程，….. 众所周知，做软件的目的就是要满足客户的需求，这个需求包括功能、外观、操作、时间及性能等各方面。那么，在软件开发过程中那部分最重要呢，程序员说“毋庸置疑，我编写的程序实现了客户提出的功能以及业务流程，肯定我是最重要的”，美工说“你开发的功能如果没有我的页面美化，是无法呈现给客户的，要知道，很多客户并不很了解内部复杂的功能，首先映入眼帘的就是界面的效果，就像人一样，如果你不是美女，那么他看了你一眼之后，就没有想和你再继续沟通和发展的积极性了”，测试听了不高兴了，说“漏洞百出的产品，哪怕你外观再漂亮，实现的功能再多，也是不成熟的产品，客户是不会使用的。”众说纷纭，各执一词。 以上所说都很有道理，每个角色都是软件成功必不可少的，每个人都好比是一块积木，只有组合起来才能搭成既美观又稳固的造型。 另一方面，他们却又都不是最重要的。举个例子，现在我家在进行装修，木工、瓦工、油漆工都是南方的工人，有很好的手艺，干活也很细致，可是他们在施工的时候都要参考两份文件，一是房屋结构图，二是装修效果图。没有此文件，他们就无从下手，就是拥有再好的手艺，做出来的再漂亮，到时候也会与房屋的实际效果存在偏差。 孙悟空三大白骨精，相信谁都耳熟能详。里面有这样一个场景，孙悟空去化斋前，划了一个圈，将唐僧他们包在里面，只要他们在圈里面，就不会有事，如果出了圈就很危险。这个圈，就是一个范围、一个标准。在这个圈里，你随便折腾，怎么折腾都行，但千万不要越界，否则后果不堪设想。 而在软件开发中文档就是那个圈，它将项目开发所进行的一切活动都进行详细的定义，只要遵照这个文档去开发，那么最终的结果一定是八九不离十。 文档贯穿软件工程的始终，从前期的项目准备，中期的开发到后期的维护、培训，无不以文档作为工作的依据。那么在软件项目中，都包括哪些文档呢，它们的作用又是什么呢，下面我将我的经验分享给大家。 《可行性研究报告》：这是客户在进行项目调研阶段所编写的，具有两重意义，其一，指明项目的必要性和紧迫性，并从业务角度阐述大概的功能需求，注意，只是大概，可能与最后的结果有很大出入；其二，最重要的一点就是为了要钱，向财政部要钱，将最终实现的功能写得天花乱坠，包括决策支持、全文检索、商业智能、远程报表等，但最后开发的可能仅仅是融合简单业务流程的信息输入和输出而已，但这已无关紧要，最重要的是我要到了钱。但是严格来说，这不是项目组所需的文档，于软件开发也意义不大。 《建设方案》：或者是《实施方案》，当客户从财政部申请到资金后，就要着手进行详细的调研和分析了，这里有两种情况，其一，客户自己从各个产品厂家进行相关的调研，进行汇总后，编写方案，这样，聪明、细心的软件公司就会从方案的技术环节，挖掘出客户所选择的产品，最后和这个产品公司合作来中标；其二，让和其关系很好的一家或两家软件公司（不会超过三家）编写，客户进行审核，客户最后选择了谁的方案那么最后这个项目就是这家公司的，这样很多情况并不是公开招标。 《招标书》：将《建设方案》或《实施方案》进行摘取，并附带上技术问题以及招标时的细节、注意事项，构成《招标书》，这个文件也是由客户写得，软件公司在投标前需要购买《招标书》。 《投标书》：与《招标书》所呼应，对技术问题进行相应的技术应答，包括技术标和商务标两部分。 上面几份文档，是项目前期准备时需要的，是侧重于售前方面的；而下面的文档是软件开发过程中必不可少的，我们按开发工作的时间顺序一一介绍。 《需求分析说明书》：对于软件开发来说，《需求分析说明书》就好像是盖楼时所用的图纸，是最重要的文档，由项目经理对客户相关部门进行业务调研后编写，语言侧重于从业务的角度描述功能需求。内容涉及三大部分，其一，编写目的、背景、目标任务等公共性语言；其二，功能性需求，将业务梳理成几大功能模块，一级功能下细分二级功能，依次类推，将最终细化的功能按描述、输入、处理和输出进行详细描述；其三，非功能性需求，包括性能、处理能力、进度、界面设计和运行环境的规定。 《数据库设计说明书》：我是做数据库出身，因此这部分的工作也是由我这个项目经理来做，根据《需求分析说明书》在Erwin建模工具中设计好逻辑模型和物理模型，然后将其整理到此文档中，文档还包含数据库所有的表结构和相关的字段说明。 《概要设计说明书》：说实话，在我做过的项目中，没有编写过此文档，因为我觉得《需求分析说明书》和《详细设计说明书》就足矣了。甚至如果项目简单或时间紧急，《详细设计说明书》都会省略：）。 《详细设计说明书》：主要包含两部分内容，其一，体系结构的设计，也就是项目所采用的几层架构，以及层与层之间的通信机制，还有就是基础框架所采用的技术；其二，是本文档的核心部分，包括每个细分模块的详细设计说明，包括程序描述、功能、性能、输入项、输出项、算法、流程逻辑、接口、存储分配、注释设计、限制条件、测试计划和尚未解决的问题等内容。本说明书对项目所采用的技术和接口都做了详细的规定，是指导程序员开发的直接工具。但需要说明的是，很多项目由于时间原因，都忽略了此说明书的编写，包括本人目前在做的项目也是如此，因此本文档并不是必须的。但如果作为给客户的交付物，需要在项目完成后补全。 《计划进度》：这个不用多说，由项目经理编写，实现对项目进度的严格把控，是项目必须的文档，可用project编写。 《测试用例》：测试用例（Test Case）目前没有经典的定义。比较通常的说法是：指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。它是将软件测试的行为活动做一个科学化的组织归纳．目的是能够将软件测试的行为转化成可管理的模式；同时测试用例也是将测试具体量化的方法之一。由此可见，《测试用例》非常重要，是对项目或产品质量的严格保证，但由于测试人员和项目组的规范性、时间进度等限制，本文档在本地区的实际项目中也很少应用，至少我认识的很多测试人员中，只有极少数的项目中会编写此文档。 《测试结果》：在项目开发阶段使用，也就是交付客户之前。文档为Excel格式，并提供关键字段的数据筛选，内容包括描述、缺陷类型（Bug、需求）、开发人员、状态、关闭时间、所属模块、提交人、解决人、备注等。其中状态包含提交、解决和确认解决，测试人员将问题提交（红色），当程序员解决后就置为解决（黄色），测试人员再次确认无误后，就修改状态为确认解决（绿色），并且添写关闭时间。 《需求变更文档》：产品交付客户之后使用。任何一个好软件，不是在第一个版本就把这些标准全部实现，而是有步骤有重点地实现，逐步成为一个好软件。因此《需求变更文档》是不必可少的，同样作个Excel表格，量化解决。包括下列几项：客户名称、需求提出人、提出日期、需求关闭时间，功能模块名，客户现在版本号，需求描述，需求分类（需求、Bug）等。每次发布新版本都把从上一版本发布之日关闭的需求列表都单独摘成一个文件，附带到这次新发布的版本之后。 此举有两个好处，其一，能够清楚的列出客户以往所提的需求，因为有一些客户提出的改动总是反反复复，一个问题一会要改成A,然后觉得不好要改成B，之后觉得还不如A好，便又要求改回去，这样给公司的进度和安排带来很大的不便，如果因为这个耽误了其他的工作，便可以有此根据和客户进行沟通，防止客户赖账；其二，可以评判技术支持和相关程序员的工作量。此文档为EXCEL格式，但最好还有一个word类型的文档，每次客户提出修改意见时，将此文档打印出来交由客户签字，作为凭证，此方法实际中并不是次次可行，一些强权客户或不敢承担责任的就不签字，那也没辙。 《测试结果》和《需求变更文档》要定期（可一周或一个月）给老板一份。这表明了你的工作量，让他看看你确实一直很辛苦地在工作，另外，也能看出你的认真负责态度。 《用户使用手册》：按标准说，应该由文案写，但在大多数的软件公司中都不设这个职位，因此要么由项目经理写要么由测试人员写，关键看是谁给客户做培训。在目前我做的这个项目中，并没有专职测试，所以这个工作还是项目经理来做。《用户使用手册》可根据实际情况写成三种版本，其一，chm类型文件，适用于C/S的项目，就像微软的产品中，都会有此帮助手册；其二，做成网页形式的帮助文件，适用于B/S项目；其三，就是做成word文档，虽然可保存至本地，但使用起来没有前二者方便。 余者还有《开发任务书》、《项目总结报告》、《软件验收评审》等，并不是必须的，可根据客户需要和实际的项目来选择使用，再次并不一一赘述。 并且，以上所有文档，虽然有些是必须的，比如《需求分析说明书》、《测试结果》、《用户使用手册》等，但根据不同的行业、不同的地区以及不同的项目和团队规模，文档的具体内容都会有所不同，不必较真。只要能抓到老鼠，白猫黑猫都是好猫，况且，没必要的多余的文档会浪费时间和成本等资源。 原文地址：http://www.cioage.com/art/200907/79248.htm 后期本人会将这些文档模板上传上去。点击有惊喜！","tags":[{"name":"开发文档","slug":"开发文档","permalink":"superdanny.link/tags/开发文档/"}]},{"title":"软件项目进度控制要处理好的四个基本问题（转）","date":"2015-12-24T02:18:00.000Z","path":"2015/12/24/Control-Software-Project-Schedule/","text":"导读：在软件项目管理工作中，对软件项目的进度安排有时比对软件成本的估算要求更高。成本的增加可以通过提高产品定价或通过大批量销售得到补偿，而项目进度安排不当会引起顾客不满，影响市场销售。软件项目的….. 制定软件项目进度表有两种途径：其一是软件开发小组根据提供软件产品的最后期限从后往前安排时间；其二是软件项目开发组织根据项目和资源情况制定软件项目开发的初步计划和交付软件产品的日期。多数软件开发组织当然希望按照第二种方式安排自己的工作进度。然而遗憾的是，大多数场合遇到的都是比较被动的第一种方式。 在软件项目管理工作中，对软件项目的进度安排有时比对软件成本的估算要求更高。成本的增加可以通过提高产品定价或通过大批量销售得到补偿，而项目进度安排不当会引起顾客不满，影响市场销售。软件项目的进度安排必须妥善处理以下几个问题： 1、任务分配、人力资源分配、时间分配要与工程进度相协调 在小型软件开发项目中，一个程序员能够完成从需求分析、设计、编码，到测试的全部工作。随着软件项目规模的扩大，人们无法容忍一个人花十年时间去完成一个需要十几个人年才能完成的软件项目。大型软件的开发方式必然是程序员们的集体劳动。由于软件开发是一项复杂的智力劳动，在软件开发过程中加入新的程序员往往会对项目产生不良影响。因为新手要从了解这个系统和以前的工作做起，当前正在从事这项工作的“专家”不得不停下手中的工作，抽出时间对他们进行培训。于是，在一段时间内，工作进度便拖后了。软件开发人数的增加将导致信息交流路径和复杂性的增加，项目进行中盲目增加人员可能造成事倍功半的效果。适用于大型项目的Rayleigh-Norden曲线[4]表明，完成软件项目的成本与时间的关系不是线性的，使用较少的人员，在可能的情况下，相对延长一些工作时间可以取得较大的经济效益。然而值得指出的是，程序员小组的正常技术交流能改进软件质量，提高软件的可维护性，减少软件错误，降低软件测试和正确性维护的开销。任务、人力、时间三者之间存在最佳组合，必须引起项目负责人的足够重视。 2、任务分解与并行化 软件工程项目既然需要软件开发人员集体的劳动，就需要采取一定的组织形式，将软件开发人员组织起来。软件人员的组织与分工是与软件项目的任务分解分不开的。为了缩短工程进度，充分发挥软件开发人员的潜力，软件项目的任务分解应尽力挖掘并行成分，以便软件施工时采用并行处理方式。 3、工作量分布 用前几节介绍的软件估算技术可以估算出软件开发各个阶段所需要的工作量，通常用人月或人年表示。软件在需求分析和设计阶段占用的工作量达到总工作量的40％～50％，说明软件开发前期的活动多么重要。当然这也包括分阶段开发原型的开销。大家熟悉的编码工作只占全部工作量的10％～20％，而软件测试和调试的工作量占到总工作量的30％～40％。这对于保证软件产品质量是十分必要的，实时嵌入式系统软件的测试和调试工作量所占的比例还要大些。 4、工程进度安排 软件项目的工作安排与其他工程项目的进度安排十分相似，通常的项目进度安排方法和工具稍加改造就可以用于软件项目的进度安排。目前，程序评估与审查技术（PERT）和关键路径方法（CPM）是两种比较常用的项目进度安排方法。两种方法都生成描述项目进展状态的任务网络图。网络图中按一定的次序列出所有的子任务和任务进展的里程碑，它表示各子任务之间的依赖关系。网络图也是作业分解结构（WBS）的发展。20世纪70年代，作业分解结构就已广泛应用于航天、航空、航海、雷达、通信、火控系统等领域的基于计算机项目的分解，并用以命名各项子任务，这些子任务不仅可以用网络图的形式表示，还可以用树型或层次结构图表示。PERT和CPM方法为软件规划人员提供了定量描述工具，包括： ①关键路径。完成关键路径上所有任务时间的总和，就是项目开发所需要的最短时间。 ②用统计模型估算开发每个子任务需要的工作量和时间。 ③计算各子任务的最早启动时间和最迟启动时间，即确定启动子任务的时间窗口边界。 某个子任务的最早启动时间被定义为该子任务的所有前导任务完成的最早时间。反之，某个子任务的最迟启动时间被定义为在保证项目按时完成的前提下，最迟启动该子任务的时间。与最早启动时间和最迟启动时间对应的概念是最早结束时间和最迟结束时间。它们分别是最早启动时间和最迟启动时间与完成该子任务所需要时间的和：在任务进度安排过程中，应先寻求关键路径并在关键路径上安排一定的机动时间和节假日，以便应付意想不到的困难和问题。采用这些工具可以大大减轻软件项目管理人员在制定软件项目进度表方面的工作量，并可提高工作质量。 原文地址：http://www.cioage.com/art/200906/65445.htm","tags":[{"name":"进度控制","slug":"进度控制","permalink":"superdanny.link/tags/进度控制/"}]},{"title":"iOS开发企业版ipa分发(In-House模式)记录","date":"2015-10-10T07:52:00.000Z","path":"2015/10/10/iOS-recording-In-House/","text":"前言本人公司开发的.ipa发布于 AppStore 和自己的服务器上。但是自己却一直没时间利用公司的资源进行研究。现在赶紧趁热打铁，记录一下，以便以后查阅。 在此之前，在网上查阅了相关资料并整理了一下加以完善更正。 背景网上说Xcode 6之后版本导出企业.ipa包需要手动添加.plist文件，本人今天亲自测试了一遍，发现Xcode 7之后又可以配置生成的。在这里我按照我的流程走一遍。 IPA打包 在工程中选择Product-Archive进入打包界面 选择Export进入打包方式选择界面 选择Save for Enterprise Deployment选项，Next 选择对应的企业账号，然后继续即可 接下来是对安装设备的要求选择，默认选择所有设备。第二个选项是指定特定类型设备方可安装。我们使用默认第一项，Next 之后的界面是对应用的二次确认，确保APP配置准确无误。在窗口的左下方有一个Include manifest for over-the-air installation。该选项表示是否在生成.ipa文件的同时生成.plist文件，我们勾选上，Next over-the-air: OTA 是苹果在iOS4中新增的一项功能，目的是让企业用户能够在脱离Apple App Store的情况下通过网页无线发布 iOS 应用；简单来讲就是在Safari中点击一个链接就可以在iPhone或iPad上下载并安装应用（目前很多越狱软件都是使用的这种发布方式）。 接下来配置.plist文件，填写完之后，Export导出.ipa包和相应的.plist文件（建议将生成的.plist文件命名同APP名一致，方面后期管理） 构建网站必备条件 需要购买一个苹果的企业版证书，价格$299/年。指南 网站需要支持HTTPS协议，用于访问下载.plist文件 这里有两种办法： 一种是购买SSL证书或者免费申请SSL证书； 另一种是将.plist文件托管在第三方上面，利用第三方支持的HTTPS进行访问下载； 使用OSChina的代码托管。访问OSChina，添加一个项目；然后用git或svn客户端将.plist文件提交到版本库中；最后在浏览器中访问项目中的.plist文件，查看原始数据，即可获得plist的https下载地址。 步骤1.将.plist文件与.ipa文件上传至服务器供用户访问2.创建一个包含如下代码的网页，用户轻点 Web 链接后会下载.plist文件，并触发下载和安装。1&lt;a href=\"itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist\"&gt;Install App&lt;/a&gt; 3.配置服务器MIME类型您可能需要配置 Web 服务器，让.plist文件和.ipa文件可正确传输。 对于OS X Server，请将MIME类型添加到 Web 服务的MIME类型设置： application/octet-stream ipa text/xml plist 对于微软的互联网信息服务器 (IIS)，请使用IIS Manager在服务器的“属性”页面中添加MIME类型： .ipa application/octet-stream .plist text/xml 【警告】撤销分发证书会导致使用该证书签名的所有应用失效。只有万不得已时才应撤销证书，比如确定专用密钥已丢失或确信证书已遭破解。 拓展区关于无线清单文件(.plist文件)清单文件是一个XML plist 文件，可供 Apple 设备用来从您的 Web 服务器上查找、下载和安装应用。清单文件由 Xcode 创建，使用的是您在共享用于企业分发的归档应用时所提供的信息。以下栏是必填项： URL：应用 (.ipa) 文件的完全限定 HTTPS URL display-image：57 x 57 像素的 PNG 图像，在下载和安装过程中显示。指定图像的完全限定 URL full-size-image：512 x 512 像素的 PNG 图像，表示 iTunes 中相应的应用 bundle-identifier：应用的包标识符，与 Xcode 项目中指定的完全一样 bundle-version：应用的包版本，在 Xcode 项目中指定 title：下载和安装过程中显示的应用的名称 样本清单文件(下面给出)还包含可选键。例如，如果应用文件太大，并且想要在执行错误检验（TCP 通信通常会执行该检验）的基础上确保下载的完整性，可以使用 MD5 键。通过指定项目数组的附加成员，您可以使用一个清单文件安装多个应用。 示例 iOS 应用清单文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;!-- array of downloads.--&gt; &lt;key&gt;items&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;!-- an array of assets to download --&gt; &lt;key&gt;assets&lt;/key&gt; &lt;array&gt; &lt;!-- software-package: the ipa to install.--&gt; &lt;dict&gt; &lt;!-- required. the asset kind.--&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;!-- optional. md5 every n bytes. will restart a chunk if md5 fails.--&gt; &lt;key&gt;md5-size&lt;/key&gt; &lt;integer&gt;10485760&lt;/integer&gt; &lt;!-- optional. array of md5 hashes for each \"md5-size\" sized chunk.--&gt; &lt;key&gt;md5s&lt;/key&gt; &lt;array&gt; &lt;string&gt;41fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;string&gt;51fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;/array&gt; &lt;!-- required. the URL of the file to download.--&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/apps/foo.ipa&lt;/string&gt; &lt;/dict&gt; &lt;!-- display-image: the icon to display during download.--&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;!-- optional. indicates if icon needs shine effect applied.--&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://www.example.com/image.57x57.png&lt;/string&gt; &lt;/dict&gt; &lt;!-- full-size-image: the large 512x512 icon used by iTunes.--&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;!-- optional. one md5 hash for the entire file.--&gt; &lt;key&gt;md5&lt;/key&gt; &lt;string&gt;61fa64bb7a7cae5a46bfb45821ac8bba&lt;/string&gt; &lt;key&gt;needs-shine&lt;/key&gt; &lt;true/&gt; &lt;key&gt;url&lt;/key&gt;&lt;string&gt;https://www.example.com/image.512x512.jpg&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt;&lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;!-- required --&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.example.fooapp&lt;/string&gt; &lt;!-- optional (software only) --&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0&lt;/string&gt; &lt;!-- required. the download kind.--&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;!-- optional. displayed during download; typically company name --&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;Apple&lt;/string&gt; &lt;!-- required. the title to display during the download.--&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;Example Corporate App&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt; 苹果官方相关文档以无线方式安装企业内部应用 关于正确提取.plist文件下载地址姿势在评论区中，有朋友问及到关于.plist文件的下载地址不正确问题，这里提供几种方式： 1、在自己的服务器部署.plist时，直接提供服务器下载地址即可2、将.plist文件部署在github上时，可以在进入.plist详细界面，点击RAW按钮获取正确的地址3、另外七牛也是一个不错的选择，我们可以将.plist文件上传到七牛上面，需要配置ssl证书。 部署下载页面方式1、方式一：进入下载页面之后点击安装APP按钮之后才能下载安装 123456789101112&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;htmlxmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;metahttp-equiv=\"Content-Type\"content=\"text/html; charset=utf-8\"/&gt; &lt;title&gt;应用名字&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1style=\"font-size:80pt\"&gt;如果点击无法下载安装，请复制超链接到浏览器中打开&lt;h1/&gt; &lt;h1style=\"font-size:100pt\"&gt; &lt;a title=\"iPhone\" href=\"itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist\"&gt;安装APP&lt;/a&gt;&lt;h1/&gt; &lt;/body&gt;&lt;/html&gt; 2、方式二：进入下载页面之后自动下载安装 12345678910111213&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;htmlxmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;metahttp-equiv=\"Content-Type\"content=\"text/html; charset=utf-8\"/&gt; &lt;title&gt;应用名字&lt;/title&gt; &lt;script&gt; var url =\"https://example.com/manifest.plist\"; window.location =\"itms-services://?action=download-manifest&amp;url=\"+ url; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3、方式三：通过iOS应用内安装 1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist\"]]; 4、方式四：终极大招，直接使用第三方托管平台（推荐自己常用平台） fir.im - 免费应用内测托管平台|iOS应用Beta测试分发|Android应用内测分发 蒲公英 - 免费的应用托管平台|App应用众测分发 TestFlight Beta Testing - App Store - Apple Developer 安装失败原因利用企业证书打包部署的 ipa 安装有可能存在安装失败的情况。一般的失败的原因可以查阅iOS应用安装失败原因排查 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"In-House","slug":"In-House","permalink":"superdanny.link/tags/In-House/"}]},{"title":"iOS UIKeyboardType各类键盘效果图","date":"2015-10-09T16:20:00.000Z","path":"2015/10/10/iOS-UIKeyboardType/","text":"前言每次设置键盘类型都要点击UIKeyboardType查看类型，在这里整理一下各种键盘类型。方便自己查看，省时省力。 12345678910111213141516typedef NS_ENUM(NSInteger, UIKeyboardType) &#123; UIKeyboardTypeDefault, // Default type for the current input method. UIKeyboardTypeASCIICapable, // Displays a keyboard which can enter ASCII characters, non-ASCII keyboards remain active UIKeyboardTypeNumbersAndPunctuation, // Numbers and assorted punctuation. UIKeyboardTypeURL, // A type optimized for URL entry (shows . / .com prominently). UIKeyboardTypeNumberPad, // A number pad (0-9). Suitable for PIN entry. UIKeyboardTypePhonePad, // A phone pad (1-9, *, 0, #, with letters under the numbers). UIKeyboardTypeNamePhonePad, // A type optimized for entering a person's name or phone number. UIKeyboardTypeEmailAddress, // A type optimized for multiple email address entry (shows space @ . prominently). UIKeyboardTypeDecimalPad NS_ENUM_AVAILABLE_IOS(4_1), // A number pad with a decimal point. UIKeyboardTypeTwitter NS_ENUM_AVAILABLE_IOS(5_0), // A type optimized for twitter text entry (easy access to @ #) UIKeyboardTypeWebSearch NS_ENUM_AVAILABLE_IOS(7_0), // A default keyboard type with URL-oriented addition (shows space . prominently). UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable, // Deprecated&#125;; 效果UIKeyboardTypeDefault UIKeyboardTypeASCIICapable UIKeyboardTypeNumbersAndPunctuation UIKeyboardTypeURL UIKeyboardTypeNumberPad UIKeyboardTypePhonePad UIKeyboardTypeNamePhonePad UIKeyboardTypeEmailAddress UIKeyboardTypeDecimalPad UIKeyboardTypeTwitter UIKeyboardTypeWebSearch UIKeyboardTypeAlphabet 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"UIKeyboardType","slug":"UIKeyboardType","permalink":"superdanny.link/tags/UIKeyboardType/"},{"name":"键盘","slug":"键盘","permalink":"superdanny.link/tags/键盘/"}]},{"title":"iOS应用安装失败原因排查","date":"2015-09-29T08:40:00.000Z","path":"2015/09/29/iOS-app-install-fail-reason/","text":"本文结合蒲公英以及FIR两家应用托管平台的博文进行整理 前言iOS 的内测应用在安装时，很多人都遇到过安装失败的情况，安装失败的原因比较多，下面将一些常见原因总结如下，方便开发者进行排查。 在 iOS 9 中启动应用时，出现提示“未受信任的企业级开发者”这样问题是因为在 iOS 9 以后的版本中，苹果对企业签名的应用做了更严格了限制。具体解决办法请见： 企业级证书打包下载安装之后无法使用问题 在 iOS 9 中点击“安装”按钮后，没有弹出“是否安装”的提示这个问题是因为 iOS 9 的一个 Bug 导致的。出现这个问题的前提，一般是由于用户已经从苹果官方 App Store 上安装了相同的应用。 【解决办法】 先在设备中删除之前已经安装的应用，然后再从托管平台安装即可。 为什么在 iOS 9 中，点击“安装”按钮后，没有任何反应，桌面也没有出现应用图标，但是状态栏上的网络图标在转这是由于 iOS 9 中的一个 Bug 造成的。虽然看上去没有反应，其实应用已经在后台开始下载并安装了，状态栏上的网络图标在转就是一个证明。这个时候，只要多等待一会儿就好了，应用安装完成之后会在桌面上显示出来的。 应用安装过程中提示”无法下载应用程序”原因一：在导出 iOS APP 的安装包文件（ .ipa 文件）时，选择了 APP-Store 方式。在导出 iOS 的.ipa文件时，有些开发者选择了APP-Store方式，这种方式导出的.ipa文件，只适合于上传到苹果App Store，并不能通过托管平台来安装。如果是这种方式导出的 .ipa文件，传到托管平台上是不能通过安装的。 原因二：在导出 iOS APP 的安装包文件（ .ipa 文件）时，选择了 Ad-hoc 方式，但是没有添加设备 UDID 。在导出 iOS 的安装包文件时，如果选择了Ad-hoc方式（一般用于苹果个人开发者账户），那么，如果要某台设备可以安装，则必须要将这台设备的 UDID 添加到导出安装包时所用的证书文件中（.mobileprovision文件），才可以在这台设备上安装。 使用 Ad-hoc 方式导出的安装包文件上传到托管平台后，托管平台会显示为内测版，同时会在应用管理中，显示出该安装包的证书中包含的 UDID 列表。开发者可以根据显示出的UDID列表，来排查某台设备的 UDID 有没有被添加到安装包的证书中。 原因三：在导出 iOS APP 的安装包文件（ .ipa 文件）时，选择了 In-house 方式，但是证书已过期或被撤销。在导出 iOS 的安装包文件时，如果选择了In-house方式（一般用于苹果企业开发者账户），此时，如果出现无法安装的情况，开发者可以检查一下自己的企业开发者证书是否已过期或被撤销。因为苹果对于企业开发者证书管理较为严格，所以开发者如果使用不当，可能会导致企业证书被封，被封后的企业证书导出的安装包，也是无法正确安装的。 原因四：开发者在生成APP安装包时，没有在 Xcode 中设置正确的 Architecture 。iOS 应用的 Architecture（架构），决定了这款 iOS 应用可以在哪些设备机型上安装。例如，如果某个应用在 Xcode 中只添加了 arm64 这一种 Architecture，那么最终打包后的安装包文件上传到托管平台后，对于 iPad mini、iPhone5 等以下设备，都是无法安装的（因为这些设备都不是 arm64 架构）。换句话说，如果需要在某个设备上可以安装，APP 就必须支持那个设备的 Architecture。 所以，正确的解决方法是，在生成 APP 安装包时，尽可能让 APP 支持更多的 Architecture。 具体操作方法是：在 Xcode - Build Settings - Architecture 中，增加 armv7、armv7s、arm64，以便所有设备都可以安装。然后，将 &quot;Build active architecture only&quot; 设置为NO。对于各个 iOS 设备支持的 Architecture 类型。请点击这里查看。 原因五：APP 支持的 iOS 系统版本，和当前设备系统版本不符。打包时 APP 选择支持的 iOS 系统版本过低或者过高，都可能导致 APP 无法安装成功。例如，如果某个 APP 设置了只支持 iOS 7.0 以上的系统时，那么，如果在 iOS 6.1 系统上安装时，肯定是无法安装成功。 因此，我们应该尽量让 APP 尽可能支持更宽泛的系统版本。 具体操作方式是：在Xcode - General - Deployment Info - Deployment Target中，给 APP 设置一个尽量低的版本，例如 iOS 5.0。 原因六：开发者上传的是一个破解的 ipa 安装包，或者是一个使用破解 Xcode 方式打包生成的 ipa 安装包，或者是通过 iTunes 生成的 ipa 安装包。通过任何非 Xcode（或 Xcode 的命令行工具）生成的安装包，都是没有办法正确在设备上安装的（越狱设备除外）。 常见的不正确的打包 ipa 的方式有：通过 iTunes 导出安装包文件、通过 iTools 导出安装包文件等等。这种类型的 APP 上传到托管平台后，会显示未签名的标签提示。 【正确的方法】 使用一个正常的苹果开发者证书，通过未破解的 Xcode 打包生成 ipa 安装包。 原因七：设备上已经安装了这个APP，且已经安装的 APP 和要安装的 APP 是用不同证书打包的。这种情况下，也会造成 APP 安装失败。解决的方式很简单，开发者只需将设备上原来已经安装的 APP 删除，再重新安装新的 APP 即可。 原因八：Info.plist 文件中的LSRequiresIPhoneOS 没有设置，或者设置了 NO。对于 iOS 的 APP 来说，如果Info.plist文件中的LSRequiresIPhoneOS没有设置，或者设置了NO，那么由 Xcode 导出的安装包（.ipa包），就不会包含Payload文件夹，而是被一个叫做APPlications的文件夹代替。这样的安装包在安装时，会被 iOS 判定为无效的安装包，所以无法被正确安装。 【解决方式】 只需要将Info.plist文件中的LSRequiresIPhoneOS设置为YES，然后重新打包即可。具体操作为：在 Xcode 中打开Info.plist文件，然后检查 LSRequiresIPhoneOS是否已设置，如果没有设置，就添加一个，然后将LSRequiresIPhoneOS的类型设置为Boolean，值设置为 YES。 设置好以后，可以看到Info.plist文件中显示APPlication requires iPhone environment的值为YES。 原因九：网络出现中断或异常。遇到这种情况，用户可检查自己手机的所连接的网络是否稳定、速度是否正常等。可以尝试一下其他网站，或者更换一个 Wi-Fi，或者由 Wi-Fi 换成 3G/4G 等，然后重新安装。 企业证书打包安装失败这里推荐FIR提供的一款可以打印安装失败日志的工具Log Guru 下面的几条是转载至Sailinghj’s blog 自我检查以下几方面1、 若要在网页上安装 APP，则 iOS7.1 及以后的 plist 文件的下载地址要放在https的网址下，而ipa文件下载地址不一定要https。 2、 ipa文件放到服务器上时，要设置下iis的 ipa 文件下载支持，否则点击下载后会图标一直停留在“等待中”。 3、 程序下载安装时，快安装完成时，图标的显示突然回退，那就是provisioning profile的问题了，查看日志会看到类似下面的信息，遇到这种情况你得检查下provisioning profile是否正确了： installd?entitlement ‘get-task-allow’ has value not permitted by provisioning profile 4、 iOS8安装到3分之2左右的时候停止，然后弹出“此时无法安装应用程序”的提示框。遇到这种情况时以为是签名或者provisioning profile的错误，然后各种检查重新发布，但是没有解决。查看日志后发现这样一条错误： 0x1022dc000 -[MIContainer makeContainerLiveReplacingContainer:withError:]: Made container live for com.kmvc.myapp at… 然后在Stack Overflow上找到同样的问题。主要的回答是这么说的： Specify a ‘display-image’ and ‘full-size-image’ as described here: http://www.informit.com/articles/article.aspx?p=1829415&amp;seqNum=16iOS8 requires these images 也就是说 iOS8 的下载安装是必须要display-image和full-size-image这两个文件，文件地址要和你的 plist 文件中写的一致。因为之前 iOS7 的安装没有这两个图片文件也可以安装，也没想到会是这个导致的无法安装，所以一定要严格按照苹果的规范来，不然真是出了问题都很难发现。 5、 之前安装过该 APP 的 iOS8 系统点击安装后没有反应。 还是查看日志，只有一条记录： LoadExternalDownloadManifestOperation: Ignore manifest download, already have bundleID: com.mycom.MyApp 遇到这种情况，按照Stack Overflow上说的回答。更改 plist 文件的bundle ID（是下载时用的 plist 文件不是项目的bundle ID），然后重新点击就可以下载安装了。 【托管平台】: 托管平台是指将APP发布于第三方平台上面，供用户安装测试。常见的托管平台有蒲公英以及FIR 【APP-Store】: APP-Store版，用于发布到苹果商店 【Ad-hoc】: 内测版，用于内部指定设备使用 【In-house】: 企业版，可在任何设备上安装，但不能滥用 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"安装失败","slug":"安装失败","permalink":"superdanny.link/tags/安装失败/"}]},{"title":"iOS应用打包","date":"2015-09-24T17:19:00.000Z","path":"2015/09/25/iOS-archive/","text":"基本步骤 选择相应地描述文件、证书 product -&gt; archive 导出ipa在第三方平台分发测试或者上传 AppStore 审核 这样的做法比较保险，因为 archive 只会编译出真机的二进制码，所以不用担心导出的ipa真机装不了 现在有点困了，流程图后面补上。。。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"打包","slug":"打包","permalink":"superdanny.link/tags/打包/"}]},{"title":"iOS开发者证书的那些事","date":"2015-09-24T16:42:00.000Z","path":"2015/09/25/iOS-production-certificate-and-use/","text":"👉苹果官方文档 Certificates 证书 我们从开发者中心了解到，开发者证书分为两种类型：Development Certificate(开发证书)和Production Certificate(发布证书)。两种证书都有对应的附属证书，包括推送证书、Apple Pay证书、Pass Type ID证书等等一系列附属证书。 需要注意的是，当我们发布应用到 AppStore 时，发布的电脑必须具备两个条件： 安装了创建这个发布证书的电脑导出的p12文件 从开发者账号下载了发布证书 证书的作用当某台电脑安装开发者证书后，这台电脑是如何拥有这种能力的呢？ 苹果在此运用了代码签名技术。代码签名验证允许我们的操作系统来判断是谁(你或者信任的团队成员)对App进行了签名。 Xcode会在项目编译期间使用你的代码签名验证，这个验证由一个由Apple认证过的公钥-私钥对组成，存储在你的Keychain(下简称钥匙串)中，公钥包含在证书(Certificates)中，公钥证书在本地钥匙串和开发者账号都有存储。 另外，还有一个我们可以叫做媒介证书(Intermediate Certificate)的证书来确保我们的证书(Certificates)是经过授权而发布的。当安装好Xcode时，媒介证书就已经安装到我们的钥匙串中去了。如果你不小心删除了你的媒介证书，不用担心。你可以重新下载它。 通过在开发者账号（Developer Account）和本地（Mac）都经过验证的证书（Certificate）我们就可以利用合法的证书进行App的测试和发布了。 方法一：快捷创建法（利用Xcode创建） 方法二：创建CSR文件及证书制作1. 打开电脑中的钥匙串访问 2. 选择菜单钥匙串访问-证书助理-从证书颁发机构请求证书 3. 输入你的Email地址和名字，确保Email地址和名字与你注册为iOS开发者时登记的相一致(不一致也没关系) 其中 CA电子邮箱地址 栏目可以为空 4. 选择保存到磁盘(Saves to Disk)，建议保存到桌面，方便查找 5. 打开开发者中心，登录开发者账号 6. 选择Certificates, Identifiers &amp; Profiles进入，然后选择Certificates 7. 选择Certificates，在右侧选择添加按钮添加 8. 选择iOS App Development，用于真机调试的Certificates文件，点击Continue。然后接下来会让你创建CSR文件(Create a CSR file)，点击Continue进入下一步上传CSR文件 9. 点击Choose File选择刚刚存储在桌面的SCR文件，然后点击Generate。一会就生成我们想要的证书啦！ 10. 我们可以将刚刚生成的证书点击Download下载到本地使用 证书的使用如果开发者B，登录开发者账号，下载证书（cer文件）运行，只有证书没有私钥，是不能正常使用的。所以如果有新同事加入到开发组的时候，应该从本地钥匙串中选择证书，一定要记得展开证书那一条显示出私钥并将两行都选中，右键导出2项，输入密码之后就生成p12文件（包含证书和私钥）给同事。 另外可以给同事一份描述文件(Provisioning Profiles)，用于本地开发识别测试设备。 需要强调一点，证书和项目关系其实并不大，证书一般有效期只有一年，当证书过期后，只需要重新生成一份证书，上传到开发者账号就行，同时因为原有证书过期，需要重新生成Provisioning Profiles文件。然后给同事们最新的p12文件和Provisioning Profiles文件就行 所以开发者账号中的证书，配置文件是可以放心操作的（比如误删了，或者找不到证书私钥了） 证书过期/即将过期网上很多说法，但是讲的对我来说还不够完善，所以这里统一一下，也方便自己查阅。 疑问一：证书过期了，会影响到 AppStore 上面的应用吗？ 答：证书过期不会影响已上架 AppStore 应用，但是推送会出问题，更新推送证书也不用下架重新发布，可以重新生成，只要保证 developer.apple.com 中那个 APP ID 的推送证书和推送服务器上的一致即可。但是账号欠费的话应用会被下架。 疑问二：证书过期了/即将过期怎么办？ 答：首先，打开密钥中心，生成一个CSR（证书请求）。然后，到Apple Center把证书revoke，然后新建一个，新建的将会默认是刚刚revoke的证书的所有设置的。把下载回来的证书导出一份p12格式的保存起来（因为如果其他人需要的时候，只能跟你拿了，在Apple Center下载的用不了的。原因是还需要你电脑的密钥）然后去provision profile edit 一下，从新下载，替换掉原来的。你就可以继续开发了。不需要提交新 App 到 AppStore。 疑问三：revoke证书对APP的影响 revoke证书对生产、测试环境的影响（1）revoke生产环境证书是不会影响已上架的APP。（2）revoke开发环境证书，则安装过该证书的APP的用户将无法打开该APP了，并且一点击APP会出现闪退现象。这时就需要开发人员重新生成开发证书后打包APP了。 Missing private key出现的原因（1）忘记Mac开机密码，在开机时进入终端重设密码，会导致私有key丢失。（2）证书生成的源电脑不是你所用的电脑，要向源电脑请求p12文件和描述文件。具体可见“在团队中，证书文件管理”。 在团队中，证书文件管理用Xcode打包时，有时系统会提示“missing private key”等错误。打开钥匙串，在“登录”选项查看种类为“证书”的名称，是否含有三角符号，没有代表缺失private key 。如下图： 👉官方资料 Provisioning Profiles 描述文件在这里，我引用别人的一段话，因为觉得写得很喜感，但又很实在。 我想这个界面一弹出来的时候，蛋蛋忧伤迎面扑来。然后怒点 Fix issue，然后你们团队负责管理证书的基友突然发现证书中心多了好多好乱的证书以及描述文件，然后他爆了一句：what the f××k！删掉了带有Xcode *的证书以及描述文件，然后自己又暴力的点了一发Fix issue，然后你突然调试不了了，再暴击Fix issue键，最后整个团队都只有通过Fix issue来真机调试了… 所以慎点Fix issue，如果点击这个选项，聪明的(蠢哭的)Xcode就会自己管理描述文件，然后各种莫名其妙的带有Xcode *的证书以及描述文件… 其实只要坚信一点，证书、设备ID、AppID、描述文件都弄对了就绝逼不会出问题的！ 描述文件过期苹果官方文档写明，企业证书有效期是3年，而描述文件只有1年有效期。所以当你的描述文件过期(expire)时。不用慌张，我看到网上好多朋友说删除重新生成，其实不用这么麻烦，只需要3步完成：点击过期的描述文件展开详情界面-点击Edit按钮-点击Generate按钮 感谢DavidDay、蛙牛提供的资料参考 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"开发证书","slug":"开发证书","permalink":"superdanny.link/tags/开发证书/"}]},{"title":"Apple开发者账号相关","date":"2015-09-24T14:54:00.000Z","path":"2015/09/24/iOS-about-certification/","text":"证书类型 账号类型 价格 可以发布AppStore? 支持安装设备数量 申请条件 证书类型 个人账号 $99 √ 500 无限制 Ad Hoc, App Store 公司账号 $99 √ 500 DUNS编码 Ad Hoc, App Store 企业账号 $299 × 无限制 DUNS编码 Ad Hoc, In House 教育账号 $0 √ 500 教育机构 Ad Hoc, App Store 证书选择到目前为止，苹果为 iOS 应用共提供了三种类型的证书签名方式，每一种都有独特的用途。这三种分别是： Ad-hoc(内测版) In-house(企业版) App-Store(App-Store版) 关于这三种类型的证书，区别如下表所示： 证书名称 安装范围 支持的苹果开发者类型 Ad-hoc 需要把设备UDID添加到证书才可安装 个人账号、公司账号、教育账号、企业账号 In-house 任何iOS设备均可安装 企业账号 App-Store 只能通过App Store安装 个人账号、公司账号、教育账号 内测阶段对于一个未上线App Store的应用，一般来说，开发者如果需要将应用安装到某些用户的设备上，就需要将应用导出为这些设备可以直接安装的安装包（.ipa文件），安装包能否正确导出，是决定了应用能否被正确安装到设备上的关键因素。其中，最关键的一个因素是，导出安装包时，应用所使用的证书（即：签名方式）。 开发者可以选择如下两种方式的证书签名方式，来导出应用安装包： Ad-hoc 方式 In-house 方式 其中，具体使用哪种方式，取决于开发者拥有苹果开发者账号的类型。例如，如果开发者拥有的是苹果个人开发者账号，则可以使用Ad-hoc方式；如果拥有的是苹果企业开发者账号，则可以使用In-house方式。 感谢朋友提醒，新版Xcode现已支持无证书也能真机调试。 证书申请（以申请企业账号为例）申请DUNS码（邓白氏码）—— 企业账号需要 关于DUNS码和企业账号苹果有相关的帮助文档： 企业账号 DUNS码 接下来进入正题，关于DUNS码的申请，我们所填写的信息必须真实，不做假。 DUNS码申请地址 信息填写中Legal Entity Name要用英文填写，实在不行，就用拼音。 手机号码务必填写正确，到时候会有相关人员打电话核实。填写的信息最好备份一份，以后可能会用到。 填完提交后很快收到邮件。剩下就等着电话核实了。 电话核实之后会在你之前填写的Email上收到DUNS码，由于苹果公司同步这些数据需要时间，所以拿到DUNS码之后需要14个工作日后才能用。 企业账号注册企业账号注册需知： 经过一段时间的等待，现在DUNS码终于可以使用了，接下来就是Apple ID注册 将之前申请的DUNS码填写进去，之后Review&amp;submit。最后等待苹果公司的电话确认信息。 通过审核之后，可以进行支付步骤了。支付后提示需要两个工作日处理订单，处理完毕后会有邮件通知。 收到激活邮箱之后进行激活，账号就可以使用了。 申请企业账号地址 账号注册界面如下图： 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"开发者账号","slug":"开发者账号","permalink":"superdanny.link/tags/开发者账号/"}]},{"title":"iOS证书申请、开发、打包、排查等系列教学","date":"2015-09-24T07:13:00.000Z","path":"2015/09/24/iOS-about-certification-guide/","text":"前言 本文是基于先人经验进行的总结整理。整理这篇文章的目的是为了让开发者能够更好更快的掌握iOS开发的整个打包流程，同时也方便本人以后查阅，减少不必要的时间。让整个开发流程简单易懂。 本文将分点介绍整个iOS开发测试过程中所需要的步骤。包括开发者账号的申请，证书的创建、使用，应用的打包，问题排查等等。 Apple开发者账号相关iOS开发者证书的那些事应用打包iTunes Connect系列 iTunes Connect(一) — iOS应用上架到AppStore iTunes Connect(二) — 应用上架过程中App状态指南 APP安装失败原因排查特别鸣谢感谢蒲公英提供的资源支持 感谢容芳志提供的资料参考 拓展区 如果在操作过程中有什么不明白的地方，可以打电话找Apple开发者支持的客服电话，电话里有专门的技术人员给你解答申请账号方面的问题。如果运气好还可能是个妹子接的哦。我们选中国区的电话。是中国人给你解答，不用担心自己的英语不行。电话服务时间是周一到周五，北京时间上午9点到下午5点。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"打包","slug":"打包","permalink":"superdanny.link/tags/打包/"},{"name":"证书","slug":"证书","permalink":"superdanny.link/tags/证书/"},{"name":"安装","slug":"安装","permalink":"superdanny.link/tags/安装/"}]},{"title":"iOS调试技巧-断点调试","date":"2015-09-23T10:44:00.000Z","path":"2015/09/23/iOS-assert/","text":"Condational Breakpoints（条件断点）普通断点只要执行到断点所在行就会停止程序，但是有时候我们想当满足一定条件时才停止程序。这个调试技巧在当你想要捕获一个循环中的变量的特定值或者一些不常发生的情况时是非常有用的，而不用你每次迭代都停止来查看。 怎样开启条件变量？ 添加一个普通断点 右键点击断点选择Edit Breakpoint 打开断点编辑器，你可以在这里设置断点条件（以及一些其他的断点设置），设置好之后就可以见证奇迹了。 断点条件拓展 Global BreakPoint（全局断点)当应用产生异常或崩溃时Xcode一般会直接跳到主函数。但这并不是我们想要的, 我们想要的是产生异常或崩溃能够停留在异常或者崩溃发生的地方而不是跳转到主函数。幸运的是有一个方法可以做到。 Xcode有一个beautiful的功能叫做异常断点，允许我们在异常发生时在异常发生的地方放一个断点。你可以指定具体的异常也可以指定所有的异常。 怎样开启异常断点呢？ 1.工程切换到异常浏览窗口，点击下方左侧的Add Breakpoint按钮 2.选择Add Exception Breakpoint确保可以捕获所有异常。 捕获到异常效果如下: GDB命令来调试程序一般情况下，我们在程序代码中添加断点，是为了通过Xcode提供的variables view（该view在Xcode底部console旁边）来查看变量的状态。理论上，该窗口可以显示出与当前上下文相关的所有值的状态。实际上，这有点小问题，有时候断点过了之后，该窗口并不会进行相关的更新。但是Xcode有一个很不错的功能是：我们可以使用控制台的命令来检查某个特定的对象——这对于调试程序非常有用。 po 命令为print object的缩写，显示对象的文本描述（显示从对象的description消息获得的字符串信息，如果对象不存在的话会打印出nil） 处理scalar值时使用p 输出view的层级关系recursiveDescription由于该指令是私有API，所以不会智能提示。需要我们手打出来。 其它命令(help)123456789101112131415161718192021222324 命令 解释break NUM 在指定的行上设置断点。bt 显示所有的调用栈帧。该命令可用来显示函数的调用顺序。clear 删除设置在特定源文件、特定行上的断点。其用法为：clear FILENAME:NUM。continue 继续执行正在调试的程序。该命令用在程序由于处理信号或断点而导致停止运行时。display EXPR 每次程序停止后显示表达式的值。表达式由程序定义的变量组成。file FILE 装载指定的可执行文件进行调试。help NAME 显示指定命令的帮助信息。info break 显示当前断点清单，包括到达断点处的次数等。info files 显示被调试文件的详细信息。info func 显示所有的函数名称。info local 显示当函数中的局部变量信息。info prog 显示被调试程序的执行状态。info var 显示所有的全局和静态变量名称。kill 终止正被调试的程序。list 显示源代码段。make 在不退出 gdb 的情况下运行 make 工具。next 在不单步执行进入其他函数的情况下，向前执行一行源代码。print EXPR 显示表达式 EXPR 的值。print-object 打印一个对象print (int) name 打印一个类型print-object [artist description] 调用一个函数set artist = @\"test\" 设置变量值whatis 查看变理的数据类型 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"调试技巧","slug":"调试技巧","permalink":"superdanny.link/tags/调试技巧/"}]},{"title":"KVC/KVO原理详解及编程指南（转）","date":"2015-09-21T08:49:00.000Z","path":"2015/09/21/iOS-KVC:KVO/","text":"作者：wangzz 原文地址：KVC/KVO原理详解及编程指南 本文只转载KVC部分讲解，KVO部分可到原博客查看。 本人在阅读过程中也进行了一些勘误修改。 前言1、本文基本不讲KVC/KVO的用法，只结合网上的资料说说对这种技术的理解。 2、由于KVO内容较少，而且是以KVC为基础实现的，本文将着重介绍KVC部分。 一、简介KVC/KVO是观察者模式的一种实现，在Cocoa中是以被万物之源NSObject类实现的NSKeyValueCoding/NSKeyValueObserving非正式协议的形式被定义为基础框架的一部分。从协议的角度来说，KVC/KVO本质上是定义了一套让我们去遵守和实现的方法。当然，KVC/KVO实现的根本是Objective-C的动态性和runtime，这在后文的原理部分会有详述。另外，KVC/KVO机制离不开访问器方法的实现，这在后文中也有解释。 1、KVC简介全称是Key-value coding，翻译成键值编码。顾名思义，在某种程度上跟map的关系匪浅。它提供了一种使用字符串而不是访问器方法去访问一个对象实例变量的机制。 2、KVO简介全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。在MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。 二、KVC相关技术1、Key和Key PathKVC定义了一种按名称访问对象属性的机制，支持这种访问的主要方法是： 1234- (id)valueForKey:(NSString *)key;- (void)setValue:(id)value forKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;- (void)setValue:(id)value forKeyPath:(NSString *)keyPath; 前边两个方法用到的Key较容易理解，就是要访问的属性名称对应的字符串。 后面两个方法用到的KeyPath是一个被点操作符隔开的用于访问对象的指定属性的字符串序列。比如KeyPath address.street将会访问消息接收对象所包含的address属性中包含的一个street属性。 其实KeyPath说白了就是我们平时使用点操作访问某个对象的属性时所写的那个字符串。 2、点语法和KVC在实现了访问器方法的类中，使用点语法和KVC访问对象其实差别不大，二者可以任意混用。但是没有访问起方法的类中，点语法无法使用，这时KVC就有优势了。（ 原因见第三部分的第一节：KVC如何访问属性值。 ） 3、一对多关系（To-Many）中的集合访问器方法我们平时大部分使用的属性都是一对一关系（To-One）,比如Person类中的name属性，每个人只有一个名字。但也有一对多的关系，比如Person中有一个friendsName属性，这是个集合（在Objective-C中可以是NSArray，NSSet等），保存的是一个人的所有朋友的名字。当操作一对多的属性中的内容时，我们有两种选择： ①间接操作先通过KVC方法取到集合属性，然后通过集合属性操作集合中的元素。 ②直接操作苹果为我们提供了一些方法模板，我们可以以规定的格式实现这些方法来达到访问集合属性中元素的目的。 有序集合对应方法如下： 1234567891011121314151617-countOf&lt;Key&gt;//必须实现，对应于NSArray的基本方法count:-objectIn&lt;Key&gt;AtIndex:-&lt;key&gt;AtIndexes://这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:-get&lt;Key&gt;:range://不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObjects:range:-insertObject:in&lt;Key&gt;AtIndex:-insert&lt;Key&gt;:atIndexes://两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:-removeObjectFrom&lt;Key&gt;AtIndex:-remove&lt;Key&gt;AtIndexes://两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:-replaceObjectIn&lt;Key&gt;AtIndex:withObject:-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;://可选的，如果在此类操作上有性能问题，就需要考虑实现之 无序集合对应方法如下： 1234567891011121314151617-countOf&lt;Key&gt;//必须实现，对应于NSArray的基本方法count:-objectIn&lt;Key&gt;AtIndex:-&lt;key&gt;AtIndexes://这两个必须实现一个，对应于 NSArray 的方法 objectAtIndex: 和 objectsAtIndexes:-get&lt;Key&gt;:range://不是必须实现的，但实现后可以提高性能，其对应于 NSArray 方法 getObjects:range:-insertObject:in&lt;Key&gt;AtIndex:-insert&lt;Key&gt;:atIndexes://两个必须实现一个，类似于 NSMutableArray 的方法 insertObject:atIndex: 和 insertObjects:atIndexes:-removeObjectFrom&lt;Key&gt;AtIndex:-remove&lt;Key&gt;AtIndexes://两个必须实现一个，类似于 NSMutableArray 的方法 removeObjectAtIndex: 和 removeObjectsAtIndexes:-replaceObjectIn&lt;Key&gt;AtIndex:withObject:-replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;://这两个都是可选的，如果在此类操作上有性能问题，就需要考虑实现之 不过这些方法除非是很有需求，否则个人认为没有实现的必要，间接法也不是很麻烦，基本能满足需求了。值得指出的是，苹果甚至都没有让这些方法以哪怕是非正式协议的形式出现，而只是在编程指南中提了一下。 4、键值验证（Key-Value Validation）KVC提供了验证Key对应的Value是否可用的方法： 1- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError; 该方法默认的实现是调用一个如下格式的方法： 1- (BOOL)validate&lt;Key&gt;:error: 比如属性name对应的方法为： 1234- (BOOL)validateName:(id *)ioValue error:(NSError * __autoreleasing *)outError &#123; // Implementation specific code. return ...;&#125; 这样就给了我们一次纠错的机会。需要指出的是，KVC是不会自动调用键值验证方法的，就是说我们需要手动验证。但是有些技术，比如CoreData会自动调用。 5、KVC对数值和结构体型属性的支持一套机制如果不支持数值和结构体型的数据，那么它的实用性就会大大折扣。幸运的是KVC中苹果对这方面的支持做的很好。KVC可以自动的将数值或结构体型的数据打包或解包成NSNumber或NSValue对象，以达到适配的目的。举个例子，Person类有个NSInteger类型的age属性 ①修改值我们通过KVC技术使用如下方式设置age属性的值： 1[person setValue:[NSNumber numberWithInteger:5] forKey:@\"age\"]; 我们赋给age的是一个NSNumber对象，KVC会自动的将NSNumber对象转换成NSInteger对象，然后再调用相应的访问器方法设置age的值。 ②获取值同样，以如下方式获取age属性值： 1[person valueForKey:@\"age\"]; 这时，会以NSNumber的形式返回age的值。需要说明的是，什么时候返回的是NSNumber，什么时候返回的是NSValue？ ③使用NSNumber封装可以使用NSNumber的数据类型有： 123456789101112131415+ (NSNumber *)numberWithChar:(char)value;+ (NSNumber *)numberWithUnsignedChar:(unsigned char)value;+ (NSNumber *)numberWithShort:(short)value;+ (NSNumber *)numberWithUnsignedShort:(unsigned short)value;+ (NSNumber *)numberWithInt:(int)value;+ (NSNumber *)numberWithUnsignedInt:(unsigned int)value;+ (NSNumber *)numberWithLong:(long)value;+ (NSNumber *)numberWithUnsignedLong:(unsigned long)value;+ (NSNumber *)numberWithLongLong:(long long)value;+ (NSNumber *)numberWithUnsignedLongLong:(unsigned long long)value;+ (NSNumber *)numberWithFloat:(float)value;+ (NSNumber *)numberWithDouble:(double)value;+ (NSNumber *)numberWithBool:(BOOL)value;+ (NSNumber *)numberWithInteger:(NSInteger)value NS_AVAILABLE(10_5, 2_0);+ (NSNumber *)numberWithUnsignedInteger:(NSUInteger)value NS_AVAILABLE(10_5, 2_0); 总之就是一些常见的数值型数据。 ④使用NSValue封装NSValue主要用于处理结构体型的数据，它本身提供了如下几种结构的支持： 123456+ (NSValue *)valueWithCGPoint:(CGPoint)point;+ (NSValue *)valueWithCGSize:(CGSize)size;+ (NSValue *)valueWithCGRect:(CGRect)rect;+ (NSValue *)valueWithCGAffineTransform:(CGAffineTransform)transform;+ (NSValue *)valueWithUIEdgeInsets:(UIEdgeInsets)insets;+ (NSValue *)valueWithUIOffset:(UIOffset)insets NS_AVAILABLE_IOS(5_0); 只有有限的6种而已！那对于其它自定义的结构体怎么办？别担心，任何结构体都是可以转化成NSValue对象的，具体实现方法参见我之前的一篇文章：NSNumber和NSValue对基础C数据类型的对象化封装 6、集合运算符（Collection Operators）集合运算符是一个特殊的Key Path，可以作为参数传递给valueForKeyPath：方法，注意只能是这个方法，如果传给了valueForKey:方法保证你程序崩溃。运算符是一个以@开头的特殊字符串，格式如下图所示： ①简单集合运算符简单集合运算符共有@avg，@count，@max，@min，@sum5种，都表示啥不用我说了吧，目前还不支持自定义。有一个集合类的对象：transactions，它存储了一个个的Transaction类的实例，该类有三个属性：payee，amount，date。下面以此为例说明如何使用这些运算符： 要获取amount的平均值可以这样： 1NSNumber *transactionAverage = [transactions valueForKeyPath:@\"@avg.amount\"]; 要获取transactions集合中元素数目可以这样： 1NSNumber *numberOfTransactions = [transactions valueForKeyPath:@\"@count\"]; 需要之处的是，@count是这些集合运算符中比较特殊的一个，因为它没有右路经，原因很容易理解。 ②对象运算符比集合运算符稍微复杂，能以数组的方式返回指定的内容，一共有两种： @distinctUnionOfObjects @unionOfObjects 它们的返回值都是NSArray，区别是前者返回的元素都是唯一的，是去重以后的结果；后者返回的元素是全集。用法如下： 12NSArray *payees = [transactions valueForKeyPath:@\"@distinctUnionOfObjects.payee\"];NSArray *payees = [transactions valueForKeyPath:@\"@unionOfObjects.payee\"]; 前者会将收款人的姓名去除重复的以后返回，后者直接返回所有收款人的姓名。 ③Array和Set操作符这种情况更复杂了，说的是集合中包含集合的情况，我们执行了如下的一段代码： 12345678// Create the array that contains additional arrays.self.arrayOfTransactionsArray = [NSMutableArray array]; // Add the array of objects used in the above examples.[arrayOfTransactionsArray addObject:transactions]; // Add a second array of objects; this array contains alternate values.[arrayOfTransactionsArrays addObject:moreTransactions]; 得到了一个包含集合的集合：arrayOfTransactionsArray这时如果我们想操作arrayOfTransactionsArray中包含的集合中的元素时，可以使用如下三个运算符： @distinctUnionOfArrays @unionOfArrays @distinctUnionOfSets 前两个针对的集合是Arrays，后一个针对的集合是Sets。因为Sets中的元素本身就是唯一的，所以没有对应的@unionOfSets运算符。它们的用法举例如下： 1NSArray *payees = [arrayOfTransactionsArrays valueForKeyPath:@\"@unionOfArrays.payee\"]; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"KVC","slug":"KVC","permalink":"superdanny.link/tags/KVC/"},{"name":"KVO","slug":"KVO","permalink":"superdanny.link/tags/KVO/"}]},{"title":"提高iOS开发效率的方法和工具（转）","date":"2015-09-19T11:19:00.000Z","path":"2015/09/19/Improve-the-efficiency-of-iOS-development/","text":"转载作者@__weak_Point部分内容并作出自己认为更加高效率的方式 介绍这篇文章主要是介绍一下我在iOS开发中使用到的一些可以提升开发效率的方法和工具。 IDE首先要说的肯定是IDE了，说到IDE，Xcode不能跑，当然你也可能同时在使用AppCode等其他的IDE，在这里我主要介绍Xcode中提升开发效率的方法。 1.善用快捷键 快捷键是开发中必不可少的，当你善于使用快捷键的时候，十指在键盘上飞舞，那画面太美，我不敢想象。 常用快捷键操作 2.常用代码片段 开发中有一些常用的代码，可以放到代码片段中，然后下次你就可以使用快捷方法来使用这些代码了，给大家看下我的Xcode中部分代码片段: 偷懒小技巧 3.Xcode插件 我想插件是Xcode必不可少的把 那些不能错过的Xcode插件 除此之外，我自己还经常用到的插件有： 1.快速Add #import 2.查看项目的’TODO’,’FIXME’等 个人使用工具： 类似的快速Add #import 4.注释 注释的作用就不多说了，而且现在公司都要求代码必须有注释。 之前一直在用喵神onevcat开源的VVDocumenter-Xcode. 但是后来觉得这种注释会有这样一个问题：一个注释多三行 1234/** * 顶部公告btn */@property (nonatomic, strong) UIButton *topAnnouncementBtn; 接口用这种方法会简单明了，但是属性的话，总感觉.h文件好多东西 个人处理方式： 对于方法注释可以用多行形式，对于属性注释可在属性前使用格式///这是注释即可 网络数据相关1.调试接口 少年，你还在写方法调试接口吗？如果是，那你一定需要下面这2个了哈: DHC在线调试接口，支持HTTP和HTTPS呦。 注意点：需要到谷歌商店安装DHC扩展程序 2.JSON数据编辑 个人使用工具：谷歌JSON-handle插件 UI相关1.距离 不行！说的是20px！差1px，2px，5px，10px，都不算20px！ 遇到有像素眼的设计师，想哭的心情总是有。但是他们可能有时候会忘记标X、Y，或者就是宽高，下面是我司UI给的一张图： 魂淡，说好的X，Y呢？ 然后我最开始是这样做的 可是总会有辣么一点误差，而且费眼。。。后来我偶然听一个产品朋友说他们在用马克鳗标图，它有免费和收费2个版本，免费版本可以使用基本功能，感觉还不错。 今天喵神onevcat在微博发了一个测量的工具：Pixel Winch,试了一下，比马克鳗好使。 2.图片压缩 我们UI就不太注重图片的大小，尼玛，有一次给的图片有4M多，害我自己还得压缩一遍 TinyPNG，保质压缩，我感觉还不错，推荐给我们UI和后台，他们用过之后都说好。 GGTinypng批量压缩图片脚本配套使用更佳。(感谢newbee_nAn 提供) 3.AppIcon AppIcon只需要UI提供一张1024*1024的图就可以了，具体的icon可以用Prepo生成 个人使用工具： 本人使用Xcode插件-RTImageAssets进行图片批量管理 可实现提供@3x三倍图自动生成两倍图 可实现提供一张1024*1024图自动生成其他规格icon 上述功能不仅实现图片批量管理，而且会在Xcode中帮我们设置好 未完待续…… 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"工具","slug":"工具","permalink":"superdanny.link/tags/工具/"}]},{"title":"brew更新镜像源进行update","date":"2015-09-19T10:21:00.000Z","path":"2015/09/19/Brew-instruction/","text":"问题Homebrew是OS X上类似APT(apt-get)、Yum的一个软件包管理器。所以，虽然你侥幸下载到了brew，但你肯定是无法更新brew的。原因你懂。不过虽然不能更新brew，但这只是指brew这个管理器本身罢了，软件还是可以安装的。但由于无法使用brew update也就无法更新软件。我们有必要来给brew换源。 推荐镜像源Coding推出了Brew国内镜像源，速度挺快的。 12$ cd /usr/local &amp;&amp; git remote set-url origin https://git.coding.net/homebrew/homebrew.git$ cd $home &amp;&amp; brew update 解决123456cd /usr/local//清华镜像源git remote set-url origin git://mirrors.tuna.tsinghua.edu.cn/homebrew.git//中科大镜像源git remote set-url origin http://mirrors.ustc.edu.cn/homebrew.git//三者选其一即可更新 如果速度还是很慢，可以尝试以下操作： 123456789cd ~/tmp//以下两个选一个(要与你之前选择的镜像源相同)git clone git://mirrors.tuna.tsinghua.edu.cn/homebrew.gitgit clone http://mirrors.ustc.edu.cn/homebrew.gitrm -rf /usr/local/.gitrm -rf /usr/local/Librarycp -R homebrew/.git /usr/local/cp -R homebrew/Library /usr/local/ 然后重试brew update 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"superdanny.link/tags/Homebrew/"},{"name":"brew","slug":"brew","permalink":"superdanny.link/tags/brew/"}]},{"title":"企业级证书打包下载安装之后无法使用问题","date":"2015-09-18T07:42:00.000Z","path":"2015/09/18/iOS9-about-enterprise-certificate/","text":"问题今天发现使用企业级证书打包下载安装的APP都不能使用，弹窗提示未受信任的企业级开发者 按照以往的情况是弹窗提示信息并且有信任按钮提供选择，现在没有，只有一个取消按钮。 解决难道iOS9之后就不能使用企业级证书进行使用吗？答案当然是NO。 到底授权信任到哪里去了？其实授权在设置里面。 打开设置-通用-描述文件 在里面选择对应的描述文件，如下图 进入里面对描述文件进行授权信任就可以了，步骤如下图 噩耗对于那些通过企业证书做分布的人员来说这是一个噩耗，比如一些手机助手软件。因为普通用户根本不知道如何操作。 临时方案目前我想到的方式 在下载页面事先提示用户如何操作 仿照手机助手应用事先让用户安装描述文件 如果你有其他的技巧，还请不吝啬的分享给大家，共同进步！ 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"iOS9","slug":"iOS9","permalink":"superdanny.link/tags/iOS9/"},{"name":"In-House","slug":"In-House","permalink":"superdanny.link/tags/In-House/"},{"name":"企业级证书打包","slug":"企业级证书打包","permalink":"superdanny.link/tags/企业级证书打包/"}]},{"title":"关于开发中遇到问题处理思路","date":"2015-09-18T05:56:00.000Z","path":"2015/09/18/Development-solutions/","text":"问题当 Apple 推出新版本 Xcode 的时候，编译旧工程有时候会导致一些旧工程无法成功编译，或者成功编译之后也会有各种问题。这里举例说明，并且如何临时避免。当然，我们还是要顺着 Apple 的要求来，临时性解决问题之后还要正面解决问题。 举一反三当你使用 Xcode6.4 打包工程一帆风顺，并且用户也可以安装使用。此时换成最新版的 Xcode7 进行打包，发现 APP 用不了了。 处理手段发现错误最重要是不要慌，人一慌就容易失常，手足无措。这个时候不要着急，需要冷静面对。心理自我暗示：不就是不能跑嘛，怕啥。只要是问题，就没有网络解决不了的。是的，我最崇尚有问题没法解决就借助网络(Google、Stack Overflow、Blog, etc)的力量，自己一个人喝闷酒既费时又费力，不但解决不了，还要被挨批。所以万事要冷静。 接下来是我的一些做法： 1、正确的处理方式 确认控制台是否有打印任何提示性信息，一般情况下原本可以运行的程序在高版本不能运行都会打印信息出来。所以我们根据信息排查，自己实在找不出原因，就寻求网络解决。 比如像昨天我发表的那篇iOS9中HTTP协议的变化就是其中一个，我们根据信息找到相应的解决方案。 2、临时处理方式 当出现像刚刚哪种情况的时候，我们如果急着使用，可以放大招。苹果推出每一个新版本的 Xcode 都是向下兼容的，所以一旦在高版本的 Xcode 跑不通，或者运行有问题时。 我们可以选择先用之前旧版本 Xcode 进行编译打包。这样可以使得安装包正常使用。但是这种方式不是永久的，因为随着 Xcode 版本的升高，对打包要求的编译器版本也会越来越高。 结束了？这只是其中遇到的一种情况，还有很多情况我没有一一列举，也等着我们去发掘补充。 如果你有其他的技巧或者开发过程中有好的应对方案，还请不吝分享给大家，共同进步！ 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"解决方式","slug":"解决方式","permalink":"superdanny.link/tags/解决方式/"}]},{"title":"解决Xcode真机调试提示“Could not find Developer Disk Image”","date":"2015-09-17T08:19:00.000Z","path":"2015/09/17/Could-not-find-Developer-Disk-Image/","text":"问题当你在新的Xcode版本上进行真机调试的时候，可能会出现Could not find Developer Disk Image的提示 出现这个问题的原因是新的Xcode本地目录里面没有对真机设备系统版本的支持。 解决 如果你有旧版本的Xcode，可以进入/Applications/Xcode(旧版本).app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport路径下将对应的系统版本拷贝 到目录/Applications/Xcode(新版本).app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport下，重新打开新版本的Xcode，clean一下，就可以继续快乐得真机调试了~ 希望有出现这种状况的D友们下次注意一下。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"真机调试","slug":"真机调试","permalink":"superdanny.link/tags/真机调试/"}]},{"title":"解决SVN提交代码出现目录过期问题","date":"2015-09-17T07:35:00.000Z","path":"2015/09/17/Fix-svn-directory-is-out-of-date/","text":"前言SVN(Subversion简称)是一个开源的版本控制系统，很多开发者都会用到它，但是使用不当会给你带来不必要的困扰，我就是其中一位，以前都是按照正确流程操作，后面使用久了，就会忽略掉一些使用细节，这也是导致问题出现的因素之一。 问题当你满怀激动的心情终于可以提交修改的代码时，SVN蹦出一条信息提示： Description : Commit failed (details follow):Status : 155011Description : Directory ‘/Users/superdanny/CompanyProject/OShoppingMerchant[支付平台商家版]/OShoppingMerchant/Images.xcassets/Source/placeholderImage1.imageset’ is out of dateStatus : 155011 Description : Item ‘/OShoppingMerchant[支付平台商家版]/OShoppingMerchant/Images.xcassets/Source/placeholderImage1.imageset’ is out of dateStatus : 170004 信息的意思是所在目录下的项目已经过期 解决其实这个问题是可以避免的，原因是由于我们平时没有养成代码提交顺序习惯。 一般代码的提交流程： 先从服务器update下最新的代码，然后再开始着手修改代码。 修改完代码之后再将代码commit到服务器 希望有出现这种状况的D友们下次注意一下。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"SVN","slug":"SVN","permalink":"superdanny.link/tags/SVN/"}]},{"title":"iOS9中HTTP协议的变化","date":"2015-09-17T06:09:00.000Z","path":"2015/09/17/iOS9-http-change/","text":"问题iOS9以后的http请求协议无法使用。 错误描述： App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app‘s Info.plist file. 原因由于iOS9中，苹果将原http协议改成了https协议，使用TLS1.2 SSL加密请求数据。 解决方案在info.plist文件加入key 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; 效果下图： 参考资料 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"iOS9","slug":"iOS9","permalink":"superdanny.link/tags/iOS9/"}]},{"title":"BUG记录","date":"2015-09-17T02:42:00.000Z","path":"2015/09/17/Bug-record/","text":"问题Assertion failure in -[UIApplication _runWithMainScene:transitionContext:completion:] 今天早上一大早升级了iOS9，满怀激动的心情来到公司。产品经理问我们的产品在iOS9上面会不会有问题。我说应该没问题吧。但是，事实并非如此。我将应用跑到手机上面时，奔溃的事情发生了，应用一打开就奔溃。这下蛋疼菊花紧了~赶紧排查……接下来就是找问题。应用奔溃的时候控制台打印出了可用信息： *** Assertion failure in -[UIApplication _runWithMainScene:transitionContext:completion:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3505.16/UIApplication.m:3294 经过一番查询，找到问题所在： do you still have: [window addSubview:viewController.view]; You should instead replace it with: [window setRootViewController:viewController]; 解决在代码中找到了原因，是由于应用程序在没有给UIWindow设置rootViewController的前提下使用了[self.window addSubview:waitingView];导致。 既然知道原因之后，就要修改。重新Run一下，Congratulation！成功进入程序。希望有出现这种状况的D友们下次注意一下。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"BUG","slug":"BUG","permalink":"superdanny.link/tags/BUG/"}]},{"title":"如何禁用/解除禁用 复制、剪切、选择、全选","date":"2015-09-16T05:31:00.000Z","path":"2015/09/16/iOS-Custom-UITextField-and-UITextView-function/","text":"需求希望能够屏蔽文本框的复制、粘贴等动能，或者在某些界面需要解除屏蔽功能。 解决方案我们需要重写canPerformAction:withSender:方法实现 代码1：禁用所有长按文本框操作 1234567#pragma mark - 禁用所有长按文本框操作- (BOOL)canPerformAction:(SEL)action withSender:(id)sender &#123; if ([UIMenuController sharedMenuController]) &#123; [UIMenuController sharedMenuController].menuVisible = NO; &#125; return NO;&#125; 代码2：禁用部分长按文本框操作 1234567891011121314#pragma mark - 禁用部分长按文本框操作- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; //禁用选择、全选、粘贴功能 //... if (action == @selector(paste:)) return NO; if (action == @selector(select:)) return NO; if (action == @selector(selectAll:)) return NO; //... return [super canPerformAction:action withSender:sender];&#125; 拓展：部分长按操作 - (void)cut:(nullable id)sender - (void)copy:(nullable id)sender - (void)paste:(nullable id)sender - (void)select:(nullable id)sender - (void)selectAll:(nullable id)sender - (void)delete:(nullable id)sender 分析、解决【情况1】：如果是屏蔽所有界面的UITextField/UITextView文本框，而UITextView/UITextField不改变 方法：我们可以给UITextField/UITextView的Category里面添加代码1/代码2 【情况2】：如果部分界面的文本框需要保留部分功能，可以通过自定义UITextField保留想要的功能。 DDTextField.h文件 12345#import &lt;UIKit/UIKit.h&gt;@interface DDTextField : UITextField@end DDTextField.m文件 1234567891011121314151617181920#import \"DDTextField.h\"@implementation DDTextField#pragma mark -- (BOOL)canPerformAction:(SEL)action withSender:(id)sender &#123; if (action == @selector(paste:)) return YES; if (action == @selector(cut:)) return YES; if (action == @selector(copy:)) return YES; if (action == @selector(select:)) return YES; if (action == @selector(selectAll:)) return YES; return NO;&#125;@end 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"长按文本框","slug":"长按文本框","permalink":"superdanny.link/tags/长按文本框/"}]},{"title":"MacOS X隐藏和显示隐藏文件","date":"2015-09-09T19:02:00.000Z","path":"2015/09/10/MacOSX-show-and-hide-file/","text":"在osx里，.开头的文件会被自动隐藏的，但是如果想要显示所有隐藏文件怎么办呢？对于新手而言，苹果的MAC操作系统刚用时用得很不习惯，比如想要显示被隐藏的文件时，不像windows有个文件夹选项对话框可以来设置。方法有很多种，这里列举三种方法进行选择。 通过终端指令 通过终端执行sh文件 通过软件 通过终端指令打开终端输入下面的命令显示：defaults write com.apple.finder AppleShowAllFiles -bool true隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false 通过终端执行sh文件打开终端输入下面的命令显示：sh showallfiles.sh隐藏：sh hideallfiles.sh 下载sh文件：sh.zip 通过软件每次敲命令也是比较繁琐的这里有个小工具有界面哦，如图下载工具：SuperDanny.zip 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"文件操作","slug":"文件操作","permalink":"superdanny.link/tags/文件操作/"},{"name":"Mac","slug":"Mac","permalink":"superdanny.link/tags/Mac/"}]},{"title":"GitHub无法访问或访问缓慢解决办法","date":"2015-09-09T15:16:00.000Z","path":"2015/09/09/Quickly-access-github/","text":"缘由由于众所周知的原因，Github最近无法访问或访问很慢。由于Github支持https，因此此次屏蔽Github采用的方法是dns污染，用户访问github会返回一个错误的IP翻墙当然是一种解决办法了，但总感觉不是很爽 临时解决办法在终端执行指令sudo vi /etc/hosts打开hosts文件进行编辑插入如下内容，保存退出即可！ 12345678910# github204.232.175.78 http://documentcloud.github.com207.97.227.239 http://github.com204.232.175.94 http://gist.github.com107.21.116.220 http://help.github.com207.97.227.252 http://nodeload.github.com199.27.76.130 http://raw.github.com107.22.3.110 http://status.github.com204.232.175.78 http://training.github.com207.97.227.243 http://www.github.com 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Mac","slug":"Mac","permalink":"superdanny.link/tags/Mac/"},{"name":"GitHub","slug":"GitHub","permalink":"superdanny.link/tags/GitHub/"}]},{"title":"自动打包Shell脚本","date":"2015-09-09T12:21:00.000Z","path":"2015/09/09/Using-shell-script-to-automatic-packaging/","text":"简介iOS应用自动化打包，可以给开发者带来无穷的便利。节省了不少时间。 作者Bruce的脚本，放到Github BashShell上了 另外Bryce Zhang童鞋总结了一篇:传送门 Build+DeployToFir.sh和XcodeBuild+Install.sh相比，Build+DeployToFir.sh不需要手动配置那么多东西了，修正优化了部分地方。打包后上传到fir.im，会更新记录,注意更新记录读取自项目根目录下的README里如果你项目下面没得README这个文件，加上或改84行吧,还有记得修改curl -X PUT --data &quot;changelog=$changelog&quot; http://fir.im/api/v2/app/54c0a98d627b6443070000cb?token=tokenvalue里的tokenvalue，去fir申请一个 sendemail目录发邮件用的python，mac自带就装好了python环境的，在目录sendemail里，已经做了脱敏处理，所以你要使用请按下面的说明修改。build+send.sh: 调打包和发邮件的脚本，注意修改第7行path=~/work/projectname/路径。我是放在~/xcodebuild/sendemail下的，如果不是，自己注意改脚本里的路径。myconfig：修改username和passwd，如果你也是qq企业邮箱smtp等就不用改了，否则修改。toEmailAddress：要发给哪些人，一行一个update.txt：发邮件的时候邮件里的内容 XcodeBuild+Install.sh1.xcode命令行编译生成ipa包，打包相关的Log都输出到~/xcodebuild目录2.生成plist文件和html下载页面配置好工程路径，url就可一键打包啦! fixInfoPlistConfict.sh解决Info.plist冲突,注意Info.plist文件的路径 fixPbxprojConfict.sh解决工程文件冲突project.pbxproj updateBuildVersion.sh提取git提交号作为build version，并更新 Date.sh此文件是和date相关的函数 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"Shell","slug":"Shell","permalink":"superdanny.link/tags/Shell/"}]},{"title":"银行卡合法性校验","date":"2015-09-09T12:13:00.000Z","path":"2015/09/09/iOS-Verifying-the-legitimacy-of-the-bank-card/","text":"Luhn检验数字算法（Luhn Check Digit Algorithm），也叫做模数10公式，是一种简单的算法，用于验证银行卡、信用卡号码的有效性的算法。对所有大型信用卡公司发行的信用卡都起作用，这些公司包括美国Express、护照、万事达卡、Discover和用餐者俱乐部等。这种算法最初是在20世纪60年代由一组数学家制定，现在Luhn检验数字算法属于大众，任何人都可以使用它。算法：将每个奇数加倍和使它变为单个的数字，如果必要的话通过减去9和在每个偶数上加上这些值。如果此卡要有效，那么，结果必须是10的倍数。 使用如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//剔除卡号里的非法字符-(NSString *)getDigitsOnly:(NSString*)s&#123; NSString *digitsOnly = @\"\"; char c; for (int i = 0; i &lt; s.length; i++) &#123; c = [s characterAtIndex:i]; if (isdigit(c)) &#123; digitsOnly =[digitsOnly stringByAppendingFormat:@\"%c\",c]; &#125; &#125; return digitsOnly;&#125;//检查银行卡是否合法//Luhn算法-(BOOL)isValidCardNumber:(NSString *)cardNumber&#123; NSString *digitsOnly = [self getDigitsOnly:cardNumber]; int sum = 0; int digit = 0; int addend = 0; BOOL timesTwo = false; for (int i = digitsOnly.length - 1; i &gt;= 0; i--) &#123; digit = [digitsOnly characterAtIndex:i] - '0'; if (timesTwo) &#123; addend = digit * 2; if (addend &gt; 9) &#123; addend -= 9; &#125; &#125; else &#123; addend = digit; &#125; sum += addend; timesTwo = !timesTwo; &#125; int modulus = sum % 10; return modulus == 0;&#125; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"银行卡校验","slug":"银行卡校验","permalink":"superdanny.link/tags/银行卡校验/"}]},{"title":"字典数组、对象数组排序以及分组","date":"2015-09-06T16:21:00.000Z","path":"2015/09/07/iOS-Array-sorting-and-grouping/","text":"简单排序 利用block语法进行排序 高级排序 拓展-分组问题 Objective-C对数据的操作可谓是非常用心，早已经封装好了很多方法等着我们去挖掘。其中对排序就是其中之一。本文是基于前人的基础上进行完善和加上自己的一些见解。 123456//NSComparisonResult类型结果typedef NS_ENUM(NSInteger, NSComparisonResult) &#123; NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending&#125;; 简单排序sortedArrayUsingSelector:通过指定方法对数组元素进行排序。有一点需要记住，就是不管你自定义的方法是什么，都必须最后返回一个NSComparisonResult类型用于决定元素的排列原则。一般用于对字符串数组进行排序，因为字符串有自带的对比方法compare:。如果想对其他类型元素的数组进行排序就需要我们自己自定义排序方法。例如： 123NSArray *array = @[@\"abc\",@\"456\",@\"123\",@\"789\",@\"ef\"];NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(compare:)];NSLog(@\"排序后:%@\",sortedArray); 利用block语法进行排序sortedArrayUsingComparator: 假如我们有一个存储了NSDate类型的数组需要进行排序，那么我们可以通过compare:方法进行排序。或者如果想自定义排序原则也可以使用如下方式： 1234567891011121314NSArray *sortedArray = [array sortedArrayUsingComparator:^NSComparisonResult(NSDate *obj1, NSDate *obj2) &#123; if ([date1 timeIntervalSinceDate:date2] &lt; 0) &#123; return NSOrderedDescending; &#125; if ([date1 timeIntervalSinceDate:date2] &gt; 0) &#123; return NSOrderedAscending; &#125; return NSOrderedSame; //或者使用compare:进行排序// NSComparisonResult result = [date1 compare:date2];// return result; &#125;];NSLog(@\"排序后:%@\",sortedArray); 假如我们有一个存储了NSDate类型的数组需要进行排序，那么我们可以通过此方法进行排序。 12345678910NSArray *sortedArray = [array sortedArrayUsingComparator:^NSComparisonResult(NSDate * date1, NSDate * date2) &#123; if ([date1 timeIntervalSinceDate:date2] &lt; 0) &#123; return NSOrderedDescending; &#125; if ([date1 timeIntervalSinceDate:date2] &gt; 0) &#123; return NSOrderedAscending; &#125; return NSOrderedSame;&#125;];NSLog(@\"排序后:%@\",sortedArray); 高级排序sortedArrayUsingDescriptors: &amp; sortUsingDescriptors:前者带返回值，是NSArray的方法，返回值中的数组是排好序的数组后者不带返回值，是NSMutableArray的方法，是对当前数组自己排序 该方法是根据用户的描述器（Descriptor）进行排序。可能这样说有点抽象，我们直接上代码解释： 假设我们有Person类，Car类。需要对Person进行特定条件的排序，排序的原则就是优先根据姓名排序，用户名相同时，再根据年龄排序，年龄也相同时，再按照车进行排序。 Car类 1234567891011121314151617181920Car.h文件@interface Car : NSObject@property (nonatomic, copy) NSString *name;+ (Car *)initWithName:(NSString *)name;@endCar.m文件#import \"Car.h\"@implementation Car + (Car *)initWithName:(NSString *)name &#123; Car *car = [Car alloc] init]; car.name = name; return car;&#125; @end Person类 1234567891011121314151617181920212223Person.h文件@interface Person : NSObject@property (nonatomic, copy ) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, strong) Car *car;+ (Person *)personWithAge:(int)age withName:(NSString *)name withCar:(Car *)car;@endPerson.m文件#import \"Person.h\"#import \"Car.h\"@implementation Person + (Person *)personWithAge:(int)age withName:(NSString *)name withCar:(Car *)car &#123; Person *person = [[Person alloc] init]; person.age = age; person.name = name; person.car = car; return person;&#125; 排序方法的实现 123456789101112131415161718192021222324252627282930313233343536//首先来3辆车，分别是奥迪、劳斯莱斯、宝马Car *car1 = [Car initWithName:@\"Audio\"];Car *car2 = [Car initWithName:@\"Rolls-Royce\"];Car *car3 = [Car initWithName:@\"BMW\"];//再来5个Person，每人送辆车，分别为car2、car1、car1、car3、car2Person *p1 = [Person personWithAge:20 withName:@\"Danny\" withCar:car2];Person *p2 = [Person personWithAge:21 withName:@\"Kevin\" withCar:car1];Person *p3 = [Person personWithAge:24 withName:@\"Maggie\" withCar:car1];Person *p4 = [Person personWithAge:23 withName:@\"Danny\" withCar:car3];Person *p5 = [Person personWithAge:23 withName:@\"LvChanghui\" withCar:car2];//加入数组NSArray *array = @[p1,p2,p3,p4,p5];//构建排序描述器,这里很类似KVO的读取属性的方法，直接从字符串读取对象属性，注意不要写错NSSortDescriptor *carNameDesc = [NSSortDescriptor sortDescriptorWithKey:@\"car.name\" ascending:YES];NSSortDescriptor *personNameDesc = [NSSortDescriptor sortDescriptorWithKey:@\"name\" ascending:YES];NSSortDescriptor *personAgeDesc = [NSSortDescriptor sortDescriptorWithKey:@\"age\" ascending:YES];//把排序描述器放进数组里，放入的顺序就是你想要排序的顺序//这里是：首先按照姓名，然后是年龄排序，最后是按照车的名字NSArray *descriptorArray = @[personNameDesc,personAgeDesc,carNameDesc];NSArray *sortedArray = [array sortedArrayUsingDescriptors: descriptorArray];NSLog(@\"%@\",sortedArray);//如果是可变数组，则使用sortUsingDescriptors:NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:@[p1,p2,p3,p4,p5]];[mutableArray sortUsingDescriptors:[NSArray arrayWithObject:sortDescriptor]];//此时mutableArray已经排好顺序NSLog(@\"%@\",mutableArray); 拓展-分组问题假如我们需要对字典(或对象)数组里面，根据字典（或对象）元素的某个键值（或属性）进行分组。分组的思路无非就是将某个键值（或属性）相同的字典（或对象）放在一起。那么如何做到快速分组呢？这里就要引入一个新的类型NSMutableSet、NSSet 该类型具有无序的，不重复的特性（保证数据的唯一性）。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表。 例如：有一个Model类，需要根据Model里面的exchangeShortTime字段进行分组 Model类 12345@interface Model : NSObject@property (nonatomic, copy) NSString *exchangeShortTime;@end 分组的实现 1234567891011121314151617181920- (void)groupAction:(NSMutableArray *)arr &#123; //arr里面存储着多个model对象，现在我们根据model中的exchangeShortTime字段进行分组 NSMutableSet *set = [NSMutableSet set]; //利用set不重复的特性,得到有多少组,根据model中的exchangeShortTime字段 [arr enumerateObjectsUsingBlock:^(Model * _Nonnull model, NSUInteger idx, BOOL * _Nonnull stop) &#123; [set addObject:model.exchangeShortTime]; &#125;]; /*此时，set里面已经存储了可以分为组数*/ //接下来需要用到NSPredicate语法进行筛选 __block NSMutableArray *groupArr = [NSMutableArray array]; [set enumerateObjectsUsingBlock:^(NSString * _Nonnull exchangeShortTime, BOOL * _Nonnull stop) &#123; NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"exchangeShortTime = %@\", exchangeShortTime]; NSArray *tempArr = [NSArray arrayWithArray:[arr filteredArrayUsingPredicate:predicate]]; [groupArr addObject:tempArr]; &#125;];&#125; 大功告成！排序分组就讲到这里。如果后面还有更多相关知识点会补充上。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"一天一道面试题","date":"2015-09-06T07:16:00.000Z","path":"2015/09/06/Interview-questions/","text":"一直想找一个平台来整理、收集面试题，但是却毫无头绪，现在有了个人博客，就可以将一些知识点以及面试题整理出来，以后自己可以当做学习复习用。 为什么要整理面试题整理面试题的好处在于更加有条理的梳理巩固知识，不对导致盲目学习。已达到较快速度的掌握一门语言（知识）。 面试题来源本人会将自己看过的，以及别人整理过的面试题都整理出来。当然，如果你有好的面试题或者对已有的面试题有更好的答案，可以留言，或者Q我，我会非常高兴。 面试题1、delegate和notification什么区别，什么情况使用？Delegate消息的发送者(sender)告知接收者(receiver)某个事件将要发生，delegate同意然然后发送者响应事件，delegate机制使得接收者可以改变发送者的行为。通常发送者和接收者的关系是直接的一对多的关系。Notification消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系。 2、什么是MVC，为什么使用MVC，有什么好处？分别为：模型（Model），视图（View）和控制（Controller） 模型（Model）“数据模型”（Model）用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“模型”有对数据直接访问的权力，例如对数据库的访问。 视图（View）视图层能够实现数据有目的显示。 控制器（Controller）控制器起到不同层面间的组织作用，用于控制应用程序的流程。 3、同步请求和异步请求什么区别？发送同步请求，程序将停止用户交互，直至服务器返回数据完成，才可以进行下一步操作，异步请求不会阻塞主线程，而会建立一个新的线程来操作，用户发出异步请求后，依然可以对UI进行操作，程序可以继续运行。 4、UIViewController的生命周期当一个视图控制器被创建，并在屏幕上显示的时候。代码的执行顺序：// 视图显示在屏幕上的顺序1、alloc创建对象，分配空间。2、init (initWithNibName)初始化对象，初始化数据。3、loadView从nib载入视图，这一步不需要去干涉。除非没有使用xib文件创建视图。4、viewDidLoad加载完毕，可以进行自定义数据以及动态创建其他控件。5、viewWillAppear视图将出现在屏幕之前，马上这个视图即将显示在屏幕上。6、viewDidAppear视图已在屏幕上渲染完成。 // 视图将被从屏幕上移除的顺序1、viewWillDisappear视图将被从屏幕上移除之前执行。2、viewDidDisappear视图已经被从屏幕上移除。3、dealloc视图被销毁，此时需要在init和viewDidLoad中创建的对象进行释放。4、viewDidUnload出现内存警告在内存不足时执行，并对所有非当前显示的controller执行。本视图的所有子视图将被销毁，以释放内存，此时开发者需要手动对viewLoad、viewDidLoad中创建的对象释放内存。因为当这个视图再次显示在屏幕上的时候，viewLoad、viewDidLoad 再次被调用，以便再次构造视图。 5、iOS数据持久化方式属性列表、对象归档、SQLite3和Core Data 6、Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？Objective-C的类不可以多重继承；可以实现多个接口，通过实现多个接口可以完成C++的多重继承；Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。 7、#import跟#include有什么区别，@class呢，＃import&lt;&gt;跟 #import””有什么区别？#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once；@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含；#import&lt;&gt;用来包含系统的头文件，#import&quot;&quot;用来包含用户头文件。 8、定义属性时，什么情况使用copy、assign、retain？assign用于简单数据类型，如NSInteger,double,bool等；retain和copy用于对象，copy用于当a指向一个对象，b也想指向同样的对象的时候，如果用assign，a如果释放，再调用b会crash,如果用copy的方式，a和b各自有自己的内存，就可以解决这个问题。retain 会使计数器加一，也可以解决assign的问题。 9、浅拷贝和深拷贝区别是什么？浅拷贝：只复制指向对象的指针，而不复制引用对象本身。深拷贝：复制引用对象本身。 10、类别的作用？继承和类别在实现中有何区别？category可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。类别主要有3个作用：(1)将类的实现分散到多个不同文件或多个不同框架中。(2)创建对私有方法的前向引用。(3)向对象添加非正式协议。继承可以增加，修改或者删除方法，并且可以增加属性。 11、消息传递原理？12、如何为Class 定义一个对外只读对内可读写的属性？方案一：在.h头文件中定义一个属性对外是readonly的，但在类的内部希望是可读写的，所以可以在.m源文件中的@interface部分重新定义此属性为readwrite，此时此属性对外是只读的，对内是读写的。 123456789101112// .h文件@interface MyObject : NSObject@property (readonly, copy) NSString *language;@end// .m文件@interface MyObject ()@property (readwrite, copy) NSString *language;@end@implementation MyObject@end 问题补充区9.1 对深浅拷贝的一些补充【情景】 A视图将数组a_Arr传递给B视图的数组b_Arr。B视图对数组b_Arr进行了数据修改之类的操作。会导致A视图的数组a_Arr数据也跟着改变。使用如下代码： 123// NSArray直接调用copy和mutableCopy是无法解决问题的VC_B *B = [[VC_B alloc] init];B.b_Arr = [a_Arr mutableCopy]; 【原因分析】 调用copy和mutableCopy只对于数组本身有效，数组里面对象的指针（内存地址）是不变的。一旦修改数组里面对象的数据，原始数组的对象也会跟着改变。所以如果在进行数据传递的时候需要在下一级或者其他视图对传递的数据进行数据变更的时候。我们应该这样操作： 12VC_B *B = [[VC_B alloc] init];B.b_Arr = [[NSMutableArray alloc] initWithArray:a_Arr copyItems:YES]; 使用initWithArray:copyItems:方法，不仅仅将数组进行时深拷贝，也将数组里面的每一个对象都进行深拷贝，避免视图B对传递的数据进行修改导致数据不对应。如果数组里面是自定义对象，还需要对象实现NSCopying协议。 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"面试","slug":"面试","permalink":"superdanny.link/tags/面试/"}]},{"title":"Xcode上Version和Build","date":"2015-09-05T08:55:00.000Z","path":"2015/09/05/Xcode-Version-and-Build/","text":"Version（应用程序发布版本号） Build（应用程序内部标示） 作用 高效率开发技巧 Version（应用程序发布版本号）对应的就是CFBundleShortVersionString。该版本的版本号是三个时期分隔的整数组成的字符串：第一个整数代表重大修改的版本，如实现新的功能或重大变化的修订。第二个整数表示的修订，实现较突出的特点。第三个整数代表维护版本。该键的值不同于CFBundleVersion标识。 版本号的管理是一个谨慎的事情，希望各位开发者了解其中的意义。如当前上架版本为1.1.0，之后你更新的时候可以改为1.1.1 Build（应用程序内部标示）对应的是CFBundleVersion。标识（发布或未发布）的内部版本号。用以记录开发版本的，每次更新的时候都需要比上一次高。如：当前版本是11，下一次就要大于11。比如12，13，etc 作用 比如团队打算发布1.0版本的时候，会发布很多build版本供测试或QA团队进行测试，你发布了很多build，因为一直在修改着代码，因此当你收到一条bug信息时候，你怎么知道是哪个build引起的问题呢，这时候build版本号的优点就可以体现出来了。 高效率开发技巧在Xcode编译时候自动增加build号码，先把 Info.plist 里的版本号改成某个数字，然后 Targets → your target → Build Phases → Run Script 的地方加上： 1234#!/bin/bashbuildNumber=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$INFOPLIST_FILE&quot;)buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion $buildNumber&quot; &quot;$INFOPLIST_FILE&quot; 效果如下： 如果没有找到Run Script选项，只需要New一个就行，如下图： 下面这行代码会让Version也自增，一般不需要 /usr/libexec/PlistBuddy -c &quot;Set :CFBundleShortVersionString $version&quot; $PRODUCT_SETTINGS_PATH 另外推荐TraWor写的另外一篇文章浅谈 iOS 版本号 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"UITableView数据更新问题","date":"2015-09-01T10:07:00.000Z","path":"2015/09/01/iOS-UITableView-update-data/","text":"自身遇到问题 拓展-进行增删数据时的注意点 beginUpdates方法和endUpdates方法是什么呢？ 一般什么时候使用这么一个动画块呢？ 插入指定的行 插入分组到制定位置 删除制定位置的分组 移动分组 问答区 自身遇到问题今天在设计自定义UITableViewCell的时候遇到一个愚蠢的问题，就是当用户在Cell上面使用自定义按钮触发删除时，为了保证删除时有动画效果，所以不能在执行deleteRowsAtIndexPaths: withRowAnimation:之后手动执行reloadData。这样就有一个问题，由于不执行reloadData，我们需要获取到Cell最新的indexPath就遇到问题 解决方案：通过获取按钮所在的Cell的indexPath解决 方式一： 12345678910111213141516171819- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; AMDeleteCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier forIndexPath:indexPath]; [cell setDeleteBlock:^(NSDictionary *dic, AMDeleteCell *cell) &#123; //UITableViewCellContentView UIView *v = [sender superview]; //UITableViewCell UITableViewCell *cell = (UITableViewCell*)[v superview]; NSIndexPath *indexPath = [tableView indexPathForCell:cell]; self.deleteIndexPath = indexPath; &#125;]; return cell;&#125; 方式二(个人认为比较好的一种方式)： 123456789101112131415- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; AMDeleteCell *cell = [tableView dequeueReusableCellWithIdentifier:identifier forIndexPath:indexPath]; [cell setDeleteBlock:^(NSDictionary *dic, AMDeleteCell *cell) &#123; NSIndexPath *indexPath = [tableView indexPathForCell:cell]; self.deleteIndexPath = indexPath; &#125;]; return cell;&#125; 自定义Cell内部部分代码： 1234567891011121314151617181920212223242526272829303132#import \"AMDeleteCell.h\"typedef void(^DeleteCellBlock)(NSDictionary *dic, AMDeleteCell *cell);@interface AMDeleteCell ()@property (strong, nonatomic) UIButton *deleteBtn;@property (strong, nonatomic) NSDictionary *dataDic;@property (copy, nonatomic ) DeleteCellBlock block;@end@implementation AMDeleteCell//…省略部分代码...- (void)setDeleteBlock:(void (^)(NSDictionary *, AMDeleteCell *))block &#123; self.block = block;&#125;#pragma mark - Cell上面按钮触发的方法- (void)deleteAction:(UIButton *)sender &#123; if (_block) &#123; _block(_dataDic, self); &#125;&#125;//...省略部分代码...@end 拓展-进行增删数据时的注意点1、普通形式（UITableViewStylePlain）数据增删 将tableView进行增删时需要先更新数据源，然后再执行delete/insert操作 2、分组形式（UITableViewStyleGrouped）数据增删 如果我们的UITableView是UITableViewStyleGrouped的时候，我们如果删除某个Group的最后一条记录时，相应的分组也将被删除。所以，必须保证UITableView的分组，和Cell同时被删除。所以，就需要使用beginUpdates方法和endUpdates方法，将要做的删除操作“包”起来！ beginUpdates方法和endUpdates方法是什么呢？ 这两个方法，是配合起来使用的，标记了一个tableView的动画块。 分别代表动画的开始和结束。两者成对出现，可以嵌套使用。 一般，在添加、删除、选择tableView中使用，并实现动画效果。 在动画块内，不建议使用reloadData方法，如果使用，会影响动画 一般什么时候使用这么一个动画块呢？一般在UITableView执行：删除行，插入行，删除分组，插入分组时使用！用来协调UITableView的动画效果。 插入指定的行在执行该方法时，会对数据源进行访问（分组数据和行数据），并更新可见行。所以，在调用该方法前，应该先更新数据源 12- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation 插入分组到制定位置插入一个特定的分组。如果，指定的位置上已经存在了分组，那么原来的分组向后移动一个位置。 12- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation 删除制定位置的分组删除一个制定位置的分组，其后面的分组向前移动一个位置。 12- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation 移动分组移动原来的分组从一个位置移动到一个新的位置。如果，新位置上若存在某个分组，那这某个分组将会向上（下）移动到临近一个位置。该方法，没有动画参数。会直接移动。并且一次只能移动一个分组。 12- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection 在如上方法中，建议使用该动画块进行操作！ 问答区 为什么block属性使用copy修饰？答：Block属性的声明，首先需要用copy修饰符，因为只有copy后的Block才会在堆中，栈中的Block的生命周期是和栈绑定的。ARC和非ARC声明都是一样的，当然注意在非ARC下要release Block。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"项目简介","date":"2015-08-27T16:26:00.000Z","path":"2015/08/28/My-projects-introduction/","text":"经过漫长的程序猿岁月，参与或独自开发的的项目也越来越多。在这里，我将一一为大家介绍。因涉及各种原因，部分项目不做展示。 1.香港购 2.聚美味 3.微校通 4.一键配送 5.考好点 6.大米 7.雲澳門 8.後臺管理 9.克拉克直播 10.享share 11.享share·企业 12.夜直播 13.MIT-Live 14.雲社團 16.未完待续… 香港购随着每年大陆去香港，澳门旅游的游客数据不断的增长，智能手机的普及，在智能移动终端上进行消费品的了解，关注，收藏，掌握各商家的优惠促销活动，并且能够帮助大陆游客解决大陆电话卡去香港游玩时通讯费用和手机上网费用贵等问题，也就显得尤其重要。在这样的背景下，搭建一款全球星APP客户端应用无疑将大大提高消费者港澳通行购物，上网通讯，娱乐的便捷，并且为其到港澳旅游创造更大的价值。商家后台自主化管理，消费者针对需求进行收藏和关注，全方位的增加了商家与消费者之间的粘合度。最终实现三方共赢 聚美味聚美味是饮食O2O移动电商平台，是让您体验舌尖上的美味的美食神器，它不止能点餐，还能提前预定、点餐，给您节约宝贵的时间，还可以提前分享给您的小伙伴们，一起出谋划菜，有了它再也不用担心点不到喜欢的菜了；有了它可以尽享各种优惠劵，让您觉得物超所值；有了它您再也不必担心漫长的等待；有了它您再也不怕迷路找不到美食所在；有了它您可以及时掌握最新美食，最新优惠，最新特价菜；有了它您还可以在品尝完美食后，再分享给您的吃货小伙伴们。 微校通为实现全国教育资源共享，实现家长、老师、学校与培训机构之间的信息交流，“微校宝”智能教育资源共享自建平台APP将方便更多的智能手机用户。为促进初中、小学、学前班、幼儿园、以及培训机构的老师和家长、家长与家长之间，实现基于语音、图文方式的沟通与交流，实现学校/培训机构广播发送、教学安排、班级动态信息发布与交流，实现教育资源共享，使老师、家长的日常沟通提供便捷的无线信息化服务，同时架起家校沟通的桥梁，提升老师的工作效率，让家长更全面地掌握孩子的相关情况。 一键配送乐百氏桶装水“一键配送”APP应用旨在为乐百氏桶装水用户提供更好的服务，使使用可以通过更便利的方式与乐百氏桶装水产生互动，会员可通过“一键配送”APP准确及时的了解乐百氏桶装水的优惠活动，享受乐百氏桶装水为会员提供的各项福利。 大米借助APP企业客户端方便更多的智能手机用户，优化用户的手机购物体验，并借助现有资源和第三方服务，搭建互动平台，通过微博微信手机短信等转发分享好友实现APP及产品的传播率，APP可实现查看最新促销活动、提供网购咨询，进一步提升服务的质量。对商家进行分类管理、通过关键词或条件搜索到商品、商家信息，产品分类进行展示，对商家信息排序、筛选，按价格、距离及评价高进行排名，给热销产品及商家店铺提供了一个展示的平台，系统后台推送商家的优惠信息，手机客户端同网页一样，包含网购所必需的商品搜索、浏览、购买等功能，数万种商品，与网站相比一个不少，而且移动网购的便利性使得我们不再必须找台电脑下单付款，用手机一样能随时随地搜索浏览商品、收藏或购买。 雲澳門專為澳門量身定制的平臺！你生活的貼心管家，足不出戶就能在線完成生活繳費及了解澳門時事資訊！你專業的導購，帶你一起樂購澳門，全球進口品牌和澳門本地優質商家，獨享各種優惠折扣，玩轉澳門吃喝玩樂！ 享share享share——国内首款与产品经理、CEO交流产品心得的应用。 享share·企业享share·企业——国内首款帮助产品经理、CEO收集产品创意的社交应用。 夜直播一款夜店直播APP。 MIT-Live办公摄像头实时直播以及点播功能APP，使用RTMP协议实现。 雲社團雲社團APP是專為社團開發的程序，主旨是幫助社團更好的發展。讓社團與社員之間關係更加緊密。雲社團APP也向澳門基金會申請了科技基金。學生在APP上可以看到學校社團現在所有的活動，和各個社團的新動態。社團可以通過APP更好的將活動推廣出去。推廣給學生群體。 今天就上传这些，改天有时间再继续上传！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"项目","slug":"项目","permalink":"superdanny.link/tags/项目/"}]},{"title":"指定UIView的特定角为圆角","date":"2015-08-20T04:13:00.000Z","path":"2015/08/20/iOS-Custom-UIView-fillet/","text":"如果需要将UIView的4个角全部设为圆角，做法相当简单： 纯代码只需设置其Layer的cornerRadius属性即可（项目需要使用QuartzCore框架） xib上只需如图一那样设置就行了 若要指定某几个角（小于4个）为圆角而别的不变时，这种方法就不好用了。对于这种情况，Stackoverflow上提供了几种解决方案。其中最简单优雅的方案，就是使用UIBezierPath。下面给出一段示例代码。 1234567891011UIView *view = [[UIView alloc] initWithFrame:CGRectMake(120, 10, 80, 80)];view.backgroundColor = [UIColor redColor];[self.view addSubview:view2];UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view2.boundsbyRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRightcornerRadii:CGSizeMake(10, 10)];CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];maskLayer.frame = view.bounds;maskLayer.path = maskPath.CGPath;view.layer.mask = maskLayer; 其中byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight指定了需要成为圆角的角。该参数是UIRectCorner类型的，可选的值有： UIRectCornerTopLeft UIRectCornerTopRight UIRectCornerBottomLeft UIRectCornerBottomRight UIRectCornerAllCorners 从名字很容易看出来代表的意思，使用“|”来组合就好了。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"初探Storyboard","date":"2015-08-18T07:05:00.000Z","path":"2015/08/18/iOS-Storyboard/","text":"创建一个基于Navigation Controller的根视图 绑定跳转事件 修改Navigation Bar标题 ViewController ViewController之间的数据传递 ViewController之间的跳转 Storyboard之间ViewController的跳转 常见问题 学习感悟 以前一直使用xib，后来来到新公司就使用纯代码。从来没有用过Storyboard（中文称故事板），今天趁有几分兴致，在学习绘图的同时练练故事板。这里做一下笔记，方便以后查看。如果大家有什么Storyboard使用技巧可以留言分享哟！ 创建一个基于Navigation Controller的根视图 首先，我们选中默认生成的View Controller，在Editor -&gt; Embed In 中有Navigation Controller和Tab Bar Controller两个选项（图一），我们选择嵌入Navigation Controller。 另外拖一个Table View Controller到故事板中，选中Table View Controller的Table View。打开Attrbutes inspector，将Content设置为Static Cells，layout area中的Table View上出现了3个Cell。 我们依次给每一个Cell设置不同的背景颜色，并依次选中3个Table View Cell，然后在Attributes inspector中将他们的Style改成Basic并给每一个Cell设置标题（图二）。 绑定跳转事件 脑补时刻，先讲解一下一些关键的跳转事件 Selection Segue：当用户点击table view cell的任何部分，都会产生反应。 Accessory Action：只有当用户点击table view cell右边的圆圈箭头按钮时，才会产生的反应。 Show：在master或detail区域展现内容(典型的如iPad的设置界面，左侧是master，右侧是detail)，究竟是在哪个区要取决于屏幕上的内容，如果不分master/detail，就单纯的把新的内容push到当前view controller stack的顶部 Show Detail：大致同Show，在detail区域展现内容，如果不分master/detail，新的内容取代当前view controller stack的顶部 Present Modally：模态展示内容 Present as Popover：在当前的view上出现一个小窗口来展示内容，无处不在的“选中文字后出现 复制/翻译 按钮就是这个 Custom：自定义的 我们选中第一个Cell，按住Control键拖拉到要跳转的视图，在弹出的选项窗中选择show，这样就完成了页面跳转操作。接下来2个Cell也是同样的操作。 修改Navigation Bar标题 在Table View Controller上中选中Navigation Item（图三）。 将Attributes inspector中Title设置为“绘图技术”，将Back Button设值为“绘图”（图四）。 注意，这里的Back Button并不是显示在当前的Navigator Bar上的，而是显示在下一个sub view controller的navigator bar上的返回按钮的文字 ViewControllerViewController之间的数据传递当你从当前scene中触发一个segue的时候，系统会自动调用prepareForSegue:sender:这个方法。如果你想从一个界面切换到里另一个界面的时候传递数据，你应该override这个方法。比如：视图A -&gt; 视图B 12345678910111213- (void)prepareForSegue:(nonnull UIStoryboardSegue *)segue sender:(nullable id)sender &#123; ThreeViewController *b_vc = segue.destinationViewController; //我们传递了一个字符串到视图B b_vc.str = @\"dataStr\"; //更多功能 //源视图控制器(当前控制器) [segue sourceViewController]; //目标视图控制器 [segue destinationViewController]; //过渡标识 [segue identifier];&#125; ViewController之间的跳转在上文中我提及到通过绑定事件进行ViewController之间的跳转。这里罗列一下有三种情况可进行跳转： 如果在Storyboard中当前的ViewController和要跳转的ViewController之间的segue存在，则可以执行performSegueWithIdentifier:sender:这个方法实现跳转。 如果目标ViewController存在Storyboard中，但是没有segue。你可以通过UIStoryboard的instantiateViewControllerWithIdentifier:这个方法获取到它，然后再用你想要的方式实现跳转，如：压栈。 如果目标ViewController不存在，则需要我们创建好ViewController才能进行接下来的操作。 Storyboard之间ViewController的跳转Storyboard被看作是一个视图的容器，存放所有视图，方便管理。【情景】当project里面有StoryboardOne和StoryboardTwo两个故事板。要求Storyboard之间的ViewController需要进行交互时（我们在StoryboardOne里面的ViewControllerOne要跳转到StoryboardTwo里面的ViewControllerTwo），可使用以下方式进行跳转： 1234567//这个是ViewControllerOne里面Button绑定事件的代码- (IBAction)buttonActoin:(id)sender &#123; UIStoryboard *sb = [UIStoryboard storyboardWithName:@\"StoryboardTwo\" bundle:nil]; //Identifier为‘ViewControllerTwo’在Storyboard里面设置的StoryboardId UIViewController *vc = [sb instantiateViewControllerWithIdentifier:@\"ViewControllerTwo\"]; [self.navigationController pushViewController:vc animated:YES];&#125; 常见问题 在使用storyboard时，报错：Failed to instantiate the default view controller for UIMainStoryboardFile ‘MainStoryboard’ - perhaps the designated entry point is not set? 原因分析：在StoryBoard中没有一个view controller设置了Initial Scene。 解决方案：在Storyboard中，选择一个view conroller作为story board的第一启动界面 学习感悟 在学习Storyboard过程中，慢慢有所感悟，在这里记录一下。可能我说的不一定是最好的，但是会再学习的过程中慢慢提升。 当Storyboard中如果VC的数量越来越多的时候，可能会出现一种情况就是，用户要定位到某一个VC比较困难。所以我在每一个VC的Title属性都设置成该VC的类名（图五），方便以后可直接在Document Outline界面定位（图六） 待续… 暂时就讲这些，后面会将文章补全。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"iOS中处理空数据","date":"2015-08-13T07:19:00.000Z","path":"2015/08/13/iOS-null-data/","text":"今天无意间看到有朋友问处理那些繁琐的空数据问题，本人以前做过类似的处理，现在由于知识有限，能想到的就是利用递归的方式进行处理。 Note：1）由于本人尚未进行全面的测试，如果大家发现有任何错误的，请留言指出。一同完善它。2）如果您有更加完美的处理方案，也希望您能分享一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import \"CheckTool.h\"@implementation CheckTool///主要调用该方法+ (id)replaceNullData:(id)obj &#123; if ([obj isKindOfClass:[NSDictionary class]]) &#123; return [self replaceNullWithDictionary:obj]; &#125; else if ([obj isKindOfClass:[NSArray class]]) &#123; return [self replaceNullWithArray:obj]; &#125; else if ([obj isKindOfClass:[NSNumber class]]) &#123; if (obj isKindOfClass:[NSNull class]] || obj == nil) &#123; obj = @(0); &#125; return obj; &#125; else if ([obj isKindOfClass:[NSString class]]) &#123; return [self replaceNullValue:obj]; &#125; return obj;&#125;///处理字典+ (id)replaceNullWithDictionary:(NSMutableDictionary *)dic &#123; NSMutableDictionary *tempDic = [NSMutableDictionary dictionary]; NSArray *allKey = [dic allKeys]; for (NSString *key in allKey) &#123; [tempDic setObject:[self replaceNullData:dic[key]] forKey:key]; &#125; return tempDic;&#125;///处理数组+ (id)replaceNullWithArray:(NSMutableArray *)arr &#123; __block NSMutableArray *tempArr = [NSMutableArray array]; [arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [tempArr addObject:[self replaceNullData:obj]]; &#125;]; return tempArr;&#125;///处理字符串+ (NSString *)replaceNullValue: (NSString *)string &#123; NSString * newStr = [NSString stringWithFormat:@\"%@\",string]; if ([newStr isKindOfClass:[NSNull class]] || newStr == nil || [newStr isEqualToString:@\"(null)\"]|| [newStr isEqualToString:@\"\"] || [newStr isEqualToString:@\"null\"] || [newStr isEqualToString:@\"&lt;null&gt;\"]) &#123; newStr = @\"\"; &#125; return newStr;&#125;@end 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"Swift入坑系列—集合类型","date":"2015-07-27T14:36:00.000Z","path":"2015/07/27/Swift-Series-CollectionType/","text":"数组（Arrays） 创建并构造数组 数组的增删改查 数组的遍历 字典（Dictionaries） 创建字典字面量 字典的增删改查 字典的遍历 总结 数组（Arrays）在OC里面，NSArray和NSMutableArray这两个类可以存储任意类型的对象，并且不提供所返回对象的任何特别信息。在Swift中，数据值被存入某个数组之前类型必须明确。方法是通过显式的类型标注或者类型推断，而且不是必须是class类型。 12345//定义了一个存储 字符串类型 的可变数组('var'字段修饰)var shoppingList: [String] = [\"Eggs\", \"Milk\"]//定义了一个存储 字符串类型 的不可变数组('let'字段修饰)let peopleList: [String] = [\"Danny\", \"Mike\", \"Johnnie\"] Note：当然你也可以省略类型标注，因为Swift可以根据你的内容推断出正确的类型，如下面的代码。 1var shoppingList = [\"Eggs\", \"Milk\"] 创建并构造数组12345678//创建一个整型空数组var array1 = [Int]()//创建一个特定大小，并且所有数据都为默认的整型数组var array2 = [Int](count: 3, repeatedValue:1)//创建一个特定大小，并且数据类型为默认的推断为浮点型的数组var array3 = [](count: 3, repeatedValue:2.5) 数组的增删改查 增（插入数据） Swift中往数组里面插入数据有多种方式： 1）append()方法 1shoppingList.append(\"Flour\") 2）insert(atIndex:)方法 1shoppingList.insert(\"Maple Syrup\", atIndex: 0) 3）+=赋值运算符 1shoppingList += [\"Baking Powder\"] 删（删除数据） 通过removeAtIndex()方法移除指定位置的数据项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（返回的数据项如果不用的时候可以无视）： 1let mapleSyrup = shoppingList.removeAtIndex(0) 通过removeLast()方法可以移除最后一项数据项 1let apples = shoppingList.removeLast() 改（更新数据） 12345//通过指定某一项更新数据项shoppingList[0] = \"Six eggs\" //通过区间更新区间内数据项shoppingList[4...6] = [\"Bananas\", \"Apples\"] Note： 我们不能使用下标语法在数组尾部添加新项。如果我们试着用这种方法对索引越界的数据进行检索或者设置新值的操作，我们会引发一个运行期错误。我们可以使用索引值和数组的count属性进行比较来在使用某个索引之前先检验是否有效。除了当count等于 0 时（说明这是个空数组），最大索引值一直是count - 1，因为数组都是零起索引 查（访问数据） 12345//获取第0项数据并赋值给变量firstItemvar firstItem = shoppingList[0] //获取某个区间的数据项并赋值给另外一个数值let tempArr = shoppingList[1...2] 数组的遍历通过for-in循环遍历数组中的数据项： [方式一] 12345let array = [\"Danny\", \"Johnnie\", \"Mike\"]//遍历数组数据项for item in array &#123; print(item)&#125; 控制台打印：DannyJohnnieMike [方式二] 12345let array = [\"Danny\", \"Johnnie\", \"Mike\"]//遍历数组数据项for (idx, value) in array.enumerate() &#123; print(\"idx:\\(idx) value:\\(value)\")&#125; 控制台打印：idx:0 value:Dannyidx:1 value:Johnnieidx:2 value:Mike 字典（Dictionaries）创建字典字面量OC里面，字典字面量的格式是：@{@&quot;key&quot; : @&quot;value&quot;}，而Swift里面，字典字面量以及数组字面量均使用中括号[]包住。格式为：[key 1: value 1, key 2: value 2, key 3: value 3] 12//创建一个var airports: [String:String] = [\"TYO\": \"Tokyo\", \"DUB\": \"Dublin\"] 12//创建一个键为String，值为Int的空字典var dic1 = Dictionary&lt;String, Int&gt;() 字典的增删改查 增（插入数据） 在字典中使用下标语法来添加新的数据项。可以使用一个合适类型的 key 作为下标索引，并且分配新的合适类型的值： 1airports[\"LHR\"] = \"London\" 删（删除数据） 通过removeValueForKey()方法在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的value或者在没有值的情况下返回nil： 12//通过键值“DUB”移除对应的值let removedValue = airports.removeValueForKey(\"DUB\") 改（更新数据） 通过使用下标语法来改变特定键对应的值： 12//使用下标语法来改变特定键对应的值airports[\"LHR\"] = \"London Heathrow\" 也可以通过updateValue(forKey:)方法设置或者更新特定键对应的值。这个方法还会返回更新值之前的原值或者nil，方便我们检查更新是否成功： 12//通过“DUB”键将旧值更新为“Dublin Internation”let oldValue = airports.updateValue(\"Dublin Internation\", forKey: \"DUB\") 查（访问数据） 使用下标语法来在字典中检索特定键对应的值。由于使用一个没有值的键这种情况是有可能发生的，可选类型返回这个键存在的相关值，否则就返回nil： 12345if let airportName = airports[\"DUB\"] &#123; print(\"DUB键对应的值为： \\(airportName).\")&#125; else &#123; print(\"DUB键没有对应的值\")&#125; 控制台打印： DUB键对应的值为： Dublin Internation. 字典的遍历[方式一] 通过for-in循环遍历某个字典中的键值对。每一个字典中的数据项都由(key, value)元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组： 1234//遍历字典对应的键值对for (key, value) in airports &#123; print(\"\\(key): \\(value)\")&#125; 控制台打印：TYO: TokyoLHR: London Heathrow [方式二] 我们也可以通过访问它的keys或者values属性检索一个字典所有的键、值： 12345678//遍历字典所有键for key in airports.keys &#123; print(\"该字典的键：\\(key)\")&#125;//遍历字典所有值for value in airports.values &#123; print(\"该字典的值：\\(value)\")&#125; 控制台打印：该字典的键：LHR该字典的键：TYO该字典的值：London Heathrow该字典的值：Tokyo Note：当你想要将字典的键、值分别存起来的话，可以使用数组的APIArray()进行存储 12345//将字典的所有键存进keys数组中let keys = Array(airports.keys)//将字典的所有值存进values数组中let values = Array(airports.values) 总结目前本人就先简单的介绍数组、字典的一些简单的使用，后期会不断的完善这篇文章。再一次感谢您花费时间阅读这篇文章！ 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Swift","slug":"Swift","permalink":"superdanny.link/tags/Swift/"}]},{"title":"Swift入坑系列—前言","date":"2015-07-25T10:45:00.000Z","path":"2015/07/25/Swift-Series-Introduction/","text":"从今天开始，本人会不定时更新自己学习Swift的坎坷道路。之所以要写这些文章，是想让更多Coder少入坑（跟我一起入坑）。我写的文章可能没有大神般那样深入，就只是很浅显的了解。当然，当我学习到了一定的程度之后，会不断更新之前的旧文章，已提供更加完整的学习心得。 本人在此申明，如果有哪些知识点讲解的不对，希望大家能够批评指出，这样大家才能共同进步（这样才能让我更加有吹牛的资本）。 Note:文章的内容是建立在有一定的OC基础上面，所以有一些内容可能没有详细说明，不懂得同学需要脑补一下先。","tags":[{"name":"Swift","slug":"Swift","permalink":"superdanny.link/tags/Swift/"}]},{"title":"关于我","date":"2015-07-21T08:44:00.000Z","path":"2015/07/21/About-me/","text":"基本信息基 本: 3年工作经验 | 男 | 25岁居住地: 珠海E-mail: 736809040#qq.com项 目: 项目清单主 页: 博客主页Github: 请多多指教 工作和教育工作 时间 公司 职务 2015.03 - 现在 澳门梦幻科技集团有限公司 iOS开发 2014.12 - 2015.03 珠海微仕会信息技术有限公司 iOS开发兼管理 2013.07 - 2014.11 广州迈峰网络科技有限公司 iOS开发(学校外派) 教育 时间 专业 学校 2016.09 - 至今 计算机科学与技术 浙江大学(在读) 2012.09 - 2015.06 软件技术 广东科学技术职业学院 专业技能1、三年iOS开发经验，丰富的Objective-C和Cocoa编程经验;2、具备主流开源组件使用经验;3、对代码的封装性、可拓展性较高;4、开发过多款电商、即时通讯、视频直播类型应用;5、有独自完整开发并上架过多款APP经验;6、熟练使用多个平台的代码管理系统、JIRA任务管理系统;7、熟练集成微信、支付宝、网银等第三方支付;8、了解数据安全，以及数据处理方式和多种加密方式;9、掌握Socket机制，心跳包、断线重连等;10、熟练APNS远程推送，以及UILocalNotification本地消息推送等;11、对移动端有独到的见解，追求极致的用户体验，对代码规范有严格的自我要求！12、Swift饭 项目经验【项目】IN潮（2017.07-2017.09） - 傳送門 潮APP是一款專為年輕人開發的緊追潮流時尚的應用APP，打造年輕人的潮流集結地！通過公司先進的互聯網技術、強大的數據分析整合能力和豐富的電子商務運營經驗，為用戶尋覓每個城市中潮玩潮吃的地方和潮買的商家，滿足用戶對高品質、健康、環保、舒適、尊貴、個性的消費需求。潮將致力於滿足年輕人對新奇、潮玩事物的探索、追求為目標。挖掘城市熱門商圈、潮流推薦食肆、娛樂運動場所等優質資源，為用戶提供豐富的消費選擇、便捷的消費方式和用心的服務，打造潮流APP的同時打造會員共享平臺。 【负责工作】1、QQ、微信、Facebook第三方登录2、商圈模块开发3、协助开发其他模块 【核心技术】1、xmpp即时通讯，实现图片、文字、语音聊天，聊天信息失败重发机制2、使用第三方MagicalRecord分表存储不同用户本地聊天记录3、使用IJKMediaFramework框架，结合ZFPlayer播放器实现直播功能4、类似“今日头条”网页嵌套图文评论功能5、QQ、微信、Facebook第三方登录6、集成支付宝，微信支付第三方支付7、集成百度地图实现APP内路线规划、APP内导航及跳转第三方地图导航功能8、自定义推送任意跳转功能 【项目】雲社團（2017.08-2017.09） - 傳送門 雲社團APP是專為社團開發的程序，主旨是幫助社團更好的發展。讓社團與社員之間關係更加緊密。雲社團APP也向澳門基金會申請了科技基金。學生在APP上可以看到學校社團現在所有的活動，和各個社團的新動態。社團可以通過APP更好的將活動推廣出去。推廣給學生群體。 【负责工作】1、独自完成整款APP的搭建与开发2、独自完成接口接通与逻辑处理3、上架并完善后期存在问题 【核心技术】1、类似“今日头条”网页嵌套图文评论功能2、QQ、微信、Facebook第三方登录3、集成支付宝，微信支付第三方支付4、多文件断点下载、预览功能6、自定义推送任意跳转功能7、活动展示、报名缴费功能 【项目】MIT-Live（2017.04-2017.07） 办公摄像头实时直播以及点播功能APP，使用RTMP协议实现。企业内部使用，未上架AppStore。 【负责工作】1、开发与后期Bug修复工作 【核心技术】1、使用IJKMediaFramework框架，结合ZFPlayer播放器实现直播、点播功能2、播放源自由切换功能 【项目】享share（2016.05-2016.09） - 傳送門 享share——国内首款与产品经理、CEO交流产品心得的应用。 这里没有客服人员，也没有客服机器人，有的是产品负责人/CEO。「灵光一闪的创意」、「产品的深度见解」，它们需要有一个合适的交流对象。有喜欢的APP吗？有对它萌生过想法创意吗？有想过和它的产品经理/CEO好好聊聊吗？有想过听听其他用户对你的想法创意作出怎么样的评价吗？或许，你现在不用再憋在心里，享share帮助你的心声一触即达。 1.【产品圈】围绕某款产品，和其他用户交流想法，分享创意。2.【企业圈】围绕某款产品，与产品经理/CEO一对一交流。表达你的创意和见解。3.【搜索】快速搜索交流对象（产品/企业）。4.【个人中心】一览无余快速查看「企业的赞」，「企业的回复」，还有企业的获赞数量总排名哦。5.【推荐有奖】分享给志同道合的朋友，赠你一书一世界。 【负责工作】1、独自完成整款APP的搭建与开发2、独自完成接口接通与逻辑处理3、上架并完善后期存在问题 【核心技术】1、类似微信朋友圈多图，多评论功能2、集成支付宝支付3、自定义推送任意跳转功能 【项目】享share·企业（2016.05-2016.09） - 傳送門 享share·企业——国内首款帮助产品经理、CEO收集产品创意的社交应用。 产品创意：“顾客想要更快的马车，福特却给他一辆汽车”。真正理解用户的需求是做产品的核心，我们希望给您提供一个特别的灵感之地。 用户心声：“用户满不满意，从一个反馈就可以看出来”。也许心声有无数个，但我们希望能让产品管理者的您认真听到一个。 交流见解：“聆听，用户亦是朋友”。我们希望在产品的世界里，用户能成为您的挚友。 1.【便捷发布产品】仅需填写产品Logo、产品名字、产品简介，即可发布产品，向用户创建一个反馈入口。2.【接收消息】舒适的阅读体验，随时随地收获优质产品创意、聆听深度用户见解。3.【适合人群】个人开发者，创业团队，中小型企业的产品管理者。 【负责工作】1、独自完成整款APP的搭建与开发2、独自完成接口接通与逻辑处理3、上架并完善后期存在问题 【核心技术】1、类似微信朋友圈多图，多评论功能2、自定义推送任意跳转功能 【项目】雲澳門商家版（2015.05-2015.12） 一款管理商铺、用户软件。 商家可使用软件管理店铺、店员、会员。用户申请会员卡时，即可通过个人版进行申请，也可通过商家给出的二维码进行扫一扫申请。 商家可通过软件发布店铺最新动态以及优惠活动，也可选择在未来某一天发布，方便快捷。让用户得到更多的了解。 【负责工作】1、根据UI设计实现界面2、实现接口接通3、修复APP存在的问题 【核心技术】1、xmpp即时通讯，实现图片、文字、语音聊天，聊天信息失败重发机制2、使用第三方MagicalRecord分表存储不同用户本地聊天记录3、以报表形式展示商户交易记录，处理用户订单请求 【项目】雲澳門（2015.04-2015.12） - 傳送門 專為澳門量身定制的平臺！你生活的貼心管家，足不出戶就能在線完成生活繳費及了解澳門時事資訊！你專業的導購，帶你一起樂購澳門，全球進口品牌和澳門本地優質商家，獨享各種優惠折扣，玩轉澳門吃喝玩樂！ 用户可使用软件在实体店进行支付操作，不管你是哪个国家，哪种货币，只要当地有软件加盟商户，即可使用该款软件进行支付，不用使用现金，省时又省力。 通过软件也可进行手机、固话话费充值缴费。 软件功能强大：扫一扫功能齐全，即可用于商家会员卡申请，又可用于支付。会员卡可用于店铺支付打折，只需扫一扫，输入密码即可实现支付，每一笔交易都会有短信提醒，软件也会收到相应的推送通知，账单列表一目了然，让用户用的放心。用户也可通过软件了解到商家的最新动态以及优惠活动，不错过任何机会。 【负责工作】1、根据UI设计实现界面2、实现接口接通3、修复APP存在的问题 【核心技术】1、xmpp即时通讯，实现图片、文字、语音聊天，聊天信息失败重发机制2、使用第三方MagicalRecord分表存储不同用户本地聊天记录3、使用UITableView开发类似淘宝购物车，UICollectionView开发商品展示页面3、开发类似“今日头条”网页嵌套图文评论功能4、集成支付宝支付，微信支付，工行支付5、集成百度地图实现APP内路线规划、APP内导航及跳转第三方地图导航功能6、自定义推送任意跳转功能 【项目】大米（2014.11-2015.02） APP可实现查看最新促销活动、提供网购咨询。对商家进行分类管理、通过关键词或条件搜索到商品、商家信息，产品分类进行展示，对商家信息排序、筛选，按价格、距离及评价高进行排名，给热销产品及商家店铺提供了一个展示的平台，系统后台推送商家的优惠信息，随时随地搜索浏览商品、收藏或购买。 【负责工作】1、编写项目设计文档、接口文档、详细任务分配及其进度跟踪2、根据UI设计实现界面3、实现部分接口接通4、修复APP存在的问题 【项目】考好点（2014.08-2014.10） 一款手机智能做题软件。提供不同科目试题下载以及模拟考试，实时提供做题报告、题目的优质解析、预测考试分数、随身的错题本-让所有人见证你的进步。 【负责工作】1、项目框架搭设2、分配工作任务以及进度跟踪3、根据UI设计实现界面 4、实现部分接口接通5、修复APP存在的问题 【核心技术】使用UIScrollerView、UITableView控件，重用机制实现答题核心界面 【项目】拜师通（2014.05-2014.07） 实现基于语音、图文方式的沟通与交流，实现培训机构广播发送、教学安排、班级动态信息发布与交流，实现教育资源共享，使老师、家长的日常沟通提供便捷的无线信息化服务，同时架起家校沟通的桥梁，提升老师的工作效率，让家长更全面地掌握孩子的相关情况。 【负责工作】1、项目的整体架构2、根据UI设计实现界面3、接口调用 【项目】一键配送（2014.04-2014.08） - 傳送門 乐百氏桶装水“一键配送”APP应用旨在为乐百氏桶装水用户提供更好的服务，使使用可以通过更便利的方式与乐百氏桶装水产生互动，会员可通过“一键配送”APP准确及时的了解乐百氏桶装水的优惠活动，享受乐百氏桶装水为会员提供的各项福利。 【负责工作】1、项目技术指导2、界面开发与接口接通 【核心技术】1、集成支付宝支付，微信支付2、使用UITableView开发类似淘宝购物车界面、商品详情界面 【项目】微校通（2013.12-2014.04） 实现基于语音、图文方式的沟通与交流，实现学校/培训机构广播发送、教学安排、班级动态信息发布与交流，实现教育资源共享，使老师、家长的日常沟通提供便捷的无线信息化服务，同时架起家校沟通的桥梁，提升老师的工作效率，让家长更全面地掌握孩子的相关情况。 【负责工作】1、项目的整体架构2、根据UI设计实现界面3、接口调用 【核心技术】1、xmpp即时通讯，实现图片、文字、语音、表情聊天2、使用第三方FMDB操作SQL分表存储不同用户本地聊天记录 【项目】聚美味（2013.08-2013.12） 聚美味是饮食O2O移动电商平台，是让您体验舌尖上的美味的美食神器，它不止能点餐，还能提前预定、点餐，给您节约宝贵的时间，还可以提前分享给您的小伙伴们；可以尽享各种优惠劵，让您觉得物超所值；不必担心漫长的等待；不怕迷路找不到美食所在；可以及时掌握最新美食，最新优惠，最新特价菜；可以在品尝完美食后，再分享给您的吃货小伙伴们。 【负责工作】1、根据UI设计实现界面效果2、实现部分接口接通3、修复APP存在的问题 【核心技术】1、集成支付宝支付，微信支付，银联支付2、使用UITableView开发类似淘宝购物车，同时使用UITableView实现类似“美团外卖”点餐界面 【项目】香港购（2013.07-2013.10） 香港，澳门旅游的游客通过智能移动终端上进行消费品的了解，关注，收藏，掌握各商家的优惠促销活动，并且能够帮助大陆游客解决大陆电话卡去香港游玩时通讯费用和手机上网费用贵等问题。搭建一款全球星APP客户端应用无疑将大大提高消费者港澳通行购物，上网通讯，娱乐的便捷，并且为其到港澳旅游创造更大的价值。商家后台自主化管理，消费者针对需求进行收藏和关注，全方位的增加了商家与消费者之间的粘合度。最终实现三方共赢。 【负责工作】1、项目的整体架构2、根据UI设计实现界面3、接口调用 【核心技术】1、集成支付宝支付，微信支付，银联支付 IT技能 自我评价本人乐观开朗，具有良好的沟通、交流、需求理解能力，工作积极主动，责任心强，能承担一定的工作压力，良好的分析和独立解决问题的能力。对应用开发颇有心得体会。具有丰富的Objective-C和Cocoa编程经验，熟练使用iPhone SDK和Xcode，3年iPhone产品研发经验，具备主流开源组件使用经验，在电商应用、即时通讯、视频直播应用上有一定的接触，并且有多款应用上架到AppStore。本人对工作负责，易于融入集体文化，能与他人建立良好的关系。","tags":[{"name":"简历","slug":"简历","permalink":"superdanny.link/tags/简历/"}]},{"title":"Grand Central Dispatch","date":"2015-07-15T12:23:00.000Z","path":"2015/07/15/iOS-Grand-Central-Dispatch/","text":"简答的复习了一下GCD的一些简单操作，这里做一个笔记，方便以后查看。 Dispatch Queue 自定义串、并行队列 程序进程缺省队列 主线程队列 同步/异步、串行/并行使用 死锁问题 dispatch_after dispatch_group Dispatch Queue Serial Dispatch Queue按添加进队列的顺序 FIFO (先进先出)一个接一个的执行 Concurrent Dispatch Queue并发执行队列里的任务 1.1 自定义串、并行队列并行队列：DISPATCH_QUEUE_CONCURRENT串行队列：DISPATCH_QUEUE_SERIAL 12345//创建一个名称为‘com.company.xxx’的串行队列dispatch_queue_t serialQueue = dispatch_queue_create(\"com.company.xxx\", DISPATCH_QUEUE_SERIAL);//创建一个名称为‘com.xxx’的并行队列dispatch_queue_t concurrentQueue = dispatch_queue_create(\"com.company.xxx\", DISPATCH_QUEUE_CONCURRENT); Note：1）参数一是队列的名称，一般是使用倒序的全域名。虽然可以不给队列指定一个名称，但是有名称的队列可以让我们在遇到问题时更好调试2）当参数二为nil时返回Serial Dispatch Queue(串行队列)，如上面那个例子，当指定为DISPATCH_QUEUE_CONCURRENT时返回Concurrent Dispatch Queue(并行队列) 1.2 程序进程缺省队列高优先级队列：DISPATCH_QUEUE_PRIORITY_HIGH中优先级队列：DISPATCH_QUEUE_PRIORITY_DEFAULT低优先级队列：DISPATCH_QUEUE_PRIORITY_LOW 12//获取程序缺省并行队列，第二个参数固定为0dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); Note：1）需要注意的是，三个队列不代表三个线程，可能会有更多的线程。并发队列可以根据实际情况来自动产生合理的线程数，也可理解为dispatch队列实现了一个线程池的管理，对于程序逻辑是透明的。2）获取Global Dispatch Queue的时候可以指定优先级，可以根据自己的实际情况来决定使用哪种优先级 1.3 主线程队列12//获取主线程串行队列dispatch_queue_t queue = dispatch_get_main_queue(); 三者对比 队列 串行 并行 自定义队列 √ √ 程序缺省队列 × √ 主线程队列 √ × Note：一般只在需要更新UI时我们才获取Main Dispatch Queue，其他情况下用Global Dispatch Queue就满足需求了 同步/异步、串行/并行使用12345678910111213//异步执行block，函数立即返回dispatch_async(queue, ^&#123;//block具体代码&#125;); //同步执行block，函数不返回dispatch_sync(queue, ^&#123;//block具体代码&#125;); 举例： 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;//子线程中开始网络请求数据...//更新数据模型dispatch_sync(dispatch_get_main_queue(), ^&#123;//在主线程中更新UI代码self.view.backgroundColor = [UIColor orangeColor];&#125;);&#125;); Note：尽可能避免使用dispatch_sync，嵌套使用时还容易引起程序死锁 死锁问题 同步串行会出现死锁，同步并行不会造成死锁 异步不管是串行还是并行都不会出现死锁 异步嵌套同步或者同步嵌套异步就需要注意代码执行顺序 Note：死锁原因：提交到主线程队列的时候，慎用同步dispatch_sync方法，有可能造成死锁。因为主线程队列是串行队列，要等队列里的任务一个一个执行。所以提交一个任务到队列，如果用同步方法就会阻塞住主线程，而主线程又要等主线程队列里的任务都执行完才能执行那个刚提交的，所以主线程队列里还有其他的任务的话，但他已经被阻塞住了，没法先完成队列里的其他任务，即，最后一个任务也没机会执行到，于是造成死锁。 dispatch_afterdispatch_after能让我们添加进队列的任务延时执行，比如想让一个Block在5秒后执行： 123456789double delayTime = 5.0;dispCatch_time_t dTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayTime*NSEC_PER_SEC));dispatch_after(dTime, dispatch_get_main_queue(), ^&#123;//delayTime秒后执行block块NSLog(@\"block执行\");&#125;); dispatch_after的真正含义是在5秒后把任务添加进队列中，并不是表示在5秒后执行，大部分情况该函数能达到我们的预期，只有在对时间要求非常精准的情况下才可能会出现问题 【拓展】延迟执行还有另外一种方式，那就是NSObject中的performSelector:withObject:afterDelay:以及performSelector:withObject:afterDelay:inModes: dispatch_group我们现在有3个Block要执行，我们不在乎它们执行的顺序，我们只希望在这3个Block执行完之后再执行某个操作。这个时候就需要使用dispatch_group了 1234567891011121314151617dispatch_group_t groupQueue = dispatch_group_create();dispatch_group_async(groupQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;NSLog(@\"1\");&#125;);dispatch_group_async(groupQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;NSLog(@\"2\");&#125;);dispatch_group_async(groupQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;NSLog(@\"3\");&#125;);dispatch_group_notify(groupQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;NSLog(@\"completion\");&#125;); 在控制台打印的结果是：2015-07-21 22:17:57.159 GCD[9606:1327380] 32015-07-21 22:17:57.159 GCD[9606:1327377] 22015-07-21 22:17:57.159 GCD[9606:1327379] 12015-07-21 22:17:57.159 GCD[9606:1327377] completion Note：输出的顺序与添加进队列的顺序无关，因为队列是Concurrent Dispatch Queue，但“completion”的输出一定是在最后的 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"},{"name":"GCD","slug":"GCD","permalink":"superdanny.link/tags/GCD/"}]},{"title":"关于Xcode更新之后插件失效以及安装失败详解","date":"2015-07-08T14:44:00.000Z","path":"2015/07/08/Update-Xcode-Plug-in/","text":"Xcode的插件对于开发者来说无疑是开发中的一大利器，让开发者能够将更多的时间和精力放在代码上面。但是开发者都会遇到一个问题，就是每次Xcode一更新，之前好不容易装好的插件全部不能用了，需要重新安装一遍，有时候还会因为某种原因导致即便安装了插件也不能使用的情况。在这里，我将跟大家分享我是如何解决这些问题的。当然，我的方案是建立在前人的基础上完善的。在这里，我先分析插件安装失效的一些原因： 系统安装了不止一个Xcode开发工具 开发者未正确的将自己的DVTPlugInCompatibilityUUID添加到插件中 成功安装了插件，但是却在Xcode识别插件的时候，开发者选择了Skip Bundle这些插件导致 下面，我将把我安装插件的过程以及如何让插件正常使用做一个详细的介绍。下载插件以及编译插件的过程我就不再累赘，想必大家都懂，我就直奔主题了。我们以ColorSense这款插件为例。 流程首先，我们要先明确我们的插件是要安装到哪个版本的Xcode上面，然后到拿到对应Xcode的DVTPlugInCompatibilityUUID 现在我想在我的Xcode 6.4上面安装这款插件，那么我需要拿到Xcode 6.4的DVTPlugInCompatibilityUUID 右键Xcode，选择显示包内容 然后找到Contents/Info.plist路径下的 Info.plist文件 双击Info.plist文件，找到DVTPlugInCompatibilityUUID，将对应的7FDF5C7A-131F-4ABB-9EDC-8C5F8F0B8A90复制 接下来到ColorSense插件所在目录下 右键插件，选择显示包内容。然后找到Contents/Info.plist路径下的 Info.plist文件 双击Info.plist文件，将刚刚复制的7FDF5C7A-131F-4ABB-9EDC-8C5F8F0B8A90增加到DVTPlugInCompatibilityUUID字段里面。保存 重新打开Xcode 6.4，此时会弹窗提示用户是否加载该插件。很多用户就是在这一步因为选择了Skip Bundle导致不能成功使用插件。 【注意】正确的做法应该是选择Load Bundle选项才对 现在可以Xcode中使用该插件了，是不是很激动！(^__^) 嘻嘻…… 是不是这样就完了？肯定没有，通过上面的步骤，我想大家已经知道了操作流程。那么接下来，讲解一个高效率做法。 终端指令实现12345//获取DVTPlugInCompatibilityUUID字段defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID//将XXXX替换成刚刚获取的DVTPlugInCompatibilityUUIDfind ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add XXXX 执行这两个指令，即可实现上面繁琐的过程。是不是更加方便？ 如果有任何疑问，可以留言，我将尽我所能帮助你。 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"Xcode","slug":"Xcode","permalink":"superdanny.link/tags/Xcode/"},{"name":"插件","slug":"插件","permalink":"superdanny.link/tags/插件/"}]},{"title":"iTerm 2 && Oh My Zsh「DIY教程」","date":"2015-07-08T14:44:00.000Z","path":"2015/07/08/iTerm_2&&Oh_My_Zsh/","text":"下面，我将分步骤讲解我是怎么一步一步完成DIY过程 1.首先下载 iTerm 2 2.打开iTerm 2 3.输入下面指令安装oh-my-zsh 4.接下来安装Powerline 5.下载、安装库字体库 6.设置iTerm 2的Regular Font 和 Non-ASCII Font 7.配色方案 8.使用agnoster主题 9.增加指令高亮效果——zsh-syntax-highlighting 问题解答区 一年前，在搞终端的时候偶然一次机会，让我看到了各种强大的DIY界面，这让我很想去自己搞一个。于是在网上不断的寻找资源，也请教了大多数朋友。最终以失败告终。最近，本人又突然想起当时这件事，于是，决定边做笔记，边尝试当初失败的过程。经过一个晚上的时间，终于DIY出我梦寐以求的效果。 先放上最终DIY效果图： 下面，我将分步骤讲解我是怎么一步一步完成DIY过程 1. 首先下载 iTerm 22. 打开iTerm 23. 输入下面指令安装oh-my-zshcurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 4. 接下来安装Powerline在官网有教程，我们只需要执行官网第一条安装指令就行 如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装 pip install powerline-status 如果没有，则先执行安装pip指令 sudo easy_install pip 5. 下载、安装库字体库1）将工程下载下来后cd到install.sh文件所在目录 2）执行指令安装字体库 执行./install.sh指令安装所有Powerline字体 安装完成后提示所有字体均已下载到/Users/superdanny/Library/Fonts路径下 All Powerline fonts installed to /Users/superdanny/Library/Fonts 6. 设置iTerm 2的Regular Font 和 Non-ASCII Font安装完字体库之后，把iTerm 2的设置里的Profile中的Text 选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline 7. 配色方案1）安装配色方案 进入刚刚下载的工程的solarized/iterm2-colors-solarized 下双击 Solarized Dark.itermcolors 和 Solarized Light.itermcolors 两个文件就可以把配置文件导入到 iTerm2 里 2）配置配色方案 通过load presets选择刚刚安装的配色主题即可 8. 使用agnoster主题1）下载agnoster主题 到下载的工程里面运行install文件,主题将安装到~/.oh-my-zsh/themes目录下 2）设置该主题进入~/.zshrc打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster。ZSH_THEME=&quot;agnoster&quot;（agnoster即为要设置的主题） 9. 增加指令高亮效果——zsh-syntax-highlighting指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮 1）cd到.zshrc所在目录 2）执行指令将工程克隆到当前目录 git clone git://github.com/zsh-users/zsh-syntax-highlighting.git 3）打开.zshrc文件，在最后添加下面内容 source XXX/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 保存文件。 注意：xxx代表.zshrc所在目录 4）cd ~/.oh-my-zsh/custom/plugins 5）再次打开.zshrc文件，在最后面添加下面内容 plugins=(zsh-syntax-highlighting) 保存文件。 问题解答区 启动iTerm 2 默认使用dash改用zsh解决方法：chsh -s /bin/zsh 如果想切换回原来的dash：chsh -s /bin/bash 卸载oh my zsh，在命令行输入如下命令，回车即可：uninstall_oh_my_zsh 执行指令pip install powerline-status出错解决方法： 需要下载苹果官方的Command line。必須官方工具下载最新版 Command Line ⌘+Q关闭iTerm 2 时每次弹窗提示问题： iTerm 2 中，进入Preference-General-Closing栏目，将Confirm &quot;Quit iTerm2(⌘Q)&quot; command选项勾选去掉就行 找不到.zshrc文件问题： 我这里将我的.zshrc文件分享出来。供大家下载网盘 路径前缀的XX@XX太长，缩短问题： 在此感谢评论区的朋友提供的解决方案。在~/.oh-my-zsh/themes路径下找到agnoster.zsh-theme文件，可使用文本工具打开，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可。 背景图: 有朋友喜欢我那个终端的背景图，这里放出来给喜欢的朋友使用。http://wx1.sinaimg.cn/large/81f8a509gy1fnjdvkkwgoj20zk0m8ak8.jpg 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"终端","slug":"终端","permalink":"superdanny.link/tags/终端/"},{"name":"DIY","slug":"DIY","permalink":"superdanny.link/tags/DIY/"}]},{"title":"解决TabBar隐藏与显现hidesBottomBarWhenPushed问题","date":"2015-01-23T04:00:00.000Z","path":"2015/01/23/iOS-TabBar-hidesBottomBarWhenPushed/","text":"今天遇到一个郁闷的问题（以前是完全没问题的）：视图A push 视图B ，以前隐藏UITabBarController的tabBar, 我用它的一个属性hidesBottomBarWhenPushed。将其设置为YES就可以在下一级隐藏Tabbar，但是pop的时候TabBar不显现了。【解决办法】 把 self.hidesBottomBarWhenPushed = YES;中的self改成你要push进入的那个viewcontroller 123LoginViewController *loginVC = [[LoginViewController alloc] init];loginVC.hidesBottomBarWhenPushed = YES;[self.navigationController pushViewController:loginVC animated:YES]; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"打赏专栏","date":"2014-12-31T17:01:00.000Z","path":"2015/01/01/A-reward-Column/","text":"本专栏用于打赏使用，如果亲觉得我的博客写的不错，且对你有所帮助。麻烦不吝啬于打赏给本人以资鼓励。 移步至简书打赏专栏 也可以使用「微信」「支付宝」「PayPal」 赞赏： 微信 支付宝 PayPal PayPal","tags":[{"name":"打赏","slug":"打赏","permalink":"superdanny.link/tags/打赏/"}]},{"title":"CocoaPods安装过程","date":"2014-12-16T03:21:00.000Z","path":"2014/12/16/CocoaPods/","text":"今天，自己尝试安装了一下CocoaPods，遇到不少问题，这里记录一下，以后也许有用。 安装按照CocoaPods详解之—-使用篇这篇博客的做法，出了一点点小问题，不过后面解决了 步骤如下： 1、在执行安装指令时，我就出现了错误（奔溃了，才刚开始就这么蛋疼~~） 1$ sudo gem install cocoapods 错误信息 ERROR: While executing gem ... (Gem::DependencyError) Unable to resolve dependencies: cocoapods requires cocoapods-core (= 0.35.0), claide (~&gt; 0.7.0), xcodeproj (~&gt; 0.20.2), cocoapods-downloader (~&gt; 0.8.0) 于是我在网上找到了一个解决办法： 先输入 1$ gem update --system 【注】如果出现权限问题FilePermissionError就加上sudo 2、执行setup步骤时，也出现问题。。。我的RP真不好1$ pod setup 错误信息 [!] /usr/bin/git clone &apos;https://github.com/CocoaPods/Specs.git&apos; master --depth=1 Cloning into &apos;master&apos;... error: RPC failed; result=52, HTTP code = 0 fatal: The remote end hung up unexpectedly 再次网上人肉答案，真被我找到一个了，说是osx10.10的问题： osx升级到10.10后，用pod install报错最终解决办法 执行完里面八个步骤，一切正常，可以使用了！！高兴~~ 升级版本既然已经安装了CocoaPods，那么就需要懂得以后更新CocoaPods版本。 12345678///查看CocoaPods版本$ pod --version0.39.0///安装最新版cocoapods$ sudo gem install cocoapods$ pod setup 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"终端","slug":"终端","permalink":"superdanny.link/tags/终端/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"superdanny.link/tags/CocoaPods/"}]},{"title":"iOS8 TabBarItem设置自定义图片问题","date":"2014-10-10T15:16:00.000Z","path":"2014/10/10/iOS8-TabBarItem-setting-custom-image/","text":"iOS8以前使用的方法 查看API之后看到使用了新的API方法来初始化tabBarItem iOS8以前使用的方法1234567891011UITabBarItem *photoItem = [[UITabBarItem alloc] initWithTitle:@\"首页\"image:[UIImage imageNamed:@\"app2\"]tag:0];photo.tabBarItem = photoItem;[photo.tabBarItem setFinishedSelectedImage:[UIImage imageNamed:@\"app1\"]withFinishedUnselectedImage:[UIImage imageNamed:@\"app2\"]];[photoItem release]; 查看API之后看到使用了新的API方法来初始化tabBarItem123- (instancetype)initWithTitle:(NSString *)titleimage:(UIImage *)imageselectedImage:(UIImage *)selectedImage 同时对使用的UIImage设置其UIImageRenderingMode属性为UIImageRenderingModeAlwaysOriginal For example： 12345678UIImage * normalImage = [[UIImage imageNamed:@\"nor.png\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];UIImage * selectImage = [[UIImage imageNamed:@\"select.png\"]imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];UITabBarItem * tabBarItem = [[UITabBarItem alloc] initWithTitle:@\"\"imageormalImageselectedImage:selectImage]; 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]},{"title":"十分钟让你明白Objective-C的语法（和Java、C++的对比）","date":"2014-08-21T05:46:00.000Z","path":"2014/08/21/Quickly-master-objective-c-grammar/","text":"一、函数的对比 二、消息 三、Import 四 、Property和Synthesize 五、头文件中的方法 六、self 指向自己的指针 [self method] 七、继承关系和接口实现 八、空指针 九、 id 很多想开发iOS，或者正在开发iOS的程序员以前都做过Java或者C++，当第一次看到Objective-C的代码时都会头疼，Objective-C的代码在语法上和Java, C++有着很大的区别，有的同学会感觉像是看天书一样。不过，语言都是相通的，有很多共性。下面列出Objective-C语言的语法和Java，C++的对比，这样你就会很容易Objective-C的语法是怎么回事了。 先目睹一下Objective-C头文件和实现文件里都有什么： 头文件： 实现文件： 一、函数的对比helloworld方法 Java 语言： 1234public void helloWorld(bool ishelloworld) &#123; //干点啥&#125; C++语言： 1234void helloWorld(bool ishelloworld)&#123; //干点啥&#125; Objective-C语言： 1234- (void)HelloWorld:(BOOL)ishelloworld&#123; //干点啥&#125; 前面带有减号(-) 的方法为实例方法，必须使用类的实例才可以调用的。对应的有+号， 代表是类的静态方法，不需要实例化即可调用。 二、消息消息的定义：向对象发送信息 消息是iOS的运行时环境特有的机制。 和C++，Java下的类，或实例调用类或实例的方法类似。我这说的是类似，他们的机制实际上是有些差别的。 例子：1234[object message];[object message:param1 withParameter:param2];NSString *string; string = [[NSString alloc] initWithString:@\"Hello\"]; 上面的代码类似于：1234567//java/c++object.message()//java/c++object.message(param1,param2)//java/c++string *str;str = new string(\"Hello\"); 三、Import例子： 123import \"Class.h\"import &lt;Class.h&gt;import &lt;director/Class.h&gt; 这个和C++里的include，java的import类似 四 、Property 和SynthesizeProperty定义：@property 声明用于自动创建property属性变量的getter和setter Synthesize定义：@Synthesize声明实现了property属性变量的getter和setter。 例子: 在 interface：@property dataType variableName 在 implementation: synthesiz variableName 五、头文件中的方法例子：在头文件中声明方法 1234- (returnType)method- (returnType)method:(dataType)param1- (returnType)method:(dataType)param1withParam:(dataType)param2 类似于: C/C++/Java 123returnType method()returnType method(param1)returnType method(param1,param2) 六、self 指向自己的指针 [self method]类似于：c++/java this.method(); 七、继承关系和接口实现例子： ClassA:ParentA ClassA:ParentA ClassA 类似于: java: ClassA extends ParentA ClassA extends ParentA implements interface ClassA implements interfaceObjective-C的Protocol和c++、java的接口类似。 八、空指针123//nil相当与Java中的nullid obj = nil;NSString *hello = nil; 九、idobjective-c的和C++里的(void*)类似 再一次感谢您花费时间阅读这篇文章！ 微博： @Danny_吕昌辉博客： SuperDanny","tags":[{"name":"iOS","slug":"iOS","permalink":"superdanny.link/tags/iOS/"}]}]